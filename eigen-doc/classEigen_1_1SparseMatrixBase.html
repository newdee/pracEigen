<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Eigen: Eigen::SparseMatrixBase&lt; Derived &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="eigendoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Eigen_Silly_Professor_64x64.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://eigen.tuxfamily.org">Eigen</a>
   &#160;<span id="projectnumber">3.3.7</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classEigen_1_1SparseMatrixBase.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classEigen_1_1SparseMatrixBase-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Eigen::SparseMatrixBase&lt; Derived &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__Sparse__chapter.html">Sparse linear algebra</a> &raquo; <a class="el" href="group__Sparse__Reference.html">Reference</a> &raquo; <a class="el" href="group__SparseCore__Module.html">SparseCore module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Derived&gt;<br />
class Eigen::SparseMatrixBase&lt; Derived &gt;</h3>

<p>Base class of any sparse matrices or sparse expressions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>is the derived type, e.g. a sparse matrix type, or an expression, etc.</td></tr>
  </table>
  </dd>
</dl>
<p>This class can be extended with the help of the plugin mechanism described on the page <a class="el" href="TopicCustomizing_Plugins.html">Extending MatrixBase (and other classes)</a> by defining the preprocessor symbol <code>EIGEN_SPARSEMATRIXBASE_PLUGIN</code>. </p>
</div><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Eigen::SparseMatrixBase&lt; Derived &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classEigen_1_1SparseMatrixBase__inherit__graph.png" border="0" usemap="#Eigen_1_1SparseMatrixBase_3_01Derived_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="Eigen_1_1SparseMatrixBase_3_01Derived_01_4_inherit__map" id="Eigen_1_1SparseMatrixBase_3_01Derived_01_4_inherit__map">
<area shape="rect" id="node3" href="classEigen_1_1SparseCompressedBase.html" title="Common base class for sparse [compressed]&#45;{row|column}&#45;storage format. " alt="" coords="590,623,798,905"/>
<area shape="rect" id="node2" href="structEigen_1_1EigenBase.html" title="{Eigen::EigenBase\&lt; Derived \&gt;\n||+ addTo()\l+ applyThisOnTheLeft()\l+ applyThisOnTheRight()\l+ cols()\l+ const_cast_derived()\l+ const_derived()\l+ derived()\l+ derived()\l+ evalTo()\l+ rows()\l+ size()\l+ subTo()\l}" alt="" coords="597,5,791,244"/>
<area shape="rect" id="node4" href="classEigen_1_1SparseMapBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html" title="Common base class for Map and Ref instance of sparse matrix and vector. " alt="" coords="185,961,403,1302"/>
<area shape="rect" id="node9" href="classEigen_1_1SparseMatrix.html" title="{SparseMatrix\&lt; Scalar \&gt;\n|# m_data\l# m_innerNonZeros\l# m_innerSize\l# m_outerIndex\l# m_outerSize\l|+ coeff()\l+ coeffRef()\l+ collapseDuplicates()\l+ cols()\l+ conservativeResize()\l+ data()\l+ data()\l+ diagonal()\l+ diagonal()\l+ finalize()\land 46 more...\l# initAssignment()\l# insertCompressed()\l# insertUncompressed()\l# reserveInnerVectors()\l}" alt="" coords="428,961,589,1302"/>
<area shape="rect" id="node10" href="classEigen_1_1SparseMatrix.html" title="{SparseMatrix\&lt; Scalar,\l ColMajor, int \&gt;\n|# m_data\l# m_innerNonZeros\l# m_innerSize\l# m_outerIndex\l# m_outerSize\l|+ coeff()\l+ coeffRef()\l+ collapseDuplicates()\l+ cols()\l+ conservativeResize()\l+ data()\l+ data()\l+ diagonal()\l+ diagonal()\l+ finalize()\land 46 more...\l# initAssignment()\l# insertCompressed()\l# insertUncompressed()\l# reserveInnerVectors()\l}" alt="" coords="613,953,775,1309"/>
<area shape="rect" id="node11" href="classEigen_1_1SparseMatrix.html" title="{SparseMatrix\&lt; Scalar,\l ColMajor, StorageIndex \&gt;\n|# m_data\l# m_innerNonZeros\l# m_innerSize\l# m_outerIndex\l# m_outerSize\l|+ coeff()\l+ coeffRef()\l+ collapseDuplicates()\l+ cols()\l+ conservativeResize()\l+ data()\l+ data()\l+ diagonal()\l+ diagonal()\l+ finalize()\land 46 more...\l# initAssignment()\l# insertCompressed()\l# insertUncompressed()\l# reserveInnerVectors()\l}" alt="" coords="799,953,973,1309"/>
<area shape="rect" id="node12" href="classEigen_1_1SparseMatrix.html" title="{SparseMatrix\&lt; Scalar,\l RowMajor, StorageIndex \&gt;\n|# m_data\l# m_innerNonZeros\l# m_innerSize\l# m_outerIndex\l# m_outerSize\l|+ coeff()\l+ coeffRef()\l+ collapseDuplicates()\l+ cols()\l+ conservativeResize()\l+ data()\l+ data()\l+ diagonal()\l+ diagonal()\l+ finalize()\land 46 more...\l# initAssignment()\l# insertCompressed()\l# insertUncompressed()\l# reserveInnerVectors()\l}" alt="" coords="997,953,1180,1309"/>
<area shape="rect" id="node5" href="classEigen_1_1SparseMapBase_3_01Derived_00_01WriteAccessors_01_4.html" title="Common base class for writable Map and Ref instance of sparse matrix and vector. " alt="" coords="198,1357,390,1625"/>
<area shape="rect" id="node6" href="classEigen_1_1Map_3_01SparseMatrixType_01_4.html" title="Specialization of class Map for SparseMatrix&#45;like storage. " alt="" coords="5,1673,183,1795"/>
<area shape="rect" id="node7" href="classEigen_1_1Ref_3_01SparseMatrixType_00_01Options_01_4.html" title="A sparse matrix expression referencing an existing sparse expression. " alt="" coords="207,1688,381,1780"/>
<area shape="rect" id="node8" href="classEigen_1_1Ref_3_01SparseVectorType_01_4.html" title="A sparse vector expression referencing an existing sparse vector expression. " alt="" coords="405,1688,580,1780"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae1c24c2182e40e95345506a9a156132b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="classEigen_1_1SparseMatrixBase.html#ae1c24c2182e40e95345506a9a156132ba456cda7b9d938e57194036a41d634604">RowsAtCompileTime</a>, 
<br />
&#160;&#160;<a class="el" href="classEigen_1_1SparseMatrixBase.html#ae1c24c2182e40e95345506a9a156132ba27ba349f075d026c1f51d1ec69aa5b14">ColsAtCompileTime</a>, 
<br />
&#160;&#160;<a class="el" href="classEigen_1_1SparseMatrixBase.html#ae1c24c2182e40e95345506a9a156132baa5022cfa2bb53129883e9b7b8abd3d68">SizeAtCompileTime</a>
, <br />
&#160;&#160;<a class="el" href="classEigen_1_1SparseMatrixBase.html#ae1c24c2182e40e95345506a9a156132ba14a3f566ed2a074beddb8aef0223bfdf">IsVectorAtCompileTime</a>, 
<br />
&#160;&#160;<a class="el" href="classEigen_1_1SparseMatrixBase.html#ae1c24c2182e40e95345506a9a156132ba2af043b36fe9e08df0107cf6de496165">Flags</a>
<br />
 }</td></tr>
<tr class="separator:ae1c24c2182e40e95345506a9a156132b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b540ba724726ebe953f8c0df06081ed"><td class="memItemLeft" align="right" valign="top">typedef internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a></td></tr>
<tr class="separator:a0b540ba724726ebe953f8c0df06081ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac254d3b61718ebc2136d27bac043dcb7"><td class="memItemLeft" align="right" valign="top">typedef Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#ac254d3b61718ebc2136d27bac043dcb7">value_type</a></td></tr>
<tr class="separator:ac254d3b61718ebc2136d27bac043dcb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structEigen_1_1EigenBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structEigen_1_1EigenBase')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="structEigen_1_1EigenBase.html">Eigen::EigenBase&lt; Derived &gt;</a></td></tr>
<tr class="memitem:a554f30542cc2316add4b1ea0a492ff02 inherit pub_types_structEigen_1_1EigenBase"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a></td></tr>
<tr class="memdesc:a554f30542cc2316add4b1ea0a492ff02 inherit pub_types_structEigen_1_1EigenBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The interface type of indices.  <a href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">More...</a><br /></td></tr>
<tr class="separator:a554f30542cc2316add4b1ea0a492ff02 inherit pub_types_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaa71e627acbc873db1885d0fb72189a6"><td class="memTemplParams" colspan="2">template&lt;typename CustomBinaryOp , typename OtherDerived &gt; </td></tr>
<tr class="memitem:aaa71e627acbc873db1885d0fb72189a6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; CustomBinaryOp, const Derived, const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#aaa71e627acbc873db1885d0fb72189a6">binaryExpr</a> (const <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other, const CustomBinaryOp &amp;func=CustomBinaryOp()) const</td></tr>
<tr class="separator:aaa71e627acbc873db1885d0fb72189a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3410aafaa1676e555080cdecd905e03"><td class="memItemLeft" align="right" valign="top">BlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startRow, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startCol, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> blockRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> blockCols)</td></tr>
<tr class="separator:af3410aafaa1676e555080cdecd905e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ce09e08cf42b2d895c40175f480599"><td class="memItemLeft" align="right" valign="top"><a id="a79ce09e08cf42b2d895c40175f480599"></a>
const ConstBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a79ce09e08cf42b2d895c40175f480599">block</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startRow, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startCol, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> blockRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> blockCols) const</td></tr>
<tr class="memdesc:a79ce09e08cf42b2d895c40175f480599"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block(Index,Index,Index,Index)</a>. */. <br /></td></tr>
<tr class="separator:a79ce09e08cf42b2d895c40175f480599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a422f30777a88d280daeb9a1496f074"><td class="memTemplParams" colspan="2">template&lt;int NRows, int NCols&gt; </td></tr>
<tr class="memitem:a3a422f30777a88d280daeb9a1496f074"><td class="memTemplItemLeft" align="right" valign="top">FixedBlockXpr&lt; NRows, NCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a3a422f30777a88d280daeb9a1496f074">block</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startRow, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startCol)</td></tr>
<tr class="separator:a3a422f30777a88d280daeb9a1496f074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9808042bbbc011affa3636915db1533"><td class="memTemplParams" colspan="2"><a id="ad9808042bbbc011affa3636915db1533"></a>
template&lt;int NRows, int NCols&gt; </td></tr>
<tr class="memitem:ad9808042bbbc011affa3636915db1533"><td class="memTemplItemLeft" align="right" valign="top">const ConstFixedBlockXpr&lt; NRows, NCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#ad9808042bbbc011affa3636915db1533">block</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startRow, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startCol) const</td></tr>
<tr class="memdesc:ad9808042bbbc011affa3636915db1533"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#a3a422f30777a88d280daeb9a1496f074">block&lt;&gt;(Index, Index)</a>. */. <br /></td></tr>
<tr class="separator:ad9808042bbbc011affa3636915db1533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1b6971a06d23d6e51057ce04192517"><td class="memTemplParams" colspan="2">template&lt;int NRows, int NCols&gt; </td></tr>
<tr class="memitem:abb1b6971a06d23d6e51057ce04192517"><td class="memTemplItemLeft" align="right" valign="top">FixedBlockXpr&lt; NRows, NCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#abb1b6971a06d23d6e51057ce04192517">block</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startRow, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startCol, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> blockRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> blockCols)</td></tr>
<tr class="separator:abb1b6971a06d23d6e51057ce04192517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928c458f6cd7b169a80691bd01ad3d9a"><td class="memTemplParams" colspan="2"><a id="a928c458f6cd7b169a80691bd01ad3d9a"></a>
template&lt;int NRows, int NCols&gt; </td></tr>
<tr class="memitem:a928c458f6cd7b169a80691bd01ad3d9a"><td class="memTemplItemLeft" align="right" valign="top">const ConstFixedBlockXpr&lt; NRows, NCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a928c458f6cd7b169a80691bd01ad3d9a">block</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startRow, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startCol, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> blockRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> blockCols) const</td></tr>
<tr class="memdesc:a928c458f6cd7b169a80691bd01ad3d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block&lt;&gt;(Index, Index, Index, Index)</a>. <br /></td></tr>
<tr class="separator:a928c458f6cd7b169a80691bd01ad3d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df62282ce9b4eb1210f0b844ff01fb5"><td class="memItemLeft" align="right" valign="top">BlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a1df62282ce9b4eb1210f0b844ff01fb5">bottomLeftCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols)</td></tr>
<tr class="separator:a1df62282ce9b4eb1210f0b844ff01fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6651d95a19494073e03a13ceeafa660"><td class="memItemLeft" align="right" valign="top"><a id="ac6651d95a19494073e03a13ceeafa660"></a>
const ConstBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#ac6651d95a19494073e03a13ceeafa660">bottomLeftCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols) const</td></tr>
<tr class="memdesc:ac6651d95a19494073e03a13ceeafa660"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#a1df62282ce9b4eb1210f0b844ff01fb5">bottomLeftCorner(Index, Index)</a>. <br /></td></tr>
<tr class="separator:ac6651d95a19494073e03a13ceeafa660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa42c135390593b8b32ab45b390b719a"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:afa42c135390593b8b32ab45b390b719a"><td class="memTemplItemLeft" align="right" valign="top">FixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#afa42c135390593b8b32ab45b390b719a">bottomLeftCorner</a> ()</td></tr>
<tr class="separator:afa42c135390593b8b32ab45b390b719a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac9c9d3a40e1e8469c3e6b18fb9b202"><td class="memTemplParams" colspan="2"><a id="a9ac9c9d3a40e1e8469c3e6b18fb9b202"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a9ac9c9d3a40e1e8469c3e6b18fb9b202"><td class="memTemplItemLeft" align="right" valign="top">const ConstFixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a9ac9c9d3a40e1e8469c3e6b18fb9b202">bottomLeftCorner</a> () const</td></tr>
<tr class="memdesc:a9ac9c9d3a40e1e8469c3e6b18fb9b202"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#afa42c135390593b8b32ab45b390b719a">bottomLeftCorner&lt;int, int&gt;()</a>. <br /></td></tr>
<tr class="separator:a9ac9c9d3a40e1e8469c3e6b18fb9b202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad619814d6d694e347d9cf5d7302057a9"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:ad619814d6d694e347d9cf5d7302057a9"><td class="memTemplItemLeft" align="right" valign="top">FixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#ad619814d6d694e347d9cf5d7302057a9">bottomLeftCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols)</td></tr>
<tr class="separator:ad619814d6d694e347d9cf5d7302057a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6269d34c9bb1277d1470d0c948361a81"><td class="memTemplParams" colspan="2"><a id="a6269d34c9bb1277d1470d0c948361a81"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a6269d34c9bb1277d1470d0c948361a81"><td class="memTemplItemLeft" align="right" valign="top">const ConstFixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a6269d34c9bb1277d1470d0c948361a81">bottomLeftCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols) const</td></tr>
<tr class="memdesc:a6269d34c9bb1277d1470d0c948361a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#a1df62282ce9b4eb1210f0b844ff01fb5">bottomLeftCorner&lt;int, int&gt;(Index, Index)</a>. <br /></td></tr>
<tr class="separator:a6269d34c9bb1277d1470d0c948361a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886654a41fc6290236125725838aea2b"><td class="memItemLeft" align="right" valign="top">BlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a886654a41fc6290236125725838aea2b">bottomRightCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols)</td></tr>
<tr class="separator:a886654a41fc6290236125725838aea2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c89e69dc50371be59b18936aea3ab81"><td class="memItemLeft" align="right" valign="top"><a id="a4c89e69dc50371be59b18936aea3ab81"></a>
const ConstBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a4c89e69dc50371be59b18936aea3ab81">bottomRightCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols) const</td></tr>
<tr class="memdesc:a4c89e69dc50371be59b18936aea3ab81"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#a886654a41fc6290236125725838aea2b">bottomRightCorner(Index, Index)</a>. <br /></td></tr>
<tr class="separator:a4c89e69dc50371be59b18936aea3ab81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161556f95a4ae01e5fda7c79bb3e04f2"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a161556f95a4ae01e5fda7c79bb3e04f2"><td class="memTemplItemLeft" align="right" valign="top">FixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a161556f95a4ae01e5fda7c79bb3e04f2">bottomRightCorner</a> ()</td></tr>
<tr class="separator:a161556f95a4ae01e5fda7c79bb3e04f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13637dee81a193bd9a631d0e0f5572b2"><td class="memTemplParams" colspan="2"><a id="a13637dee81a193bd9a631d0e0f5572b2"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a13637dee81a193bd9a631d0e0f5572b2"><td class="memTemplItemLeft" align="right" valign="top">const ConstFixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a13637dee81a193bd9a631d0e0f5572b2">bottomRightCorner</a> () const</td></tr>
<tr class="memdesc:a13637dee81a193bd9a631d0e0f5572b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#a161556f95a4ae01e5fda7c79bb3e04f2">bottomRightCorner&lt;int, int&gt;()</a>. <br /></td></tr>
<tr class="separator:a13637dee81a193bd9a631d0e0f5572b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a544a89365beaa479e628ebda6d3a93"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a1a544a89365beaa479e628ebda6d3a93"><td class="memTemplItemLeft" align="right" valign="top">FixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a1a544a89365beaa479e628ebda6d3a93">bottomRightCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols)</td></tr>
<tr class="separator:a1a544a89365beaa479e628ebda6d3a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752c59896582b0c654d24362f3799b68"><td class="memTemplParams" colspan="2"><a id="a752c59896582b0c654d24362f3799b68"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a752c59896582b0c654d24362f3799b68"><td class="memTemplItemLeft" align="right" valign="top">const ConstFixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a752c59896582b0c654d24362f3799b68">bottomRightCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols) const</td></tr>
<tr class="memdesc:a752c59896582b0c654d24362f3799b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#a886654a41fc6290236125725838aea2b">bottomRightCorner&lt;int, int&gt;(Index, Index)</a>. <br /></td></tr>
<tr class="separator:a752c59896582b0c654d24362f3799b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79baf99d957a7b32169acbe18d1d89c"><td class="memItemLeft" align="right" valign="top">RowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#aa79baf99d957a7b32169acbe18d1d89c">bottomRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n)</td></tr>
<tr class="separator:aa79baf99d957a7b32169acbe18d1d89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a265019db27b9f22e978023171ed07"><td class="memItemLeft" align="right" valign="top"><a id="a73a265019db27b9f22e978023171ed07"></a>
ConstRowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a73a265019db27b9f22e978023171ed07">bottomRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n) const</td></tr>
<tr class="memdesc:a73a265019db27b9f22e978023171ed07"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#aa79baf99d957a7b32169acbe18d1d89c">bottomRows(Index)</a>. <br /></td></tr>
<tr class="separator:a73a265019db27b9f22e978023171ed07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e2afd4e6a4939f488afbfe3b5cf8c0"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ac0e2afd4e6a4939f488afbfe3b5cf8c0"><td class="memTemplItemLeft" align="right" valign="top">NRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#ac0e2afd4e6a4939f488afbfe3b5cf8c0">bottomRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N)</td></tr>
<tr class="separator:ac0e2afd4e6a4939f488afbfe3b5cf8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb59ce4f9e75ea309f78630e5aaafc67"><td class="memTemplParams" colspan="2"><a id="abb59ce4f9e75ea309f78630e5aaafc67"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:abb59ce4f9e75ea309f78630e5aaafc67"><td class="memTemplItemLeft" align="right" valign="top">ConstNRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#abb59ce4f9e75ea309f78630e5aaafc67">bottomRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N) const</td></tr>
<tr class="memdesc:abb59ce4f9e75ea309f78630e5aaafc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#aa79baf99d957a7b32169acbe18d1d89c">bottomRows&lt;int&gt;()</a>. <br /></td></tr>
<tr class="separator:abb59ce4f9e75ea309f78630e5aaafc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f1053a230f80f9e3ae8a9e1963e3c9"><td class="memTemplParams" colspan="2">template&lt;typename NewType &gt; </td></tr>
<tr class="memitem:ad2f1053a230f80f9e3ae8a9e1963e3c9"><td class="memTemplItemLeft" align="right" valign="top">CastXpr&lt; NewType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#ad2f1053a230f80f9e3ae8a9e1963e3c9">cast</a> () const</td></tr>
<tr class="separator:ad2f1053a230f80f9e3ae8a9e1963e3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49129f2301063ce046ae071c82610d5"><td class="memItemLeft" align="right" valign="top">ColXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#ad49129f2301063ce046ae071c82610d5">col</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> i)</td></tr>
<tr class="separator:ad49129f2301063ce046ae071c82610d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d181161b91bc84f955f116c536e6334"><td class="memItemLeft" align="right" valign="top"><a id="a4d181161b91bc84f955f116c536e6334"></a>
ConstColXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a4d181161b91bc84f955f116c536e6334">col</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> i) const</td></tr>
<tr class="memdesc:a4d181161b91bc84f955f116c536e6334"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#ad49129f2301063ce046ae071c82610d5">col()</a>. <br /></td></tr>
<tr class="separator:a4d181161b91bc84f955f116c536e6334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7ce296424ef6e478ab0fb19547a7ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#aca7ce296424ef6e478ab0fb19547a7ee">cols</a> () const</td></tr>
<tr class="separator:aca7ce296424ef6e478ab0fb19547a7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5786b847d59be644984e6ec30d2e35c0"><td class="memItemLeft" align="right" valign="top">ConjugateReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a5786b847d59be644984e6ec30d2e35c0">conjugate</a> () const</td></tr>
<tr class="memdesc:a5786b847d59be644984e6ec30d2e35c0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
  <a href="#a5786b847d59be644984e6ec30d2e35c0">More...</a><br /></td></tr>
<tr class="separator:a5786b847d59be644984e6ec30d2e35c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc11609ee20c2e103b42f2fda9b6fd7a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseAbsReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#afc11609ee20c2e103b42f2fda9b6fd7a">cwiseAbs</a> () const</td></tr>
<tr class="separator:afc11609ee20c2e103b42f2fda9b6fd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae719d8a727660cb6469070b338499f08"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseAbs2ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#ae719d8a727660cb6469070b338499f08">cwiseAbs2</a> () const</td></tr>
<tr class="separator:ae719d8a727660cb6469070b338499f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb20e383a14f049736de22c8b333695"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a3eb20e383a14f049736de22c8b333695"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; std::equal_to&lt; Scalar &gt;, const Derived, const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a3eb20e383a14f049736de22c8b333695">cwiseEqual</a> (const <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a3eb20e383a14f049736de22c8b333695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf4659b7df3458fb7491ac3132f6cdb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseScalarEqualReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#abbf4659b7df3458fb7491ac3132f6cdb">cwiseEqual</a> (const Scalar &amp;s) const</td></tr>
<tr class="separator:abbf4659b7df3458fb7491ac3132f6cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703fdd06c4802869bd1682f4b06eda2c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseInverseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a703fdd06c4802869bd1682f4b06eda2c">cwiseInverse</a> () const</td></tr>
<tr class="separator:a703fdd06c4802869bd1682f4b06eda2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d944efb685a27c2dfcf59a07f4d2fdd"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a4d944efb685a27c2dfcf59a07f4d2fdd"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_max_op&lt; Scalar, Scalar &gt;, const Derived, const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a4d944efb685a27c2dfcf59a07f4d2fdd">cwiseMax</a> (const <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a4d944efb685a27c2dfcf59a07f4d2fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724916ecda447e958944991767ac1f97"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_max_op&lt; Scalar, Scalar &gt;, const Derived, const ConstantReturnType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a724916ecda447e958944991767ac1f97">cwiseMax</a> (const Scalar &amp;other) const</td></tr>
<tr class="separator:a724916ecda447e958944991767ac1f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28d8003e305b4877d795432484cc73a"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:af28d8003e305b4877d795432484cc73a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_min_op&lt; Scalar, Scalar &gt;, const Derived, const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#af28d8003e305b4877d795432484cc73a">cwiseMin</a> (const <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:af28d8003e305b4877d795432484cc73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6acc24a2f2388959407e0ec6ecc7551"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_min_op&lt; Scalar, Scalar &gt;, const Derived, const ConstantReturnType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#ac6acc24a2f2388959407e0ec6ecc7551">cwiseMin</a> (const Scalar &amp;other) const</td></tr>
<tr class="separator:ac6acc24a2f2388959407e0ec6ecc7551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9596ff9f731a708010da9e876ee6ad09"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a9596ff9f731a708010da9e876ee6ad09"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; std::not_equal_to&lt; Scalar &gt;, const Derived, const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a9596ff9f731a708010da9e876ee6ad09">cwiseNotEqual</a> (const <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a9596ff9f731a708010da9e876ee6ad09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5654574942f40fc222297af1ebf62d"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a5f5654574942f40fc222297af1ebf62d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_product_op&lt; Derived ::Scalar, OtherDerived ::Scalar &gt;, const Derived, const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a5f5654574942f40fc222297af1ebf62d">cwiseProduct</a> (const <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a5f5654574942f40fc222297af1ebf62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914f7db22f9010c2288098be79b7e478"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a914f7db22f9010c2288098be79b7e478"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_quotient_op&lt; Scalar &gt;, const Derived, const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a914f7db22f9010c2288098be79b7e478">cwiseQuotient</a> (const <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a914f7db22f9010c2288098be79b7e478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86f1aa7e8855072a1b5f6fdc6573567"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseSignReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#ae86f1aa7e8855072a1b5f6fdc6573567">cwiseSign</a> () const</td></tr>
<tr class="separator:ae86f1aa7e8855072a1b5f6fdc6573567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f979e103dd39e8cac8505254d190c2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseSqrtReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a43f979e103dd39e8cac8505254d190c2">cwiseSqrt</a> () const</td></tr>
<tr class="separator:a43f979e103dd39e8cac8505254d190c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761bd872a06b59632fcff7b7807a77ce"><td class="memItemLeft" align="right" valign="top">const internal::eval&lt; Derived &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a761bd872a06b59632fcff7b7807a77ce">eval</a> () const</td></tr>
<tr class="separator:a761bd872a06b59632fcff7b7807a77ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1314ea2bd1e1d2030a1e42e5240b3b"><td class="memItemLeft" align="right" valign="top">SegmentReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#abe1314ea2bd1e1d2030a1e42e5240b3b">head</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n)</td></tr>
<tr class="separator:abe1314ea2bd1e1d2030a1e42e5240b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa092867646b5b5fe37cc8a4ae25f4f87"><td class="memItemLeft" align="right" valign="top"><a id="aa092867646b5b5fe37cc8a4ae25f4f87"></a>
ConstSegmentReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#aa092867646b5b5fe37cc8a4ae25f4f87">head</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n) const</td></tr>
<tr class="memdesc:aa092867646b5b5fe37cc8a4ae25f4f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#abe1314ea2bd1e1d2030a1e42e5240b3b">head(Index)</a>. <br /></td></tr>
<tr class="separator:aa092867646b5b5fe37cc8a4ae25f4f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f5840458a6b52b293cfdd52c28063a"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a77f5840458a6b52b293cfdd52c28063a"><td class="memTemplItemLeft" align="right" valign="top">FixedSegmentReturnType&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a77f5840458a6b52b293cfdd52c28063a">head</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N)</td></tr>
<tr class="separator:a77f5840458a6b52b293cfdd52c28063a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9d0d4851aed8261f0bbefa67f4b35a"><td class="memTemplParams" colspan="2"><a id="aea9d0d4851aed8261f0bbefa67f4b35a"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:aea9d0d4851aed8261f0bbefa67f4b35a"><td class="memTemplItemLeft" align="right" valign="top">ConstFixedSegmentReturnType&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#aea9d0d4851aed8261f0bbefa67f4b35a">head</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N) const</td></tr>
<tr class="memdesc:aea9d0d4851aed8261f0bbefa67f4b35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#abe1314ea2bd1e1d2030a1e42e5240b3b">head&lt;int&gt;()</a>. <br /></td></tr>
<tr class="separator:aea9d0d4851aed8261f0bbefa67f4b35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20e914fe0dd4b2490102f48b050f1bb"><td class="memItemLeft" align="right" valign="top">const ImagReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#ad20e914fe0dd4b2490102f48b050f1bb">imag</a> () const</td></tr>
<tr class="memdesc:ad20e914fe0dd4b2490102f48b050f1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
  <a href="#ad20e914fe0dd4b2490102f48b050f1bb">More...</a><br /></td></tr>
<tr class="separator:ad20e914fe0dd4b2490102f48b050f1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2948b3eeefeb4757f7d4039de074e89"><td class="memItemLeft" align="right" valign="top">NonConstImagReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#ab2948b3eeefeb4757f7d4039de074e89">imag</a> ()</td></tr>
<tr class="memdesc:ab2948b3eeefeb4757f7d4039de074e89"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
  <a href="#ab2948b3eeefeb4757f7d4039de074e89">More...</a><br /></td></tr>
<tr class="separator:ab2948b3eeefeb4757f7d4039de074e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180fcba1ccf3cdf3252a263bc1de7a1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a180fcba1ccf3cdf3252a263bc1de7a1d">innerSize</a> () const</td></tr>
<tr class="separator:a180fcba1ccf3cdf3252a263bc1de7a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65aaf3b50d205011e2bfa0de24756cce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">InnerVectorReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a65aaf3b50d205011e2bfa0de24756cce">innerVector</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> outer)</td></tr>
<tr class="separator:a65aaf3b50d205011e2bfa0de24756cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1050a842569fcdadf8d936250301e72d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">ConstInnerVectorReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a1050a842569fcdadf8d936250301e72d">innerVector</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> outer) const</td></tr>
<tr class="separator:a1050a842569fcdadf8d936250301e72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c51bf5a7eb18eab9a85949d03aed14a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">InnerVectorsReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a3c51bf5a7eb18eab9a85949d03aed14a">innerVectors</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> outerStart, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="classEigen_1_1SparseMatrixBase.html#ac86cc88a4cfef21db6b64ec0ab4c8f0a">outerSize</a>)</td></tr>
<tr class="separator:a3c51bf5a7eb18eab9a85949d03aed14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6585c991d04c139f2486ab81f56ad1a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">ConstInnerVectorsReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#ae6585c991d04c139f2486ab81f56ad1a">innerVectors</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> outerStart, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="classEigen_1_1SparseMatrixBase.html#ac86cc88a4cfef21db6b64ec0ab4c8f0a">outerSize</a>) const</td></tr>
<tr class="separator:ae6585c991d04c139f2486ab81f56ad1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eedffa867031f649fd0fb9cc23ce4be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a7eedffa867031f649fd0fb9cc23ce4be">isVector</a> () const</td></tr>
<tr class="separator:a7eedffa867031f649fd0fb9cc23ce4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f260bce61944ae8aaad69a68441cc1"><td class="memItemLeft" align="right" valign="top">ColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a45f260bce61944ae8aaad69a68441cc1">leftCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n)</td></tr>
<tr class="separator:a45f260bce61944ae8aaad69a68441cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920bb604eadb65723c24609b636b8e42"><td class="memItemLeft" align="right" valign="top"><a id="a920bb604eadb65723c24609b636b8e42"></a>
ConstColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a920bb604eadb65723c24609b636b8e42">leftCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n) const</td></tr>
<tr class="memdesc:a920bb604eadb65723c24609b636b8e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#a45f260bce61944ae8aaad69a68441cc1">leftCols(Index)</a>. <br /></td></tr>
<tr class="separator:a920bb604eadb65723c24609b636b8e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe9c9b17434027b0949e57951c9af05"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:aebe9c9b17434027b0949e57951c9af05"><td class="memTemplItemLeft" align="right" valign="top">NColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#aebe9c9b17434027b0949e57951c9af05">leftCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N)</td></tr>
<tr class="separator:aebe9c9b17434027b0949e57951c9af05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a26d7a108e2005432f1655071bbec98"><td class="memTemplParams" colspan="2"><a id="a3a26d7a108e2005432f1655071bbec98"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:a3a26d7a108e2005432f1655071bbec98"><td class="memTemplItemLeft" align="right" valign="top">ConstNColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a3a26d7a108e2005432f1655071bbec98">leftCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N) const</td></tr>
<tr class="memdesc:a3a26d7a108e2005432f1655071bbec98"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#a45f260bce61944ae8aaad69a68441cc1">leftCols&lt;int&gt;()</a>. <br /></td></tr>
<tr class="separator:a3a26d7a108e2005432f1655071bbec98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08b7336ad372d17084b8a241fe3ab79"><td class="memItemLeft" align="right" valign="top">ColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#af08b7336ad372d17084b8a241fe3ab79">middleCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startCol, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> numCols)</td></tr>
<tr class="separator:af08b7336ad372d17084b8a241fe3ab79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81fe46f8bbef3c10e6dbe62a45b46995"><td class="memItemLeft" align="right" valign="top"><a id="a81fe46f8bbef3c10e6dbe62a45b46995"></a>
ConstColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a81fe46f8bbef3c10e6dbe62a45b46995">middleCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startCol, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> numCols) const</td></tr>
<tr class="memdesc:a81fe46f8bbef3c10e6dbe62a45b46995"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#af08b7336ad372d17084b8a241fe3ab79">middleCols(Index,Index)</a>. <br /></td></tr>
<tr class="separator:a81fe46f8bbef3c10e6dbe62a45b46995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec625252292e4626e263dd133ccac421"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:aec625252292e4626e263dd133ccac421"><td class="memTemplItemLeft" align="right" valign="top">NColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#aec625252292e4626e263dd133ccac421">middleCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startCol, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N)</td></tr>
<tr class="separator:aec625252292e4626e263dd133ccac421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c6c2249d1602b9dabd86743816480d"><td class="memTemplParams" colspan="2"><a id="aa1c6c2249d1602b9dabd86743816480d"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:aa1c6c2249d1602b9dabd86743816480d"><td class="memTemplItemLeft" align="right" valign="top">ConstNColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#aa1c6c2249d1602b9dabd86743816480d">middleCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startCol, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N) const</td></tr>
<tr class="memdesc:aa1c6c2249d1602b9dabd86743816480d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#af08b7336ad372d17084b8a241fe3ab79">middleCols&lt;int&gt;()</a>. <br /></td></tr>
<tr class="separator:aa1c6c2249d1602b9dabd86743816480d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81def49d91f316d66418f8ad3f801fb"><td class="memItemLeft" align="right" valign="top">RowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#aa81def49d91f316d66418f8ad3f801fb">middleRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startRow, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n)</td></tr>
<tr class="separator:aa81def49d91f316d66418f8ad3f801fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98abc932dc7b6f30c2c03616a1d137e6"><td class="memItemLeft" align="right" valign="top"><a id="a98abc932dc7b6f30c2c03616a1d137e6"></a>
ConstRowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a98abc932dc7b6f30c2c03616a1d137e6">middleRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startRow, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n) const</td></tr>
<tr class="memdesc:a98abc932dc7b6f30c2c03616a1d137e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#aa81def49d91f316d66418f8ad3f801fb">middleRows(Index,Index)</a>. <br /></td></tr>
<tr class="separator:a98abc932dc7b6f30c2c03616a1d137e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4adbdd67164a3753df77a0c2d5eda8"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a4c4adbdd67164a3753df77a0c2d5eda8"><td class="memTemplItemLeft" align="right" valign="top">NRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a4c4adbdd67164a3753df77a0c2d5eda8">middleRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startRow, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N)</td></tr>
<tr class="separator:a4c4adbdd67164a3753df77a0c2d5eda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899e4e88a796facafc878a9238cfa9d9"><td class="memTemplParams" colspan="2"><a id="a899e4e88a796facafc878a9238cfa9d9"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:a899e4e88a796facafc878a9238cfa9d9"><td class="memTemplItemLeft" align="right" valign="top">ConstNRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a899e4e88a796facafc878a9238cfa9d9">middleRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startRow, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N) const</td></tr>
<tr class="memdesc:a899e4e88a796facafc878a9238cfa9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#aa81def49d91f316d66418f8ad3f801fb">middleRows&lt;int&gt;()</a>. <br /></td></tr>
<tr class="separator:a899e4e88a796facafc878a9238cfa9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b575655d7a77f0594cec7a6864e864"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a02b575655d7a77f0594cec7a6864e864"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_boolean_and_op, const Derived, const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a02b575655d7a77f0594cec7a6864e864">operator &amp;&amp;</a> (const <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a02b575655d7a77f0594cec7a6864e864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d549536a2d7bc6a414d66c1e2b305dd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d549536a2d7bc6a414d66c1e2b305dd"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_product_op&lt; Scalar, T &gt;, Derived, Constant&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a4d549536a2d7bc6a414d66c1e2b305dd">operator*</a> (const T &amp;scalar) const</td></tr>
<tr class="separator:a4d549536a2d7bc6a414d66c1e2b305dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4d71b3f34389e6fc01f2b86e43f7a4"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a9d4d71b3f34389e6fc01f2b86e43f7a4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Product.html">Product</a>&lt; Derived, OtherDerived, AliasFreeProduct &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a9d4d71b3f34389e6fc01f2b86e43f7a4">operator*</a> (const <a class="el" href="classEigen_1_1SparseMatrixBase.html">SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a9d4d71b3f34389e6fc01f2b86e43f7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97874c8f3c0a69b0160f0d310b233468"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a97874c8f3c0a69b0160f0d310b233468"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; sum&lt; Scalar &gt;, const Derived, const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a97874c8f3c0a69b0160f0d310b233468">operator+</a> (const <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a97874c8f3c0a69b0160f0d310b233468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118b1aef19fa7231538d94646573b7bc"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a118b1aef19fa7231538d94646573b7bc"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; difference&lt; Scalar &gt;, const Derived, const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a118b1aef19fa7231538d94646573b7bc">operator-</a> (const <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a118b1aef19fa7231538d94646573b7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1fdce454e05bc7c40c0cec7e854fe70"><td class="memItemLeft" align="right" valign="top">const NegativeReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#ab1fdce454e05bc7c40c0cec7e854fe70">operator-</a> () const</td></tr>
<tr class="separator:ab1fdce454e05bc7c40c0cec7e854fe70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30a0ce5a8b71a99bc969fe585e39713"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa30a0ce5a8b71a99bc969fe585e39713"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_quotient_op&lt; Scalar, T &gt;, Derived, Constant&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#aa30a0ce5a8b71a99bc969fe585e39713">operator/</a> (const T &amp;scalar) const</td></tr>
<tr class="separator:aa30a0ce5a8b71a99bc969fe585e39713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81ea3dea5ea37304ea010d511f35088"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:af81ea3dea5ea37304ea010d511f35088"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_boolean_or_op, const Derived, const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#af81ea3dea5ea37304ea010d511f35088">operator||</a> (const <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:af81ea3dea5ea37304ea010d511f35088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86cc88a4cfef21db6b64ec0ab4c8f0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#ac86cc88a4cfef21db6b64ec0ab4c8f0a">outerSize</a> () const</td></tr>
<tr class="separator:ac86cc88a4cfef21db6b64ec0ab4c8f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d0414b56d9d620ce9a698c1b281e5d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1SparseView.html">SparseView</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#ac8d0414b56d9d620ce9a698c1b281e5d">pruned</a> (const Scalar &amp;reference=Scalar(0), const RealScalar &amp;epsilon=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; Scalar &gt;::dummy_precision()) const</td></tr>
<tr class="separator:ac8d0414b56d9d620ce9a698c1b281e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34162b16f185e9f8a39da62087a23665"><td class="memItemLeft" align="right" valign="top">RealReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a34162b16f185e9f8a39da62087a23665">real</a> () const</td></tr>
<tr class="memdesc:a34162b16f185e9f8a39da62087a23665"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
  <a href="#a34162b16f185e9f8a39da62087a23665">More...</a><br /></td></tr>
<tr class="separator:a34162b16f185e9f8a39da62087a23665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3855bebf879e6c4a56f5ce1c25a9a3e3"><td class="memItemLeft" align="right" valign="top">NonConstRealReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a3855bebf879e6c4a56f5ce1c25a9a3e3">real</a> ()</td></tr>
<tr class="memdesc:a3855bebf879e6c4a56f5ce1c25a9a3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
  <a href="#a3855bebf879e6c4a56f5ce1c25a9a3e3">More...</a><br /></td></tr>
<tr class="separator:a3855bebf879e6c4a56f5ce1c25a9a3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89993e50b36a130a5a2d53d8fcd7cba3"><td class="memItemLeft" align="right" valign="top">ColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a89993e50b36a130a5a2d53d8fcd7cba3">rightCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n)</td></tr>
<tr class="separator:a89993e50b36a130a5a2d53d8fcd7cba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358aa7fae323b5e579ea9132671f4cd0"><td class="memItemLeft" align="right" valign="top"><a id="a358aa7fae323b5e579ea9132671f4cd0"></a>
ConstColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a358aa7fae323b5e579ea9132671f4cd0">rightCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n) const</td></tr>
<tr class="memdesc:a358aa7fae323b5e579ea9132671f4cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#a89993e50b36a130a5a2d53d8fcd7cba3">rightCols(Index)</a>. <br /></td></tr>
<tr class="separator:a358aa7fae323b5e579ea9132671f4cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7945204acc8477627f6895140a7c51ef"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a7945204acc8477627f6895140a7c51ef"><td class="memTemplItemLeft" align="right" valign="top">NColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a7945204acc8477627f6895140a7c51ef">rightCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N)</td></tr>
<tr class="separator:a7945204acc8477627f6895140a7c51ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af390fc1cca411fb5b624bafa7e028aa1"><td class="memTemplParams" colspan="2"><a id="af390fc1cca411fb5b624bafa7e028aa1"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:af390fc1cca411fb5b624bafa7e028aa1"><td class="memTemplItemLeft" align="right" valign="top">ConstNColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#af390fc1cca411fb5b624bafa7e028aa1">rightCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N) const</td></tr>
<tr class="memdesc:af390fc1cca411fb5b624bafa7e028aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#a89993e50b36a130a5a2d53d8fcd7cba3">rightCols&lt;int&gt;()</a>. <br /></td></tr>
<tr class="separator:af390fc1cca411fb5b624bafa7e028aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c023d63826ff35698e8e8feac3b24a"><td class="memItemLeft" align="right" valign="top">RowXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a92c023d63826ff35698e8e8feac3b24a">row</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> i)</td></tr>
<tr class="separator:a92c023d63826ff35698e8e8feac3b24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9570fa736f7678600886a1fe1d6a17a"><td class="memItemLeft" align="right" valign="top"><a id="aa9570fa736f7678600886a1fe1d6a17a"></a>
ConstRowXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#aa9570fa736f7678600886a1fe1d6a17a">row</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> i) const</td></tr>
<tr class="memdesc:aa9570fa736f7678600886a1fe1d6a17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#a92c023d63826ff35698e8e8feac3b24a">row()</a>. */. <br /></td></tr>
<tr class="separator:aa9570fa736f7678600886a1fe1d6a17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1944e9fa9ce7937bfc3a87b2cb94371f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a1944e9fa9ce7937bfc3a87b2cb94371f">rows</a> () const</td></tr>
<tr class="separator:a1944e9fa9ce7937bfc3a87b2cb94371f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f22c078139d8a4e9ab9f3c8d037edf0"><td class="memItemLeft" align="right" valign="top">SegmentReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a6f22c078139d8a4e9ab9f3c8d037edf0">segment</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> start, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n)</td></tr>
<tr class="separator:a6f22c078139d8a4e9ab9f3c8d037edf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfce39b5581a87e0cdb9d18539733768"><td class="memItemLeft" align="right" valign="top"><a id="abfce39b5581a87e0cdb9d18539733768"></a>
ConstSegmentReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#abfce39b5581a87e0cdb9d18539733768">segment</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> start, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n) const</td></tr>
<tr class="memdesc:abfce39b5581a87e0cdb9d18539733768"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#a6f22c078139d8a4e9ab9f3c8d037edf0">segment(Index,Index)</a>. <br /></td></tr>
<tr class="separator:abfce39b5581a87e0cdb9d18539733768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced8757cdac6f6463eb65018b337f9e5"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:aced8757cdac6f6463eb65018b337f9e5"><td class="memTemplItemLeft" align="right" valign="top">FixedSegmentReturnType&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#aced8757cdac6f6463eb65018b337f9e5">segment</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> start, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N)</td></tr>
<tr class="separator:aced8757cdac6f6463eb65018b337f9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70310eb90843c2527036f4f63e8d39e7"><td class="memTemplParams" colspan="2"><a id="a70310eb90843c2527036f4f63e8d39e7"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:a70310eb90843c2527036f4f63e8d39e7"><td class="memTemplItemLeft" align="right" valign="top">ConstFixedSegmentReturnType&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a70310eb90843c2527036f4f63e8d39e7">segment</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> start, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N) const</td></tr>
<tr class="memdesc:a70310eb90843c2527036f4f63e8d39e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of segment&lt;int&gt;(Index). <br /></td></tr>
<tr class="separator:a70310eb90843c2527036f4f63e8d39e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124bc57921775eb9aa2dfd9727e23472"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a124bc57921775eb9aa2dfd9727e23472">size</a> () const</td></tr>
<tr class="separator:a124bc57921775eb9aa2dfd9727e23472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33269907b2a9e03cc93618ad076bee4d"><td class="memItemLeft" align="right" valign="top">SegmentReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a33269907b2a9e03cc93618ad076bee4d">tail</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n)</td></tr>
<tr class="separator:a33269907b2a9e03cc93618ad076bee4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb2740ed49726fc60575a9e54ca0401"><td class="memItemLeft" align="right" valign="top"><a id="abfb2740ed49726fc60575a9e54ca0401"></a>
ConstSegmentReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#abfb2740ed49726fc60575a9e54ca0401">tail</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n) const</td></tr>
<tr class="memdesc:abfb2740ed49726fc60575a9e54ca0401"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#a33269907b2a9e03cc93618ad076bee4d">tail(Index)</a>. <br /></td></tr>
<tr class="separator:abfb2740ed49726fc60575a9e54ca0401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada219a98a93845b4c09924d471322853"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ada219a98a93845b4c09924d471322853"><td class="memTemplItemLeft" align="right" valign="top">FixedSegmentReturnType&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#ada219a98a93845b4c09924d471322853">tail</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N)</td></tr>
<tr class="separator:ada219a98a93845b4c09924d471322853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b508da02ec65e7d404425ea47cae29"><td class="memTemplParams" colspan="2"><a id="aa8b508da02ec65e7d404425ea47cae29"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:aa8b508da02ec65e7d404425ea47cae29"><td class="memTemplItemLeft" align="right" valign="top">ConstFixedSegmentReturnType&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#aa8b508da02ec65e7d404425ea47cae29">tail</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N) const</td></tr>
<tr class="memdesc:aa8b508da02ec65e7d404425ea47cae29"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of tail&lt;int&gt;. <br /></td></tr>
<tr class="separator:aa8b508da02ec65e7d404425ea47cae29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2fae971336c83038b5e1e97b49591a"><td class="memItemLeft" align="right" valign="top">BlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a1a2fae971336c83038b5e1e97b49591a">topLeftCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols)</td></tr>
<tr class="separator:a1a2fae971336c83038b5e1e97b49591a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b13cd439325423bdf2711920e3dd1a1"><td class="memItemLeft" align="right" valign="top"><a id="a3b13cd439325423bdf2711920e3dd1a1"></a>
const ConstBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a3b13cd439325423bdf2711920e3dd1a1">topLeftCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols) const</td></tr>
<tr class="memdesc:a3b13cd439325423bdf2711920e3dd1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#a1a2fae971336c83038b5e1e97b49591a">topLeftCorner(Index, Index)</a>. <br /></td></tr>
<tr class="separator:a3b13cd439325423bdf2711920e3dd1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38ce1cb59059bebdf605b2091ea49b9"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:af38ce1cb59059bebdf605b2091ea49b9"><td class="memTemplItemLeft" align="right" valign="top">FixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#af38ce1cb59059bebdf605b2091ea49b9">topLeftCorner</a> ()</td></tr>
<tr class="separator:af38ce1cb59059bebdf605b2091ea49b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74140ddaec2e6442771066e7f5cd49b0"><td class="memTemplParams" colspan="2"><a id="a74140ddaec2e6442771066e7f5cd49b0"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a74140ddaec2e6442771066e7f5cd49b0"><td class="memTemplItemLeft" align="right" valign="top">const ConstFixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a74140ddaec2e6442771066e7f5cd49b0">topLeftCorner</a> () const</td></tr>
<tr class="memdesc:a74140ddaec2e6442771066e7f5cd49b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#af38ce1cb59059bebdf605b2091ea49b9">topLeftCorner&lt;int, int&gt;()</a>. <br /></td></tr>
<tr class="separator:a74140ddaec2e6442771066e7f5cd49b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f09735a100f857c593741840184cefe"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a8f09735a100f857c593741840184cefe"><td class="memTemplItemLeft" align="right" valign="top">FixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a8f09735a100f857c593741840184cefe">topLeftCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols)</td></tr>
<tr class="separator:a8f09735a100f857c593741840184cefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2a17b67327925dc9dab29694f48433"><td class="memTemplParams" colspan="2"><a id="a4d2a17b67327925dc9dab29694f48433"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a4d2a17b67327925dc9dab29694f48433"><td class="memTemplItemLeft" align="right" valign="top">const ConstFixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a4d2a17b67327925dc9dab29694f48433">topLeftCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols) const</td></tr>
<tr class="memdesc:a4d2a17b67327925dc9dab29694f48433"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#a1a2fae971336c83038b5e1e97b49591a">topLeftCorner&lt;int, int&gt;(Index, Index)</a>. <br /></td></tr>
<tr class="separator:a4d2a17b67327925dc9dab29694f48433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f226d90163592659e6f82dd3e3295f"><td class="memItemLeft" align="right" valign="top">BlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a09f226d90163592659e6f82dd3e3295f">topRightCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols)</td></tr>
<tr class="separator:a09f226d90163592659e6f82dd3e3295f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1debf2e68644f144b48a5cbe9235185e"><td class="memItemLeft" align="right" valign="top"><a id="a1debf2e68644f144b48a5cbe9235185e"></a>
const ConstBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a1debf2e68644f144b48a5cbe9235185e">topRightCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols) const</td></tr>
<tr class="memdesc:a1debf2e68644f144b48a5cbe9235185e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#a09f226d90163592659e6f82dd3e3295f">topRightCorner(Index, Index)</a>. <br /></td></tr>
<tr class="separator:a1debf2e68644f144b48a5cbe9235185e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4ccb3c46e55e407bbe316fdebcb659"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a2b4ccb3c46e55e407bbe316fdebcb659"><td class="memTemplItemLeft" align="right" valign="top">FixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a2b4ccb3c46e55e407bbe316fdebcb659">topRightCorner</a> ()</td></tr>
<tr class="separator:a2b4ccb3c46e55e407bbe316fdebcb659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98de5e9fc2d3b8c513223db387fdec55"><td class="memTemplParams" colspan="2"><a id="a98de5e9fc2d3b8c513223db387fdec55"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a98de5e9fc2d3b8c513223db387fdec55"><td class="memTemplItemLeft" align="right" valign="top">const ConstFixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a98de5e9fc2d3b8c513223db387fdec55">topRightCorner</a> () const</td></tr>
<tr class="memdesc:a98de5e9fc2d3b8c513223db387fdec55"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#a2b4ccb3c46e55e407bbe316fdebcb659">topRightCorner&lt;int, int&gt;()</a>. <br /></td></tr>
<tr class="separator:a98de5e9fc2d3b8c513223db387fdec55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafa5d35b2d1bfc9f0cc19f14a0e2c56"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:adafa5d35b2d1bfc9f0cc19f14a0e2c56"><td class="memTemplItemLeft" align="right" valign="top">FixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#adafa5d35b2d1bfc9f0cc19f14a0e2c56">topRightCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols)</td></tr>
<tr class="separator:adafa5d35b2d1bfc9f0cc19f14a0e2c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48496ebbfcd6cb685f893246de1d934"><td class="memTemplParams" colspan="2"><a id="ad48496ebbfcd6cb685f893246de1d934"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:ad48496ebbfcd6cb685f893246de1d934"><td class="memTemplItemLeft" align="right" valign="top">const ConstFixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#ad48496ebbfcd6cb685f893246de1d934">topRightCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols) const</td></tr>
<tr class="memdesc:ad48496ebbfcd6cb685f893246de1d934"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#a09f226d90163592659e6f82dd3e3295f">topRightCorner&lt;int, int&gt;(Index, Index)</a>. <br /></td></tr>
<tr class="separator:ad48496ebbfcd6cb685f893246de1d934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1528bf1b344bbfb216cbae7463454d24"><td class="memItemLeft" align="right" valign="top">RowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a1528bf1b344bbfb216cbae7463454d24">topRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n)</td></tr>
<tr class="separator:a1528bf1b344bbfb216cbae7463454d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe6308ac0e60d2a13c019e0c947e2f1"><td class="memItemLeft" align="right" valign="top"><a id="a8fe6308ac0e60d2a13c019e0c947e2f1"></a>
ConstRowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a8fe6308ac0e60d2a13c019e0c947e2f1">topRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n) const</td></tr>
<tr class="memdesc:a8fe6308ac0e60d2a13c019e0c947e2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#a1528bf1b344bbfb216cbae7463454d24">topRows(Index)</a>. <br /></td></tr>
<tr class="separator:a8fe6308ac0e60d2a13c019e0c947e2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a2b592894cb82fab9e930db8f95117"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a43a2b592894cb82fab9e930db8f95117"><td class="memTemplItemLeft" align="right" valign="top">NRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a43a2b592894cb82fab9e930db8f95117">topRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N)</td></tr>
<tr class="separator:a43a2b592894cb82fab9e930db8f95117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958cda0ac21d50fd2fbc97861f97a0b7"><td class="memTemplParams" colspan="2"><a id="a958cda0ac21d50fd2fbc97861f97a0b7"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:a958cda0ac21d50fd2fbc97861f97a0b7"><td class="memTemplItemLeft" align="right" valign="top">ConstNRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a958cda0ac21d50fd2fbc97861f97a0b7">topRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N) const</td></tr>
<tr class="memdesc:a958cda0ac21d50fd2fbc97861f97a0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1SparseMatrixBase.html#a1528bf1b344bbfb216cbae7463454d24">topRows&lt;int&gt;()</a>. <br /></td></tr>
<tr class="separator:a958cda0ac21d50fd2fbc97861f97a0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d4898bd6a57cc3ba543a39b102423e"><td class="memItemLeft" align="right" valign="top">SparseSymmetricPermutationProduct&lt; Derived, <a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1">Upper</a>|<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749">Lower</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a51d4898bd6a57cc3ba543a39b102423e">twistedBy</a> (const <a class="el" href="classEigen_1_1PermutationMatrix.html">PermutationMatrix</a>&lt; <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a> &gt; &amp;perm) const</td></tr>
<tr class="separator:a51d4898bd6a57cc3ba543a39b102423e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bed5dea96bdaf17ffd1a76ab0aedb1"><td class="memTemplParams" colspan="2">template&lt;typename CustomUnaryOp &gt; </td></tr>
<tr class="memitem:af9bed5dea96bdaf17ffd1a76ab0aedb1"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt; CustomUnaryOp, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#af9bed5dea96bdaf17ffd1a76ab0aedb1">unaryExpr</a> (const CustomUnaryOp &amp;func=CustomUnaryOp()) const</td></tr>
<tr class="memdesc:af9bed5dea96bdaf17ffd1a76ab0aedb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a unary operator coefficient-wise.  <a href="#af9bed5dea96bdaf17ffd1a76ab0aedb1">More...</a><br /></td></tr>
<tr class="separator:af9bed5dea96bdaf17ffd1a76ab0aedb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009918bb363546f107f5bdc1ea0610f3"><td class="memTemplParams" colspan="2">template&lt;typename CustomViewOp &gt; </td></tr>
<tr class="memitem:a009918bb363546f107f5bdc1ea0610f3"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryView.html">CwiseUnaryView</a>&lt; CustomViewOp, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a009918bb363546f107f5bdc1ea0610f3">unaryViewExpr</a> (const CustomViewOp &amp;func=CustomViewOp()) const</td></tr>
<tr class="separator:a009918bb363546f107f5bdc1ea0610f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structEigen_1_1EigenBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structEigen_1_1EigenBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structEigen_1_1EigenBase.html">Eigen::EigenBase&lt; Derived &gt;</a></td></tr>
<tr class="memitem:a16145eb95335754c2ff8b2a58731bc53 inherit pub_methods_structEigen_1_1EigenBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#a16145eb95335754c2ff8b2a58731bc53">cols</a> () const</td></tr>
<tr class="separator:a16145eb95335754c2ff8b2a58731bc53 inherit pub_methods_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbabe7f12bcbfba3b9a448b1f5e46fa inherit pub_methods_structEigen_1_1EigenBase"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#a1fbabe7f12bcbfba3b9a448b1f5e46fa">derived</a> ()</td></tr>
<tr class="separator:a1fbabe7f12bcbfba3b9a448b1f5e46fa inherit pub_methods_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4f3f1c57b7594b96a7e30f2974ea2e inherit pub_methods_structEigen_1_1EigenBase"><td class="memItemLeft" align="right" valign="top">const Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#afd4f3f1c57b7594b96a7e30f2974ea2e">derived</a> () const</td></tr>
<tr class="separator:afd4f3f1c57b7594b96a7e30f2974ea2e inherit pub_methods_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75c2d8a783d055db397319c5a330eee inherit pub_methods_structEigen_1_1EigenBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#ab75c2d8a783d055db397319c5a330eee">rows</a> () const</td></tr>
<tr class="separator:ab75c2d8a783d055db397319c5a330eee inherit pub_methods_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0d244a512a784ded5319bd1a848440 inherit pub_methods_structEigen_1_1EigenBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#adb0d244a512a784ded5319bd1a848440">size</a> () const</td></tr>
<tr class="separator:adb0d244a512a784ded5319bd1a848440 inherit pub_methods_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8fc2c86eca0e76d5264e285ff4eea079"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8fc2c86eca0e76d5264e285ff4eea079"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_product_op&lt; T, Scalar &gt;, Constant&lt; T &gt;, Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html#a8fc2c86eca0e76d5264e285ff4eea079">operator*</a> (const T &amp;scalar, const <a class="el" href="classEigen_1_1SparseMatrixBase.html">StorageBaseType</a> &amp;expr)</td></tr>
<tr class="separator:a8fc2c86eca0e76d5264e285ff4eea079"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0b540ba724726ebe953f8c0df06081ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b540ba724726ebe953f8c0df06081ed">&#9670;&nbsp;</a></span>StorageIndex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::traits&lt;Derived&gt;::<a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a> <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The integer type used to <b>store</b> indices within a <a class="el" href="classEigen_1_1SparseMatrix.html" title="A versatible sparse matrix representation. ">SparseMatrix</a>. For a <code>SparseMatrix&lt;Scalar,Options,IndexType&gt;</code> it an alias of the third template parameter <code>IndexType</code>. </p>

</div>
</div>
<a id="ac254d3b61718ebc2136d27bac043dcb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac254d3b61718ebc2136d27bac043dcb7">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Scalar <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1SparseMatrixBase.html#ac254d3b61718ebc2136d27bac043dcb7">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The numeric type of the expression' coefficients, e.g. float, double, int or std::complex&lt;float&gt;, etc.</p>
<p>It is an alias for the Scalar type </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ae1c24c2182e40e95345506a9a156132b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c24c2182e40e95345506a9a156132b">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae1c24c2182e40e95345506a9a156132ba456cda7b9d938e57194036a41d634604"></a>RowsAtCompileTime&#160;</td><td class="fielddoc"><p>The number of rows at compile-time. This is just a copy of the value provided by the <em>Derived</em> type. If a value is not known at compile-time, it is set to the <em>Dynamic</em> constant. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structEigen_1_1EigenBase.html#ab75c2d8a783d055db397319c5a330eee">MatrixBase::rows()</a>, <a class="el" href="structEigen_1_1EigenBase.html#a16145eb95335754c2ff8b2a58731bc53">MatrixBase::cols()</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#ae1c24c2182e40e95345506a9a156132ba27ba349f075d026c1f51d1ec69aa5b14">ColsAtCompileTime</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#ae1c24c2182e40e95345506a9a156132baa5022cfa2bb53129883e9b7b8abd3d68">SizeAtCompileTime</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ae1c24c2182e40e95345506a9a156132ba27ba349f075d026c1f51d1ec69aa5b14"></a>ColsAtCompileTime&#160;</td><td class="fielddoc"><p>The number of columns at compile-time. This is just a copy of the value provided by the <em>Derived</em> type. If a value is not known at compile-time, it is set to the <em>Dynamic</em> constant. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structEigen_1_1EigenBase.html#ab75c2d8a783d055db397319c5a330eee">MatrixBase::rows()</a>, <a class="el" href="structEigen_1_1EigenBase.html#a16145eb95335754c2ff8b2a58731bc53">MatrixBase::cols()</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#ae1c24c2182e40e95345506a9a156132ba456cda7b9d938e57194036a41d634604">RowsAtCompileTime</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#ae1c24c2182e40e95345506a9a156132baa5022cfa2bb53129883e9b7b8abd3d68">SizeAtCompileTime</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ae1c24c2182e40e95345506a9a156132baa5022cfa2bb53129883e9b7b8abd3d68"></a>SizeAtCompileTime&#160;</td><td class="fielddoc"><p>This is equal to the number of coefficients, i.e. the number of rows times the number of columns, or to <em>Dynamic</em> if this is not known at compile-time. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseMatrixBase.html#ae1c24c2182e40e95345506a9a156132ba456cda7b9d938e57194036a41d634604">RowsAtCompileTime</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#ae1c24c2182e40e95345506a9a156132ba27ba349f075d026c1f51d1ec69aa5b14">ColsAtCompileTime</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ae1c24c2182e40e95345506a9a156132ba14a3f566ed2a074beddb8aef0223bfdf"></a>IsVectorAtCompileTime&#160;</td><td class="fielddoc"><p>This is set to true if either the number of rows or the number of columns is known at compile-time to be equal to 1. Indeed, in that case, we are dealing with a column-vector (if there is only one column) or with a row-vector (if there is only one row). </p>
</td></tr>
<tr><td class="fieldname"><a id="ae1c24c2182e40e95345506a9a156132ba2af043b36fe9e08df0107cf6de496165"></a>Flags&#160;</td><td class="fielddoc"><p>This stores expression <a class="el" href="group__flags.html">Flags</a> flags which may or may not be inherited by new expressions constructed from this one. See the <a class="el" href="group__flags.html">list of flags</a>. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aaa71e627acbc873db1885d0fb72189a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa71e627acbc873db1885d0fb72189a6">&#9670;&nbsp;</a></span>binaryExpr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename CustomBinaryOp , typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;CustomBinaryOp, const Derived, const OtherDerived&gt; <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::binaryExpr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CustomBinaryOp &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code>CustomBinaryOp()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a custom coefficient-wise operator <em>func</em> of *this and <em>other</em> </dd></dl>
<p>The template parameter <em>CustomBinaryOp</em> is the type of the functor of the custom operator (see class <a class="el" href="classEigen_1_1CwiseBinaryOp.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions. ">CwiseBinaryOp</a> for an example)</p>
<p>Here is an example illustrating the use of custom functors: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"></div><div class="line"><span class="comment">// define a custom template binary functor</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Scalar&gt; <span class="keyword">struct </span>MakeComplexOp {</div><div class="line">  EIGEN_EMPTY_STRUCT_CTOR(MakeComplexOp)</div><div class="line">  <span class="keyword">typedef</span> complex&lt;Scalar&gt; result_type;</div><div class="line">  complex&lt;Scalar&gt; operator()(<span class="keyword">const</span> Scalar&amp; a, <span class="keyword">const</span> Scalar&amp; b)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> complex&lt;Scalar&gt;(a,b); }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">  <a class="code" href="classEigen_1_1Matrix.html">Matrix4d</a> m1 = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4d::Random</a>(), m2 = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4d::Random</a>();</div><div class="line">  cout &lt;&lt; m1.<a class="code" href="classEigen_1_1MatrixBase.html#a1063a3752d30b568e52c89ce4e567489">binaryExpr</a>(m2, MakeComplexOp&lt;double&gt;()) &lt;&lt; endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> Output: </p><pre class="fragment">   (0.68,0.271)  (0.823,-0.967) (-0.444,-0.687)   (-0.27,0.998)
 (-0.211,0.435) (-0.605,-0.514)  (0.108,-0.198) (0.0268,-0.563)
 (0.566,-0.717)  (-0.33,-0.726) (-0.0452,-0.74)  (0.904,0.0259)
  (0.597,0.214)   (0.536,0.608)  (0.258,-0.782)   (0.832,0.678)
</pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseBinaryOp.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions. ">CwiseBinaryOp</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#a97874c8f3c0a69b0160f0d310b233468">operator+()</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#ab1fdce454e05bc7c40c0cec7e854fe70">operator-()</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#a5f5654574942f40fc222297af1ebf62d">cwiseProduct()</a> </dd></dl>

</div>
</div>
<a id="af3410aafaa1676e555080cdecd905e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3410aafaa1676e555080cdecd905e03">&#9670;&nbsp;</a></span>block() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BlockXpr <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>startRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>startCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>blockRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>blockCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a dynamic-size expression of a block in *this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startRow</td><td>the first row in the block </td></tr>
    <tr><td class="paramname">startCol</td><td>the first column in the block </td></tr>
    <tr><td class="paramname">blockRows</td><td>the number of rows in the block </td></tr>
    <tr><td class="paramname">blockCols</td><td>the number of columns in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gace49b1dc3432f8a6639966a2cb7178be">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.block(1, 1, 2, 2):&quot;</span> &lt;&lt; endl &lt;&lt; m.block(1, 1, 2, 2) &lt;&lt; endl;</div><div class="line">m.block(1, 1, 2, 2).setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.block(1, 1, 2, 2):
-6  1
-3  0
Now the matrix m is:
 7  9 -5 -3
-2  0  0  0
 6  0  0  9
 6  6  3  9
</pre><dl class="section note"><dt>Note</dt><dd>Even though the returned expression has dynamic size, in the case when it is applied to a fixed-size matrix, it inherits a fixed maximal size, which means that evaluating it does not cause a dynamic memory allocation.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method returns a read-only expression for any sparse matrices. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#a3a422f30777a88d280daeb9a1496f074">block(Index,Index)</a> </dd></dl>

</div>
</div>
<a id="a3a422f30777a88d280daeb9a1496f074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a422f30777a88d280daeb9a1496f074">&#9670;&nbsp;</a></span>block() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int NRows, int NCols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FixedBlockXpr&lt;NRows,NCols&gt;::Type <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>startRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>startCol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a fixed-size expression of a block in *this.</dd></dl>
<p>The template parameters <em>NRows</em> and <em>NCols</em> are the number of rows and columns in the block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startRow</td><td>the first row in the block </td></tr>
    <tr><td class="paramname">startCol</td><td>the first column in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gace49b1dc3432f8a6639966a2cb7178be">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.block&lt;2,2&gt;(1,1):&quot;</span> &lt;&lt; endl &lt;&lt; m.block&lt;2,2&gt;(1,1) &lt;&lt; endl;</div><div class="line">m.block&lt;2,2&gt;(1,1).setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.block&lt;2,2&gt;(1,1):
-6  1
-3  0
Now the matrix m is:
 7  9 -5 -3
-2  0  0  0
 6  0  0  9
 6  6  3  9
</pre><dl class="section note"><dt>Note</dt><dd>since block is a templated member, the keyword template has to be used if the matrix type is also a template parameter:<div class="fragment"><div class="line">m.template block&lt;3,3&gt;(1,1); </div></div><!-- fragment --></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method returns a read-only expression for any sparse matrices. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a id="abb1b6971a06d23d6e51057ce04192517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1b6971a06d23d6e51057ce04192517">&#9670;&nbsp;</a></span>block() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int NRows, int NCols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FixedBlockXpr&lt;NRows,NCols&gt;::Type <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>startRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>startCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>blockRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>blockCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a block in *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NRows</td><td>number of rows in block as specified at compile-time </td></tr>
    <tr><td class="paramname">NCols</td><td>number of columns in block as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startRow</td><td>the first row in the block </td></tr>
    <tr><td class="paramname">startCol</td><td>the first column in the block </td></tr>
    <tr><td class="paramname">blockRows</td><td>number of rows in block as specified at run-time </td></tr>
    <tr><td class="paramname">blockCols</td><td>number of columns in block as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>This function is mainly useful for blocks where the number of rows is specified at compile-time and the number of columns is specified at run-time, or vice versa. The compile-time and run-time information should not contradict. In other words, <em>blockRows</em> should equal <em>NRows</em> unless <em>NRows</em> is <em>Dynamic</em>, and the same for the number of columns.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gace49b1dc3432f8a6639966a2cb7178be">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the block:&quot;</span> &lt;&lt; endl &lt;&lt; m.block&lt;2, <a class="code" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>&gt;(1, 1, 2, 3) &lt;&lt; endl;</div><div class="line">m.block&lt;2, <a class="code" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>&gt;(1, 1, 2, 3).setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Matrix4i m = Matrix4i::Random();
cout &lt;&lt; "Here is the matrix m:" &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; "Here is the block:" &lt;&lt; endl &lt;&lt; m.block&lt;2, Dynamic&gt;(1, 1, 2, 3) &lt;&lt; endl;
m.block&lt;2, Dynamic&gt;(1, 1, 2, 3).setZero();
cout &lt;&lt; "Now the matrix m is:" &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-only expression for any sparse matrices. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a id="a1df62282ce9b4eb1210f0b844ff01fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df62282ce9b4eb1210f0b844ff01fb5">&#9670;&nbsp;</a></span>bottomLeftCorner() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BlockXpr <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::bottomLeftCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a dynamic-size expression of a bottom-left corner of *this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>the number of rows in the corner </td></tr>
    <tr><td class="paramname">cCols</td><td>the number of columns in the corner</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gace49b1dc3432f8a6639966a2cb7178be">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.bottomLeftCorner(2, 2):&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; m.bottomLeftCorner(2, 2) &lt;&lt; endl;</div><div class="line">m.bottomLeftCorner(2, 2).setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.bottomLeftCorner(2, 2):
 6 -3
 6  6
Now the matrix m is:
 7  9 -5 -3
-2 -6  1  0
 0  0  0  9
 0  0  3  9
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-only expression for any sparse matrices. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a id="afa42c135390593b8b32ab45b390b719a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa42c135390593b8b32ab45b390b719a">&#9670;&nbsp;</a></span>bottomLeftCorner() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int CRows, int CCols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FixedBlockXpr&lt;CRows,CCols&gt;::Type <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::bottomLeftCorner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a fixed-size bottom-left corner of *this.</dd></dl>
<p>The template parameters CRows and CCols are the number of rows and columns in the corner.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gace49b1dc3432f8a6639966a2cb7178be">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.bottomLeftCorner&lt;2,2&gt;():&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; m.bottomLeftCorner&lt;2,2&gt;() &lt;&lt; endl;</div><div class="line">m.bottomLeftCorner&lt;2,2&gt;().setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.bottomLeftCorner&lt;2,2&gt;():
 6 -3
 6  6
Now the matrix m is:
 7  9 -5 -3
-2 -6  1  0
 0  0  0  9
 0  0  3  9
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-only expression for any sparse matrices. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a id="ad619814d6d694e347d9cf5d7302057a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad619814d6d694e347d9cf5d7302057a9">&#9670;&nbsp;</a></span>bottomLeftCorner() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int CRows, int CCols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FixedBlockXpr&lt;CRows,CCols&gt;::Type <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::bottomLeftCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a bottom-left corner of *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CRows</td><td>number of rows in corner as specified at compile-time </td></tr>
    <tr><td class="paramname">CCols</td><td>number of columns in corner as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>number of rows in corner as specified at run-time </td></tr>
    <tr><td class="paramname">cCols</td><td>number of columns in corner as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>This function is mainly useful for corners where the number of rows is specified at compile-time and the number of columns is specified at run-time, or vice versa. The compile-time and run-time information should not contradict. In other words, <em>cRows</em> should equal <em>CRows</em> unless <em>CRows</em> is <em>Dynamic</em>, and the same for the number of columns.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gace49b1dc3432f8a6639966a2cb7178be">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.bottomLeftCorner&lt;2,Dynamic&gt;(2,2):&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; m.bottomLeftCorner&lt;2,<a class="code" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>&gt;(2,2) &lt;&lt; endl;</div><div class="line">m.bottomLeftCorner&lt;2,<a class="code" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>&gt;(2,2).setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.bottomLeftCorner&lt;2,Dynamic&gt;(2,2):
 6 -3
 6  6
Now the matrix m is:
 7  9 -5 -3
-2 -6  1  0
 0  0  0  9
 0  0  3  9
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-only expression for any sparse matrices. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a> </dd></dl>

</div>
</div>
<a id="a886654a41fc6290236125725838aea2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886654a41fc6290236125725838aea2b">&#9670;&nbsp;</a></span>bottomRightCorner() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BlockXpr <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::bottomRightCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a dynamic-size expression of a bottom-right corner of *this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>the number of rows in the corner </td></tr>
    <tr><td class="paramname">cCols</td><td>the number of columns in the corner</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gace49b1dc3432f8a6639966a2cb7178be">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.bottomRightCorner(2, 2):&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; m.bottomRightCorner(2, 2) &lt;&lt; endl;</div><div class="line">m.bottomRightCorner(2, 2).setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.bottomRightCorner(2, 2):
0 9
3 9
Now the matrix m is:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  0
 6  6  0  0
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-only expression for any sparse matrices. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a id="a161556f95a4ae01e5fda7c79bb3e04f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161556f95a4ae01e5fda7c79bb3e04f2">&#9670;&nbsp;</a></span>bottomRightCorner() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int CRows, int CCols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FixedBlockXpr&lt;CRows,CCols&gt;::Type <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::bottomRightCorner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a fixed-size bottom-right corner of *this.</dd></dl>
<p>The template parameters CRows and CCols are the number of rows and columns in the corner.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gace49b1dc3432f8a6639966a2cb7178be">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.bottomRightCorner&lt;2,2&gt;():&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; m.bottomRightCorner&lt;2,2&gt;() &lt;&lt; endl;</div><div class="line">m.bottomRightCorner&lt;2,2&gt;().setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.bottomRightCorner&lt;2,2&gt;():
0 9
3 9
Now the matrix m is:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  0
 6  6  0  0
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-only expression for any sparse matrices. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a id="a1a544a89365beaa479e628ebda6d3a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a544a89365beaa479e628ebda6d3a93">&#9670;&nbsp;</a></span>bottomRightCorner() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int CRows, int CCols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FixedBlockXpr&lt;CRows,CCols&gt;::Type <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::bottomRightCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a bottom-right corner of *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CRows</td><td>number of rows in corner as specified at compile-time </td></tr>
    <tr><td class="paramname">CCols</td><td>number of columns in corner as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>number of rows in corner as specified at run-time </td></tr>
    <tr><td class="paramname">cCols</td><td>number of columns in corner as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>This function is mainly useful for corners where the number of rows is specified at compile-time and the number of columns is specified at run-time, or vice versa. The compile-time and run-time information should not contradict. In other words, <em>cRows</em> should equal <em>CRows</em> unless <em>CRows</em> is <em>Dynamic</em>, and the same for the number of columns.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gace49b1dc3432f8a6639966a2cb7178be">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.bottomRightCorner&lt;2,Dynamic&gt;(2,2):&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; m.bottomRightCorner&lt;2,<a class="code" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>&gt;(2,2) &lt;&lt; endl;</div><div class="line">m.bottomRightCorner&lt;2,<a class="code" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>&gt;(2,2).setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.bottomRightCorner&lt;2,Dynamic&gt;(2,2):
0 9
3 9
Now the matrix m is:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  0
 6  6  0  0
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-only expression for any sparse matrices. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a> </dd></dl>

</div>
</div>
<a id="aa79baf99d957a7b32169acbe18d1d89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79baf99d957a7b32169acbe18d1d89c">&#9670;&nbsp;</a></span>bottomRows() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RowsBlockXpr <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::bottomRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the bottom rows of *this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of rows in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__arraytypedefs.html#ga921202924faaff5051ada3cb1445438e">Array44i</a> a = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Array44i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is a.bottomRows(2):&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; a.bottomRows(2) &lt;&lt; endl;</div><div class="line">a.bottomRows(2).setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.bottomRows(2):
 6 -3  0  9
 6  6  3  9
Now the array a is:
 7  9 -5 -3
-2 -6  1  0
 0  0  0  0
 0  0  0  0
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-write expression for row-major sparse matrices only. Otherwise, the returned expression is read-only. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a id="ac0e2afd4e6a4939f488afbfe3b5cf8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e2afd4e6a4939f488afbfe3b5cf8c0">&#9670;&nbsp;</a></span>bottomRows() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NRowsBlockXpr&lt;N&gt;::Type <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::bottomRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the bottom rows of *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of rows in the block as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of rows in the block as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em>n</em> should equal <em>N</em> unless <em>N</em> is <em>Dynamic</em>.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__arraytypedefs.html#ga921202924faaff5051ada3cb1445438e">Array44i</a> a = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Array44i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is a.bottomRows&lt;2&gt;():&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; a.bottomRows&lt;2&gt;() &lt;&lt; endl;</div><div class="line">a.bottomRows&lt;2&gt;().setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.bottomRows&lt;2&gt;():
 6 -3  0  9
 6  6  3  9
Now the array a is:
 7  9 -5 -3
-2 -6  1  0
 0  0  0  0
 0  0  0  0
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-write expression for row-major sparse matrices only. Otherwise, the returned expression is read-only. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a id="ad2f1053a230f80f9e3ae8a9e1963e3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f1053a230f80f9e3ae8a9e1963e3c9">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename NewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CastXpr&lt;NewType&gt;::Type <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of <code>*this</code> with the <em>Scalar</em> type casted to <em>NewScalar</em>.</dd></dl>
<p>The template parameter <em>NewScalar</em> is the type we are casting the scalars to.</p>
<p>This method does not change the sparsity of <code>*this</code>: the conversion function is applied to explicitly stored coefficients only. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseCompressedBase.html#a7cf299e08d2a4f6d6869e631e51b12fe">SparseCompressedBase::coeffs()</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseUnaryOp.html" title="Generic expression where a coefficient-wise unary operator is applied to an expression. ">CwiseUnaryOp</a> </dd></dl>

</div>
</div>
<a id="ad49129f2301063ce046ae071c82610d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49129f2301063ce046ae071c82610d5">&#9670;&nbsp;</a></span>col()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ColXpr <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the <em>i-th</em> column of *this. Note that the numbering starts at 0.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga84e9fd068879d808012bb6d5dbfecb17">Matrix3d</a> m = <a class="code" href="classEigen_1_1MatrixBase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">Matrix3d::Identity</a>();</div><div class="line">m.col(1) = <a class="code" href="group__matrixtypedefs.html#gaabb0b4639dc0b48e691e02e95873b0f1">Vector3d</a>(4,5,6);</div><div class="line">cout &lt;&lt; m &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">1 4 0
0 5 0
0 6 1
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-write expression for column-major sparse matrices only. Otherwise, the returned expression is read-only. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseMatrixBase.html#a92c023d63826ff35698e8e8feac3b24a">row()</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a> </dd></dl>

</div>
</div>
<a id="aca7ce296424ef6e478ab0fb19547a7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7ce296424ef6e478ab0fb19547a7ee">&#9670;&nbsp;</a></span>cols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::cols </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of columns. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseMatrixBase.html#a1944e9fa9ce7937bfc3a87b2cb94371f">rows()</a> </dd></dl>

</div>
</div>
<a id="a5786b847d59be644984e6ec30d2e35c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5786b847d59be644984e6ec30d2e35c0">&#9670;&nbsp;</a></span>conjugate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConjugateReturnType <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::conjugate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><br />
 </p>
<dl class="section return"><dt>Returns</dt><dd>an expression of the complex conjugate of <code>*this</code>.</dd></dl>
<p>This method does not change the sparsity of <code>*this</code>: the complex conjugate is applied to explicitly stored coefficients only. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseCompressedBase.html#a7cf299e08d2a4f6d6869e631e51b12fe">SparseCompressedBase::coeffs()</a> </dd>
<dd>
<a href="group__CoeffwiseMathFunctions.html#cwisetable_conj">Math functions</a>, <a class="el" href="classEigen_1_1MatrixBase.html#afacca1f88da57e5cd87dd07c8ff926bb">MatrixBase::adjoint()</a> </dd></dl>

</div>
</div>
<a id="afc11609ee20c2e103b42f2fda9b6fd7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc11609ee20c2e103b42f2fda9b6fd7a">&#9670;&nbsp;</a></span>cwiseAbs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseAbsReturnType</a> <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::cwiseAbs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise absolute value of <code>*this</code> </dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga99b41a69f0bf64eadb63a97f357ab412">MatrixXd</a> m(2,3);</div><div class="line">m &lt;&lt; 2, -4, 6,   </div><div class="line">     -5, 1, 0;</div><div class="line">cout &lt;&lt; m.cwiseAbs() &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">2 4 6
5 1 0
</pre><p>This method does not change the sparsity of <code>*this</code>: the absolute value is applied to explicitly stored coefficients only. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseCompressedBase.html#a7cf299e08d2a4f6d6869e631e51b12fe">SparseCompressedBase::coeffs()</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseMatrixBase.html#ae719d8a727660cb6469070b338499f08">cwiseAbs2()</a> </dd></dl>

</div>
</div>
<a id="ae719d8a727660cb6469070b338499f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae719d8a727660cb6469070b338499f08">&#9670;&nbsp;</a></span>cwiseAbs2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseAbs2ReturnType</a> <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::cwiseAbs2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise squared absolute value of <code>*this</code> </dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga99b41a69f0bf64eadb63a97f357ab412">MatrixXd</a> m(2,3);</div><div class="line">m &lt;&lt; 2, -4, 6,   </div><div class="line">     -5, 1, 0;</div><div class="line">cout &lt;&lt; m.cwiseAbs2() &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment"> 4 16 36
25  1  0
</pre><p>This method does not change the sparsity of <code>*this</code>: the squared absolute value is applied to explicitly stored coefficients only. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseCompressedBase.html#a7cf299e08d2a4f6d6869e631e51b12fe">SparseCompressedBase::coeffs()</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseMatrixBase.html#afc11609ee20c2e103b42f2fda9b6fd7a">cwiseAbs()</a> </dd></dl>

</div>
</div>
<a id="a3eb20e383a14f049736de22c8b333695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb20e383a14f049736de22c8b333695">&#9670;&nbsp;</a></span>cwiseEqual() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;std::equal_to&lt;Scalar&gt;, const Derived, const OtherDerived&gt; <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::cwiseEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise == operator of *this and <em>other</em> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this performs an exact comparison, which is generally a bad idea with floating-point types. In order to check for equality between two vectors or matrices with floating-point coefficients, it is generally a far better idea to use a fuzzy comparison as provided by isApprox() and isMuchSmallerThan().</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gaceba5f63d4040c79c44109590d4fa606">MatrixXi</a> m(2,2);</div><div class="line">m &lt;&lt; 1, 0,</div><div class="line">     1, 1;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Comparing m with identity matrix:&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; m.cwiseEqual(<a class="code" href="classEigen_1_1MatrixBase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">MatrixXi::Identity</a>(2,2)) &lt;&lt; endl;</div><div class="line"><a class="code" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> count = m.cwiseEqual(<a class="code" href="classEigen_1_1MatrixBase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">MatrixXi::Identity</a>(2,2)).count();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Number of coefficients that are equal: &quot;</span> &lt;&lt; count &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Comparing m with identity matrix:
1 1
0 1
Number of coefficients that are equal: 3
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseMatrixBase.html#a9596ff9f731a708010da9e876ee6ad09">cwiseNotEqual()</a>, isApprox(), isMuchSmallerThan() </dd></dl>

</div>
</div>
<a id="abbf4659b7df3458fb7491ac3132f6cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf4659b7df3458fb7491ac3132f6cdb">&#9670;&nbsp;</a></span>cwiseEqual() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseScalarEqualReturnType</a> <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::cwiseEqual </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise == operator of <code>*this</code> and a scalar <em>s</em> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this performs an exact comparison, which is generally a bad idea with floating-point types. In order to check for equality between two vectors or matrices with floating-point coefficients, it is generally a far better idea to use a fuzzy comparison as provided by isApprox() and isMuchSmallerThan().</dd></dl>
<dl class="section see"><dt>See also</dt><dd>cwiseEqual(const MatrixBase&lt;OtherDerived&gt; &amp;) const </dd></dl>

</div>
</div>
<a id="a703fdd06c4802869bd1682f4b06eda2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703fdd06c4802869bd1682f4b06eda2c">&#9670;&nbsp;</a></span>cwiseInverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseInverseReturnType</a> <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::cwiseInverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise inverse of *this.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga99b41a69f0bf64eadb63a97f357ab412">MatrixXd</a> m(2,3);</div><div class="line">m &lt;&lt; 2, 0.5, 1,   </div><div class="line">     3, 0.25, 1;</div><div class="line">cout &lt;&lt; m.cwiseInverse() &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">  0.5     2     1
0.333     4     1
</pre><p>This method does not change the sparsity of <code>*this</code>: the inverse is applied to explicitly stored coefficients only. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseCompressedBase.html#a7cf299e08d2a4f6d6869e631e51b12fe">SparseCompressedBase::coeffs()</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseMatrixBase.html#a5f5654574942f40fc222297af1ebf62d">cwiseProduct()</a> </dd></dl>

</div>
</div>
<a id="a4d944efb685a27c2dfcf59a07f4d2fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d944efb685a27c2dfcf59a07f4d2fdd">&#9670;&nbsp;</a></span>cwiseMax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_max_op&lt;Scalar,Scalar&gt;, const Derived, const OtherDerived&gt; <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::cwiseMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise max of *this and <em>other</em> </dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gaabb0b4639dc0b48e691e02e95873b0f1">Vector3d</a> v(2,3,4), w(4,2,3);</div><div class="line">cout &lt;&lt; v.cwiseMax(w) &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">4
3
4
</pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseBinaryOp.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions. ">CwiseBinaryOp</a>, min() </dd></dl>

</div>
</div>
<a id="a724916ecda447e958944991767ac1f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724916ecda447e958944991767ac1f97">&#9670;&nbsp;</a></span>cwiseMax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_max_op&lt;Scalar,Scalar&gt;, const Derived, const ConstantReturnType&gt; <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::cwiseMax </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise max of *this and scalar <em>other</em> </dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseBinaryOp.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions. ">CwiseBinaryOp</a>, min() </dd></dl>

</div>
</div>
<a id="af28d8003e305b4877d795432484cc73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af28d8003e305b4877d795432484cc73a">&#9670;&nbsp;</a></span>cwiseMin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_min_op&lt;Scalar,Scalar&gt;, const Derived, const OtherDerived&gt; <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::cwiseMin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise min of *this and <em>other</em> </dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gaabb0b4639dc0b48e691e02e95873b0f1">Vector3d</a> v(2,3,4), w(4,2,3);</div><div class="line">cout &lt;&lt; v.cwiseMin(w) &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">2
2
3
</pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseBinaryOp.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions. ">CwiseBinaryOp</a>, max() </dd></dl>

</div>
</div>
<a id="ac6acc24a2f2388959407e0ec6ecc7551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6acc24a2f2388959407e0ec6ecc7551">&#9670;&nbsp;</a></span>cwiseMin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_min_op&lt;Scalar,Scalar&gt;, const Derived, const ConstantReturnType&gt; <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::cwiseMin </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise min of *this and scalar <em>other</em> </dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseBinaryOp.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions. ">CwiseBinaryOp</a>, min() </dd></dl>

</div>
</div>
<a id="a9596ff9f731a708010da9e876ee6ad09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9596ff9f731a708010da9e876ee6ad09">&#9670;&nbsp;</a></span>cwiseNotEqual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;std::not_equal_to&lt;Scalar&gt;, const Derived, const OtherDerived&gt; <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::cwiseNotEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise != operator of *this and <em>other</em> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this performs an exact comparison, which is generally a bad idea with floating-point types. In order to check for equality between two vectors or matrices with floating-point coefficients, it is generally a far better idea to use a fuzzy comparison as provided by isApprox() and isMuchSmallerThan().</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gaceba5f63d4040c79c44109590d4fa606">MatrixXi</a> m(2,2);</div><div class="line">m &lt;&lt; 1, 0,</div><div class="line">     1, 1;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Comparing m with identity matrix:&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; m.cwiseNotEqual(<a class="code" href="classEigen_1_1MatrixBase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">MatrixXi::Identity</a>(2,2)) &lt;&lt; endl;</div><div class="line"><a class="code" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> count = m.cwiseNotEqual(<a class="code" href="classEigen_1_1MatrixBase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">MatrixXi::Identity</a>(2,2)).count();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Number of coefficients that are not equal: &quot;</span> &lt;&lt; count &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Comparing m with identity matrix:
0 0
1 0
Number of coefficients that are not equal: 1
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseMatrixBase.html#a3eb20e383a14f049736de22c8b333695">cwiseEqual()</a>, isApprox(), isMuchSmallerThan() </dd></dl>

</div>
</div>
<a id="a5f5654574942f40fc222297af1ebf62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5654574942f40fc222297af1ebf62d">&#9670;&nbsp;</a></span>cwiseProduct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_product_op &lt; Derived ::Scalar, OtherDerived ::Scalar&gt;, const Derived , const OtherDerived &gt; <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::cwiseProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the Schur product (coefficient wise product) of *this and <em>other</em> </dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gaf5dfa8fd62427c5f3c8035daf15ebfcb">Matrix3i</a> a = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3i::Random</a>(), b = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3i::Random</a>();</div><div class="line"><a class="code" href="group__matrixtypedefs.html#gaf5dfa8fd62427c5f3c8035daf15ebfcb">Matrix3i</a> c = a.cwiseProduct(b);</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;a:\n&quot;</span> &lt;&lt; a &lt;&lt; <span class="stringliteral">&quot;\nb:\n&quot;</span> &lt;&lt; b &lt;&lt; <span class="stringliteral">&quot;\nc:\n&quot;</span> &lt;&lt; c &lt;&lt; endl;</div><div class="line"></div></div><!-- fragment --><p> Output: </p><pre class="fragment">a:
 7  6 -3
-2  9  6
 6 -6 -5
b:
 1 -3  9
 0  0  3
 3  9  5
c:
  7 -18 -27
  0   0  18
 18 -54 -25
</pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseBinaryOp.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions. ">CwiseBinaryOp</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#ae719d8a727660cb6469070b338499f08">cwiseAbs2</a> </dd></dl>

</div>
</div>
<a id="a914f7db22f9010c2288098be79b7e478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a914f7db22f9010c2288098be79b7e478">&#9670;&nbsp;</a></span>cwiseQuotient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_quotient_op&lt;Scalar&gt;, const Derived, const OtherDerived&gt; <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::cwiseQuotient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise quotient of *this and <em>other</em> </dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gaabb0b4639dc0b48e691e02e95873b0f1">Vector3d</a> v(2,3,4), w(4,2,3);</div><div class="line">cout &lt;&lt; v.cwiseQuotient(w) &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment"> 0.5
 1.5
1.33
</pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseBinaryOp.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions. ">CwiseBinaryOp</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#a5f5654574942f40fc222297af1ebf62d">cwiseProduct()</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#a703fdd06c4802869bd1682f4b06eda2c">cwiseInverse()</a> </dd></dl>

</div>
</div>
<a id="ae86f1aa7e8855072a1b5f6fdc6573567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86f1aa7e8855072a1b5f6fdc6573567">&#9670;&nbsp;</a></span>cwiseSign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseSignReturnType</a> <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::cwiseSign </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise signum of *this.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga99b41a69f0bf64eadb63a97f357ab412">MatrixXd</a> m(2,3);</div><div class="line">m &lt;&lt;  2, -4, 6,</div><div class="line">     -5,  1, 0;</div><div class="line">cout &lt;&lt; m.cwiseSign() &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment"> 1 -1  1
-1  1  0
</pre><p>This method does not change the sparsity of <code>*this</code>: the sign function is applied to explicitly stored coefficients only. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseCompressedBase.html#a7cf299e08d2a4f6d6869e631e51b12fe">SparseCompressedBase::coeffs()</a> </dd></dl>

</div>
</div>
<a id="a43f979e103dd39e8cac8505254d190c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f979e103dd39e8cac8505254d190c2">&#9670;&nbsp;</a></span>cwiseSqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseSqrtReturnType</a> <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::cwiseSqrt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise square root of *this.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gaabb0b4639dc0b48e691e02e95873b0f1">Vector3d</a> v(1,2,4);</div><div class="line">cout &lt;&lt; v.cwiseSqrt() &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">   1
1.41
   2
</pre><p>This method does not change the sparsity of <code>*this</code>: the square-root is applied to explicitly stored coefficients only. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseCompressedBase.html#a7cf299e08d2a4f6d6869e631e51b12fe">SparseCompressedBase::coeffs()</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>cwisePow(), cwiseSquare() </dd></dl>

</div>
</div>
<a id="a761bd872a06b59632fcff7b7807a77ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a761bd872a06b59632fcff7b7807a77ce">&#9670;&nbsp;</a></span>eval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const internal::eval&lt;Derived&gt;::type <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::eval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the matrix or vector obtained by evaluating this expression.</dd></dl>
<p>Notice that in the case of a plain matrix or vector (not an expression) this function just returns a const reference, in order to avoid a useless copy. </p>

</div>
</div>
<a id="abe1314ea2bd1e1d2030a1e42e5240b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1314ea2bd1e1d2030a1e42e5240b3b">&#9670;&nbsp;</a></span>head() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SegmentReturnType <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a dynamic-size expression of the first coefficients of *this.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of coefficients in the segment</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga8925ca20a1b04cafb29e08196b9d0dae">RowVector4i</a> v = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">RowVector4i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is v.head(2):&quot;</span> &lt;&lt; endl &lt;&lt; v.head(2) &lt;&lt; endl;</div><div class="line">v.head(2).setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the vector v is:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the vector v:
 7 -2  6  6
Here is v.head(2):
 7 -2
Now the vector v is:
0 0 6 6
</pre><dl class="section note"><dt>Note</dt><dd>Even though the returned expression has dynamic size, in the case when it is applied to a fixed-size vector, it inherits a fixed maximal size, which means that evaluating it does not cause a dynamic memory allocation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#a3a422f30777a88d280daeb9a1496f074">block(Index,Index)</a> </dd></dl>

</div>
</div>
<a id="a77f5840458a6b52b293cfdd52c28063a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f5840458a6b52b293cfdd52c28063a">&#9670;&nbsp;</a></span>head() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FixedSegmentReturnType&lt;N&gt;::Type <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a fixed-size expression of the first coefficients of *this.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of coefficients in the segment as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of coefficients in the segment as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em>n</em> should equal <em>N</em> unless <em>N</em> is <em>Dynamic</em>.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga8925ca20a1b04cafb29e08196b9d0dae">RowVector4i</a> v = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">RowVector4i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is v.head(2):&quot;</span> &lt;&lt; endl &lt;&lt; v.head&lt;2&gt;() &lt;&lt; endl;</div><div class="line">v.head&lt;2&gt;().setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the vector v is:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the vector v:
 7 -2  6  6
Here is v.head(2):
 7 -2
Now the vector v is:
0 0 6 6
</pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a> </dd></dl>

</div>
</div>
<a id="ad20e914fe0dd4b2490102f48b050f1bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20e914fe0dd4b2490102f48b050f1bb">&#9670;&nbsp;</a></span>imag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ImagReturnType <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::imag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><br />
 </p>
<dl class="section return"><dt>Returns</dt><dd>an read-only expression of the imaginary part of <code>*this</code>.</dd></dl>
<p>This method does not change the sparsity of <code>*this</code>: the imaginary part function is applied to explicitly stored coefficients only. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseCompressedBase.html#a7cf299e08d2a4f6d6869e631e51b12fe">SparseCompressedBase::coeffs()</a> </dd>
<dd>
<a class="el" href="classEigen_1_1SparseMatrixBase.html#a3855bebf879e6c4a56f5ce1c25a9a3e3" title="  ">real()</a> </dd></dl>

</div>
</div>
<a id="ab2948b3eeefeb4757f7d4039de074e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2948b3eeefeb4757f7d4039de074e89">&#9670;&nbsp;</a></span>imag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NonConstImagReturnType <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::imag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><br />
 </p>
<dl class="section return"><dt>Returns</dt><dd>a non const expression of the imaginary part of <code>*this</code>.</dd></dl>
<p>This method does not change the sparsity of <code>*this</code>: the imaginary part function is applied to explicitly stored coefficients only. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseCompressedBase.html#a7cf299e08d2a4f6d6869e631e51b12fe">SparseCompressedBase::coeffs()</a> </dd>
<dd>
<a class="el" href="classEigen_1_1SparseMatrixBase.html#a3855bebf879e6c4a56f5ce1c25a9a3e3" title="  ">real()</a> </dd></dl>

</div>
</div>
<a id="a180fcba1ccf3cdf3252a263bc1de7a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180fcba1ccf3cdf3252a263bc1de7a1d">&#9670;&nbsp;</a></span>innerSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::innerSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the size of the inner dimension according to the storage order, i.e., the number of rows for a columns major matrix, and the number of cols otherwise </dd></dl>

</div>
</div>
<a id="a65aaf3b50d205011e2bfa0de24756cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65aaf3b50d205011e2bfa0de24756cce">&#9670;&nbsp;</a></span>innerVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1SparseMatrixBase.html">SparseMatrixBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1Block.html">InnerVectorReturnType</a> <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::innerVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>outer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <em>outer</em> -th column (resp. row) of the matrix <code>*this</code> if <code>*this</code> is col-major (resp. row-major). </dd></dl>

</div>
</div>
<a id="a1050a842569fcdadf8d936250301e72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1050a842569fcdadf8d936250301e72d">&#9670;&nbsp;</a></span>innerVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1SparseMatrixBase.html">SparseMatrixBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1Block.html">ConstInnerVectorReturnType</a> <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::innerVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>outer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <em>outer</em> -th column (resp. row) of the matrix <code>*this</code> if <code>*this</code> is col-major (resp. row-major). Read-only. </dd></dl>

</div>
</div>
<a id="a3c51bf5a7eb18eab9a85949d03aed14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c51bf5a7eb18eab9a85949d03aed14a">&#9670;&nbsp;</a></span>innerVectors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1SparseMatrixBase.html">SparseMatrixBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1Block.html">InnerVectorsReturnType</a> <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::innerVectors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>outerStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>outerSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <em>outer</em> -th column (resp. row) of the matrix <code>*this</code> if <code>*this</code> is col-major (resp. row-major). </dd></dl>

</div>
</div>
<a id="ae6585c991d04c139f2486ab81f56ad1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6585c991d04c139f2486ab81f56ad1a">&#9670;&nbsp;</a></span>innerVectors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1SparseMatrixBase.html">SparseMatrixBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1Block.html">ConstInnerVectorsReturnType</a> <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::innerVectors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>outerStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>outerSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <em>outer</em> -th column (resp. row) of the matrix <code>*this</code> if <code>*this</code> is col-major (resp. row-major). Read-only. </dd></dl>

</div>
</div>
<a id="a7eedffa867031f649fd0fb9cc23ce4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eedffa867031f649fd0fb9cc23ce4be">&#9670;&nbsp;</a></span>isVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::isVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if either the number of rows or the number of columns is equal to 1. In other words, this function returns <div class="fragment"><div class="line"><a class="code" href="classEigen_1_1SparseMatrixBase.html#a1944e9fa9ce7937bfc3a87b2cb94371f">rows</a>()==1 || <a class="code" href="classEigen_1_1SparseMatrixBase.html#aca7ce296424ef6e478ab0fb19547a7ee">cols</a>()==1 </div></div><!-- fragment --> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseMatrixBase.html#a1944e9fa9ce7937bfc3a87b2cb94371f">rows()</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#aca7ce296424ef6e478ab0fb19547a7ee">cols()</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#ae1c24c2182e40e95345506a9a156132ba14a3f566ed2a074beddb8aef0223bfdf">IsVectorAtCompileTime</a>. </dd></dl>

</div>
</div>
<a id="a45f260bce61944ae8aaad69a68441cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f260bce61944ae8aaad69a68441cc1">&#9670;&nbsp;</a></span>leftCols() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ColsBlockXpr <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::leftCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the left columns of *this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of columns in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__arraytypedefs.html#ga921202924faaff5051ada3cb1445438e">Array44i</a> a = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Array44i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is a.leftCols(2):&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; a.leftCols(2) &lt;&lt; endl;</div><div class="line">a.leftCols(2).setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.leftCols(2):
 7  9
-2 -6
 6 -3
 6  6
Now the array a is:
 0  0 -5 -3
 0  0  1  0
 0  0  0  9
 0  0  3  9
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-write expression for column-major sparse matrices only. Otherwise, the returned expression is read-only. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a id="aebe9c9b17434027b0949e57951c9af05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe9c9b17434027b0949e57951c9af05">&#9670;&nbsp;</a></span>leftCols() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NColsBlockXpr&lt;N&gt;::Type <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::leftCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the left columns of *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of columns in the block as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of columns in the block as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em>n</em> should equal <em>N</em> unless <em>N</em> is <em>Dynamic</em>.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__arraytypedefs.html#ga921202924faaff5051ada3cb1445438e">Array44i</a> a = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Array44i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is a.leftCols&lt;2&gt;():&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; a.leftCols&lt;2&gt;() &lt;&lt; endl;</div><div class="line">a.leftCols&lt;2&gt;().setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.leftCols&lt;2&gt;():
 7  9
-2 -6
 6 -3
 6  6
Now the array a is:
 0  0 -5 -3
 0  0  1  0
 0  0  0  9
 0  0  3  9
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-write expression for column-major sparse matrices only. Otherwise, the returned expression is read-only. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a id="af08b7336ad372d17084b8a241fe3ab79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08b7336ad372d17084b8a241fe3ab79">&#9670;&nbsp;</a></span>middleCols() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ColsBlockXpr <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::middleCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>startCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>numCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of a range of columns of *this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startCol</td><td>the index of the first column in the block </td></tr>
    <tr><td class="paramname">numCols</td><td>the number of columns in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> N = 5;</div><div class="line">    <a class="code" href="classEigen_1_1Matrix.html">MatrixXi</a> A(N,N);</div><div class="line">    A.setRandom();</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;A =\n&quot;</span> &lt;&lt; A &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;A(1..3,:) =\n&quot;</span> &lt;&lt; A.middleCols(1,3) &lt;&lt; endl;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> Output: </p><pre class="fragment">A =
  7  -6   0   9 -10
 -2  -3   3   3  -5
  6   6  -3   5  -8
  6  -5   0  -8   6
  9   1   9   2  -7

A(1..3,:) =
-6  0  9
-3  3  3
 6 -3  5
-5  0 -8
 1  9  2
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-write expression for column-major sparse matrices only. Otherwise, the returned expression is read-only. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a id="aec625252292e4626e263dd133ccac421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec625252292e4626e263dd133ccac421">&#9670;&nbsp;</a></span>middleCols() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NColsBlockXpr&lt;N&gt;::Type <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::middleCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>startCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of a range of columns of *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of columns in the block as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startCol</td><td>the index of the first column in the block </td></tr>
    <tr><td class="paramname">n</td><td>the number of columns in the block as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em>n</em> should equal <em>N</em> unless <em>N</em> is <em>Dynamic</em>.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> N = 5;</div><div class="line">    <a class="code" href="classEigen_1_1Matrix.html">MatrixXi</a> A(N,N);</div><div class="line">    A.setRandom();</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;A =\n&quot;</span> &lt;&lt; A &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;A(:,1..3) =\n&quot;</span> &lt;&lt; A.middleCols&lt;3&gt;(1) &lt;&lt; endl;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> Output: </p><pre class="fragment">A =
  7  -6   0   9 -10
 -2  -3   3   3  -5
  6   6  -3   5  -8
  6  -5   0  -8   6
  9   1   9   2  -7

A(:,1..3) =
-6  0  9
-3  3  3
 6 -3  5
-5  0 -8
 1  9  2
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-write expression for column-major sparse matrices only. Otherwise, the returned expression is read-only. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a id="aa81def49d91f316d66418f8ad3f801fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81def49d91f316d66418f8ad3f801fb">&#9670;&nbsp;</a></span>middleRows() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RowsBlockXpr <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::middleRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>startRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of a range of rows of *this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startRow</td><td>the index of the first row in the block </td></tr>
    <tr><td class="paramname">n</td><td>the number of rows in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> N = 5;</div><div class="line">    <a class="code" href="classEigen_1_1Matrix.html">MatrixXi</a> A(N,N);</div><div class="line">    A.setRandom();</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;A =\n&quot;</span> &lt;&lt; A &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;A(2..3,:) =\n&quot;</span> &lt;&lt; A.middleRows(2,2) &lt;&lt; endl;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> Output: </p><pre class="fragment">A =
  7  -6   0   9 -10
 -2  -3   3   3  -5
  6   6  -3   5  -8
  6  -5   0  -8   6
  9   1   9   2  -7

A(2..3,:) =
 6  6 -3  5 -8
 6 -5  0 -8  6
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-write expression for row-major sparse matrices only. Otherwise, the returned expression is read-only. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a id="a4c4adbdd67164a3753df77a0c2d5eda8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4adbdd67164a3753df77a0c2d5eda8">&#9670;&nbsp;</a></span>middleRows() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NRowsBlockXpr&lt;N&gt;::Type <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::middleRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>startRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of a range of rows of *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of rows in the block as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startRow</td><td>the index of the first row in the block </td></tr>
    <tr><td class="paramname">n</td><td>the number of rows in the block as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em>n</em> should equal <em>N</em> unless <em>N</em> is <em>Dynamic</em>.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> N = 5;</div><div class="line">    <a class="code" href="classEigen_1_1Matrix.html">MatrixXi</a> A(N,N);</div><div class="line">    A.setRandom();</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;A =\n&quot;</span> &lt;&lt; A &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;A(1..3,:) =\n&quot;</span> &lt;&lt; A.middleRows&lt;3&gt;(1) &lt;&lt; endl;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> Output: </p><pre class="fragment">A =
  7  -6   0   9 -10
 -2  -3   3   3  -5
  6   6  -3   5  -8
  6  -5   0  -8   6
  9   1   9   2  -7

A(1..3,:) =
-2 -3  3  3 -5
 6  6 -3  5 -8
 6 -5  0 -8  6
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-write expression for row-major sparse matrices only. Otherwise, the returned expression is read-only. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a id="a02b575655d7a77f0594cec7a6864e864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02b575655d7a77f0594cec7a6864e864">&#9670;&nbsp;</a></span>operator &amp;&amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_boolean_and_op, const Derived, const OtherDerived&gt; <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise boolean <b>and</b> operator of <code>*this</code> and <em>other</em> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this operator is for expression of bool only.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__arraytypedefs.html#gaaaaed220517b7fc8a3494d6b2f0361e3">Array3d</a> v(-1,2,1), w(-3,2,3);</div><div class="line">cout &lt;&lt; ((v&lt;w) &amp;&amp; (v&lt;0)) &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">0
0
0
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseMatrixBase.html#af81ea3dea5ea37304ea010d511f35088">operator||()</a>, select() </dd></dl>

</div>
</div>
<a id="a4d549536a2d7bc6a414d66c1e2b305dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d549536a2d7bc6a414d66c1e2b305dd">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_product_op&lt;Scalar,T&gt;,Derived,Constant&lt;T&gt; &gt; <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of <code>*this</code> scaled by the scalar factor <em>scalar</em> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is the scalar type of <em>scalar</em>. It must be compatible with the scalar type of the given expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d4d71b3f34389e6fc01f2b86e43f7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4d71b3f34389e6fc01f2b86e43f7a4">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Product.html">Product</a>&lt; Derived, OtherDerived, AliasFreeProduct &gt; <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1SparseMatrixBase.html">SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the product of two sparse matrices. By default a conservative product preserving the symbolic non zeros is performed. The automatic pruning of the small values can be achieved by calling the <a class="el" href="classEigen_1_1SparseMatrixBase.html#ac8d0414b56d9d620ce9a698c1b281e5d">pruned()</a> function in which case a totally different product algorithm is employed: <div class="fragment"><div class="line">C = (A*B).<a class="code" href="classEigen_1_1SparseMatrixBase.html#ac8d0414b56d9d620ce9a698c1b281e5d">pruned</a>();             <span class="comment">// supress numerical zeros (exact)</span></div><div class="line">C = (A*B).<a class="code" href="classEigen_1_1SparseMatrixBase.html#ac8d0414b56d9d620ce9a698c1b281e5d">pruned</a>(ref);</div><div class="line">C = (A*B).<a class="code" href="classEigen_1_1SparseMatrixBase.html#ac8d0414b56d9d620ce9a698c1b281e5d">pruned</a>(ref,epsilon);</div></div><!-- fragment --> where <code>ref</code> is a meaningful non zero reference value. </dd></dl>

</div>
</div>
<a id="a97874c8f3c0a69b0160f0d310b233468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97874c8f3c0a69b0160f0d310b233468">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; sum &lt;Scalar&gt;, const Derived, const OtherDerived&gt; <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the sum of <code>*this</code> and <em>other</em> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you want to add a given scalar to all coefficients, see Cwise::operator+().</dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseBinaryOp.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions. ">CwiseBinaryOp</a>, operator+=() </dd></dl>

</div>
</div>
<a id="a118b1aef19fa7231538d94646573b7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118b1aef19fa7231538d94646573b7bc">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; difference &lt;Scalar&gt;, const Derived, const OtherDerived&gt; <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the difference of <code>*this</code> and <em>other</em> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you want to substract a given scalar from all coefficients, see Cwise::operator-().</dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseBinaryOp.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions. ">CwiseBinaryOp</a>, operator-=() </dd></dl>

</div>
</div>
<a id="ab1fdce454e05bc7c40c0cec7e854fe70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1fdce454e05bc7c40c0cec7e854fe70">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const NegativeReturnType <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the opposite of <code>*this</code> </dd></dl>
<p>This method does not change the sparsity of <code>*this</code>: the opposite is applied to explicitly stored coefficients only. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseCompressedBase.html#a7cf299e08d2a4f6d6869e631e51b12fe">SparseCompressedBase::coeffs()</a> </dd></dl>

</div>
</div>
<a id="aa30a0ce5a8b71a99bc969fe585e39713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30a0ce5a8b71a99bc969fe585e39713">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_quotient_op&lt;Scalar,T&gt;,Derived,Constant&lt;T&gt; &gt; <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of <code>*this</code> divided by the scalar value <em>scalar</em> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is the scalar type of <em>scalar</em>. It must be compatible with the scalar type of the given expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af81ea3dea5ea37304ea010d511f35088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81ea3dea5ea37304ea010d511f35088">&#9670;&nbsp;</a></span>operator||()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_boolean_or_op, const Derived, const OtherDerived&gt; <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise boolean <b>or</b> operator of <code>*this</code> and <em>other</em> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this operator is for expression of bool only.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__arraytypedefs.html#gaaaaed220517b7fc8a3494d6b2f0361e3">Array3d</a> v(-1,2,1), w(-3,2,3);</div><div class="line">cout &lt;&lt; ((v&lt;w) || (v&lt;0)) &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">1
0
1
</pre><dl class="section see"><dt>See also</dt><dd>operator&amp;&amp;(), select() </dd></dl>

</div>
</div>
<a id="ac86cc88a4cfef21db6b64ec0ab4c8f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86cc88a4cfef21db6b64ec0ab4c8f0a">&#9670;&nbsp;</a></span>outerSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::outerSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the size of the storage major dimension, i.e., the number of columns for a columns major matrix, and the number of rows otherwise </dd></dl>

</div>
</div>
<a id="ac8d0414b56d9d620ce9a698c1b281e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d0414b56d9d620ce9a698c1b281e5d">&#9670;&nbsp;</a></span>pruned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1SparseView.html">SparseView</a>&lt; Derived &gt; <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::pruned </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>reference</em> = <code>Scalar(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;Scalar&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of <code>*this</code> with values smaller than <em>reference</em> * <em>epsilon</em> removed.</dd></dl>
<p>This method is typically used in conjunction with the product of two sparse matrices to automatically prune the smallest values as follows: </p><div class="fragment"><div class="line">C = (A*B).<a class="code" href="classEigen_1_1SparseMatrixBase.html#ac8d0414b56d9d620ce9a698c1b281e5d">pruned</a>();             <span class="comment">// suppress numerical zeros (exact)</span></div><div class="line">C = (A*B).<a class="code" href="classEigen_1_1SparseMatrixBase.html#ac8d0414b56d9d620ce9a698c1b281e5d">pruned</a>(ref);</div><div class="line">C = (A*B).<a class="code" href="classEigen_1_1SparseMatrixBase.html#ac8d0414b56d9d620ce9a698c1b281e5d">pruned</a>(ref,epsilon);</div></div><!-- fragment --><p> where <code>ref</code> is a meaningful non zero reference value. </p>

</div>
</div>
<a id="a34162b16f185e9f8a39da62087a23665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34162b16f185e9f8a39da62087a23665">&#9670;&nbsp;</a></span>real() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealReturnType <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::real </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><br />
 </p>
<dl class="section return"><dt>Returns</dt><dd>a read-only expression of the real part of <code>*this</code>.</dd></dl>
<p>This method does not change the sparsity of <code>*this</code>: the real part function is applied to explicitly stored coefficients only. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseCompressedBase.html#a7cf299e08d2a4f6d6869e631e51b12fe">SparseCompressedBase::coeffs()</a> </dd>
<dd>
<a class="el" href="classEigen_1_1SparseMatrixBase.html#ab2948b3eeefeb4757f7d4039de074e89" title="  ">imag()</a> </dd></dl>

</div>
</div>
<a id="a3855bebf879e6c4a56f5ce1c25a9a3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3855bebf879e6c4a56f5ce1c25a9a3e3">&#9670;&nbsp;</a></span>real() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NonConstRealReturnType <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::real </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><br />
 </p>
<dl class="section return"><dt>Returns</dt><dd>a non const expression of the real part of <code>*this</code>.</dd></dl>
<p>This method does not change the sparsity of <code>*this</code>: the real part function is applied to explicitly stored coefficients only. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseCompressedBase.html#a7cf299e08d2a4f6d6869e631e51b12fe">SparseCompressedBase::coeffs()</a> </dd>
<dd>
<a class="el" href="classEigen_1_1SparseMatrixBase.html#ab2948b3eeefeb4757f7d4039de074e89" title="  ">imag()</a> </dd></dl>

</div>
</div>
<a id="a89993e50b36a130a5a2d53d8fcd7cba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89993e50b36a130a5a2d53d8fcd7cba3">&#9670;&nbsp;</a></span>rightCols() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ColsBlockXpr <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::rightCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the right columns of *this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of columns in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__arraytypedefs.html#ga921202924faaff5051ada3cb1445438e">Array44i</a> a = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Array44i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is a.rightCols(2):&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; a.rightCols(2) &lt;&lt; endl;</div><div class="line">a.rightCols(2).setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.rightCols(2):
-5 -3
 1  0
 0  9
 3  9
Now the array a is:
 7  9  0  0
-2 -6  0  0
 6 -3  0  0
 6  6  0  0
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-write expression for column-major sparse matrices only. Otherwise, the returned expression is read-only. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a id="a7945204acc8477627f6895140a7c51ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7945204acc8477627f6895140a7c51ef">&#9670;&nbsp;</a></span>rightCols() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NColsBlockXpr&lt;N&gt;::Type <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::rightCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the right columns of *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of columns in the block as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of columns in the block as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em>n</em> should equal <em>N</em> unless <em>N</em> is <em>Dynamic</em>.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__arraytypedefs.html#ga921202924faaff5051ada3cb1445438e">Array44i</a> a = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Array44i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is a.rightCols&lt;2&gt;():&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; a.rightCols&lt;2&gt;() &lt;&lt; endl;</div><div class="line">a.rightCols&lt;2&gt;().setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.rightCols&lt;2&gt;():
-5 -3
 1  0
 0  9
 3  9
Now the array a is:
 7  9  0  0
-2 -6  0  0
 6 -3  0  0
 6  6  0  0
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-write expression for column-major sparse matrices only. Otherwise, the returned expression is read-only. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a id="a92c023d63826ff35698e8e8feac3b24a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c023d63826ff35698e8e8feac3b24a">&#9670;&nbsp;</a></span>row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RowXpr <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the <em>i-th</em> row of *this. Note that the numbering starts at 0.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga84e9fd068879d808012bb6d5dbfecb17">Matrix3d</a> m = <a class="code" href="classEigen_1_1MatrixBase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">Matrix3d::Identity</a>();</div><div class="line">m.row(1) = <a class="code" href="group__matrixtypedefs.html#gaabb0b4639dc0b48e691e02e95873b0f1">Vector3d</a>(4,5,6);</div><div class="line">cout &lt;&lt; m &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">1 0 0
4 5 6
0 0 1
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-write expression for row-major sparse matrices only. Otherwise, the returned expression is read-only. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseMatrixBase.html#ad49129f2301063ce046ae071c82610d5">col()</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a> </dd></dl>

</div>
</div>
<a id="a1944e9fa9ce7937bfc3a87b2cb94371f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1944e9fa9ce7937bfc3a87b2cb94371f">&#9670;&nbsp;</a></span>rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::rows </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of rows. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseMatrixBase.html#aca7ce296424ef6e478ab0fb19547a7ee">cols()</a> </dd></dl>

</div>
</div>
<a id="a6f22c078139d8a4e9ab9f3c8d037edf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f22c078139d8a4e9ab9f3c8d037edf0">&#9670;&nbsp;</a></span>segment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SegmentReturnType <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::segment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a dynamic-size expression of a segment (i.e. a vector block) in *this.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>the first coefficient in the segment </td></tr>
    <tr><td class="paramname">n</td><td>the number of coefficients in the segment</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga8925ca20a1b04cafb29e08196b9d0dae">RowVector4i</a> v = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">RowVector4i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is v.segment(1, 2):&quot;</span> &lt;&lt; endl &lt;&lt; v.segment(1, 2) &lt;&lt; endl;</div><div class="line">v.segment(1, 2).setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the vector v is:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the vector v:
 7 -2  6  6
Here is v.segment(1, 2):
-2  6
Now the vector v is:
7 0 0 6
</pre><dl class="section note"><dt>Note</dt><dd>Even though the returned expression has dynamic size, in the case when it is applied to a fixed-size vector, it inherits a fixed maximal size, which means that evaluating it does not cause a dynamic memory allocation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, segment(Index) </dd></dl>

</div>
</div>
<a id="aced8757cdac6f6463eb65018b337f9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced8757cdac6f6463eb65018b337f9e5">&#9670;&nbsp;</a></span>segment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FixedSegmentReturnType&lt;N&gt;::Type <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::segment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a fixed-size expression of a segment (i.e. a vector block) in <code>*this</code> </dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of coefficients in the segment as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>the index of the first element in the segment </td></tr>
    <tr><td class="paramname">n</td><td>the number of coefficients in the segment as specified at compile-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em>n</em> should equal <em>N</em> unless <em>N</em> is <em>Dynamic</em>.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga8925ca20a1b04cafb29e08196b9d0dae">RowVector4i</a> v = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">RowVector4i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is v.segment&lt;2&gt;(1):&quot;</span> &lt;&lt; endl &lt;&lt; v.segment&lt;2&gt;(1) &lt;&lt; endl;</div><div class="line">v.segment&lt;2&gt;(2).setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the vector v is:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the vector v:
 7 -2  6  6
Here is v.segment&lt;2&gt;(1):
-2  6
Now the vector v is:
 7 -2  0  0
</pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a> </dd></dl>

</div>
</div>
<a id="a124bc57921775eb9aa2dfd9727e23472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124bc57921775eb9aa2dfd9727e23472">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of coefficients, which is <em><a class="el" href="classEigen_1_1SparseMatrixBase.html#a1944e9fa9ce7937bfc3a87b2cb94371f">rows()</a>*cols</em>(). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseMatrixBase.html#a1944e9fa9ce7937bfc3a87b2cb94371f">rows()</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#aca7ce296424ef6e478ab0fb19547a7ee">cols()</a>. </dd></dl>

</div>
</div>
<a id="a33269907b2a9e03cc93618ad076bee4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33269907b2a9e03cc93618ad076bee4d">&#9670;&nbsp;</a></span>tail() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SegmentReturnType <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a dynamic-size expression of the last coefficients of *this.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of coefficients in the segment</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga8925ca20a1b04cafb29e08196b9d0dae">RowVector4i</a> v = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">RowVector4i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is v.tail(2):&quot;</span> &lt;&lt; endl &lt;&lt; v.tail(2) &lt;&lt; endl;</div><div class="line">v.tail(2).setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the vector v is:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the vector v:
 7 -2  6  6
Here is v.tail(2):
6 6
Now the vector v is:
 7 -2  0  0
</pre><dl class="section note"><dt>Note</dt><dd>Even though the returned expression has dynamic size, in the case when it is applied to a fixed-size vector, it inherits a fixed maximal size, which means that evaluating it does not cause a dynamic memory allocation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#a3a422f30777a88d280daeb9a1496f074">block(Index,Index)</a> </dd></dl>

</div>
</div>
<a id="ada219a98a93845b4c09924d471322853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada219a98a93845b4c09924d471322853">&#9670;&nbsp;</a></span>tail() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FixedSegmentReturnType&lt;N&gt;::Type <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a fixed-size expression of the last coefficients of *this.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of coefficients in the segment as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of coefficients in the segment as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em>n</em> should equal <em>N</em> unless <em>N</em> is <em>Dynamic</em>.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga8925ca20a1b04cafb29e08196b9d0dae">RowVector4i</a> v = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">RowVector4i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is v.tail(2):&quot;</span> &lt;&lt; endl &lt;&lt; v.tail&lt;2&gt;() &lt;&lt; endl;</div><div class="line">v.tail&lt;2&gt;().setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the vector v is:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the vector v:
 7 -2  6  6
Here is v.tail(2):
6 6
Now the vector v is:
 7 -2  0  0
</pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a> </dd></dl>

</div>
</div>
<a id="a1a2fae971336c83038b5e1e97b49591a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2fae971336c83038b5e1e97b49591a">&#9670;&nbsp;</a></span>topLeftCorner() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BlockXpr <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::topLeftCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a dynamic-size expression of a top-left corner of *this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>the number of rows in the corner </td></tr>
    <tr><td class="paramname">cCols</td><td>the number of columns in the corner</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gace49b1dc3432f8a6639966a2cb7178be">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.topLeftCorner(2, 2):&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; m.topLeftCorner(2, 2) &lt;&lt; endl;</div><div class="line">m.topLeftCorner(2, 2).setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.topLeftCorner(2, 2):
 7  9
-2 -6
Now the matrix m is:
 0  0 -5 -3
 0  0  1  0
 6 -3  0  9
 6  6  3  9
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-only expression for any sparse matrices. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a id="af38ce1cb59059bebdf605b2091ea49b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38ce1cb59059bebdf605b2091ea49b9">&#9670;&nbsp;</a></span>topLeftCorner() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int CRows, int CCols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FixedBlockXpr&lt;CRows,CCols&gt;::Type <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::topLeftCorner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a fixed-size top-left corner of *this.</dd></dl>
<p>The template parameters CRows and CCols are the number of rows and columns in the corner.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gace49b1dc3432f8a6639966a2cb7178be">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.topLeftCorner&lt;2,2&gt;():&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; m.topLeftCorner&lt;2,2&gt;() &lt;&lt; endl;</div><div class="line">m.topLeftCorner&lt;2,2&gt;().setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.topLeftCorner&lt;2,2&gt;():
 7  9
-2 -6
Now the matrix m is:
 0  0 -5 -3
 0  0  1  0
 6 -3  0  9
 6  6  3  9
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-only expression for any sparse matrices. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a id="a8f09735a100f857c593741840184cefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f09735a100f857c593741840184cefe">&#9670;&nbsp;</a></span>topLeftCorner() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int CRows, int CCols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FixedBlockXpr&lt;CRows,CCols&gt;::Type <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::topLeftCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a top-left corner of *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CRows</td><td>number of rows in corner as specified at compile-time </td></tr>
    <tr><td class="paramname">CCols</td><td>number of columns in corner as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>number of rows in corner as specified at run-time </td></tr>
    <tr><td class="paramname">cCols</td><td>number of columns in corner as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>This function is mainly useful for corners where the number of rows is specified at compile-time and the number of columns is specified at run-time, or vice versa. The compile-time and run-time information should not contradict. In other words, <em>cRows</em> should equal <em>CRows</em> unless <em>CRows</em> is <em>Dynamic</em>, and the same for the number of columns.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gace49b1dc3432f8a6639966a2cb7178be">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.topLeftCorner&lt;2,Dynamic&gt;(2,2):&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; m.topLeftCorner&lt;2,<a class="code" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>&gt;(2,2) &lt;&lt; endl;</div><div class="line">m.topLeftCorner&lt;2,<a class="code" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>&gt;(2,2).setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.topLeftCorner&lt;2,Dynamic&gt;(2,2):
 7  9
-2 -6
Now the matrix m is:
 0  0 -5 -3
 0  0  1  0
 6 -3  0  9
 6  6  3  9
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-only expression for any sparse matrices. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a> </dd></dl>

</div>
</div>
<a id="a09f226d90163592659e6f82dd3e3295f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f226d90163592659e6f82dd3e3295f">&#9670;&nbsp;</a></span>topRightCorner() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BlockXpr <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::topRightCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a dynamic-size expression of a top-right corner of *this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>the number of rows in the corner </td></tr>
    <tr><td class="paramname">cCols</td><td>the number of columns in the corner</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gace49b1dc3432f8a6639966a2cb7178be">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.topRightCorner(2, 2):&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; m.topRightCorner(2, 2) &lt;&lt; endl;</div><div class="line">m.topRightCorner(2, 2).setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.topRightCorner(2, 2):
-5 -3
 1  0
Now the matrix m is:
 7  9  0  0
-2 -6  0  0
 6 -3  0  9
 6  6  3  9
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-only expression for any sparse matrices. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a id="a2b4ccb3c46e55e407bbe316fdebcb659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4ccb3c46e55e407bbe316fdebcb659">&#9670;&nbsp;</a></span>topRightCorner() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int CRows, int CCols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FixedBlockXpr&lt;CRows,CCols&gt;::Type <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::topRightCorner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a fixed-size top-right corner of *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CRows</td><td>the number of rows in the corner </td></tr>
    <tr><td class="paramname">CCols</td><td>the number of columns in the corner</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gace49b1dc3432f8a6639966a2cb7178be">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.topRightCorner&lt;2,2&gt;():&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; m.topRightCorner&lt;2,2&gt;() &lt;&lt; endl;</div><div class="line">m.topRightCorner&lt;2,2&gt;().setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.topRightCorner&lt;2,2&gt;():
-5 -3
 1  0
Now the matrix m is:
 7  9  0  0
-2 -6  0  0
 6 -3  0  9
 6  6  3  9
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-only expression for any sparse matrices. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#a3a422f30777a88d280daeb9a1496f074">block&lt;int,int&gt;(Index,Index)</a> </dd></dl>

</div>
</div>
<a id="adafa5d35b2d1bfc9f0cc19f14a0e2c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adafa5d35b2d1bfc9f0cc19f14a0e2c56">&#9670;&nbsp;</a></span>topRightCorner() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int CRows, int CCols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FixedBlockXpr&lt;CRows,CCols&gt;::Type <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::topRightCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a top-right corner of *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CRows</td><td>number of rows in corner as specified at compile-time </td></tr>
    <tr><td class="paramname">CCols</td><td>number of columns in corner as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>number of rows in corner as specified at run-time </td></tr>
    <tr><td class="paramname">cCols</td><td>number of columns in corner as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>This function is mainly useful for corners where the number of rows is specified at compile-time and the number of columns is specified at run-time, or vice versa. The compile-time and run-time information should not contradict. In other words, <em>cRows</em> should equal <em>CRows</em> unless <em>CRows</em> is <em>Dynamic</em>, and the same for the number of columns.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gace49b1dc3432f8a6639966a2cb7178be">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.topRightCorner&lt;2,Dynamic&gt;(2,2):&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; m.topRightCorner&lt;2,<a class="code" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>&gt;(2,2) &lt;&lt; endl;</div><div class="line">m.topRightCorner&lt;2,<a class="code" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>&gt;(2,2).setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.topRightCorner&lt;2,Dynamic&gt;(2,2):
-5 -3
 1  0
Now the matrix m is:
 7  9  0  0
-2 -6  0  0
 6 -3  0  9
 6  6  3  9
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-only expression for any sparse matrices. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a> </dd></dl>

</div>
</div>
<a id="a1528bf1b344bbfb216cbae7463454d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1528bf1b344bbfb216cbae7463454d24">&#9670;&nbsp;</a></span>topRows() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RowsBlockXpr <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::topRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the top rows of *this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of rows in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__arraytypedefs.html#ga921202924faaff5051ada3cb1445438e">Array44i</a> a = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Array44i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is a.topRows(2):&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; a.topRows(2) &lt;&lt; endl;</div><div class="line">a.topRows(2).setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.topRows(2):
 7  9 -5 -3
-2 -6  1  0
Now the array a is:
 0  0  0  0
 0  0  0  0
 6 -3  0  9
 6  6  3  9
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-write expression for row-major sparse matrices only. Otherwise, the returned expression is read-only. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a id="a43a2b592894cb82fab9e930db8f95117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a2b592894cb82fab9e930db8f95117">&#9670;&nbsp;</a></span>topRows() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NRowsBlockXpr&lt;N&gt;::Type <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::topRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the top rows of *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of rows in the block as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of rows in the block as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em>n</em> should equal <em>N</em> unless <em>N</em> is <em>Dynamic</em>.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__arraytypedefs.html#ga921202924faaff5051ada3cb1445438e">Array44i</a> a = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Array44i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is a.topRows&lt;2&gt;():&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; a.topRows&lt;2&gt;() &lt;&lt; endl;</div><div class="line">a.topRows&lt;2&gt;().setZero();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.topRows&lt;2&gt;():
 7  9 -5 -3
-2 -6  1  0
Now the array a is:
 0  0  0  0
 0  0  0  0
 6 -3  0  9
 6  6  3  9
</pre><dl class="section warning"><dt>Warning</dt><dd>This method returns a read-write expression for row-major sparse matrices only. Otherwise, the returned expression is read-only. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__TutorialSparse.html#TutorialSparse_SubMatrices">Sparse block operations</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#af3410aafaa1676e555080cdecd905e03">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a id="a51d4898bd6a57cc3ba543a39b102423e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d4898bd6a57cc3ba543a39b102423e">&#9670;&nbsp;</a></span>twistedBy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SparseSymmetricPermutationProduct&lt;Derived,<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1">Upper</a>|<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749">Lower</a>&gt; <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::twistedBy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1PermutationMatrix.html">PermutationMatrix</a>&lt; <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#a0b540ba724726ebe953f8c0df06081ed">StorageIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of P H P^-1 where H is the matrix represented by <code>*this</code> </dd></dl>

</div>
</div>
<a id="af9bed5dea96bdaf17ffd1a76ab0aedb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bed5dea96bdaf17ffd1a76ab0aedb1">&#9670;&nbsp;</a></span>unaryExpr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename CustomUnaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;CustomUnaryOp, const Derived&gt; <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::unaryExpr </td>
          <td>(</td>
          <td class="paramtype">const CustomUnaryOp &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code>CustomUnaryOp()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a unary operator coefficient-wise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Functor implementing the unary operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CustomUnaryOp</td><td>Type of <em>func</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An expression of a custom coefficient-wise unary operator <em>func</em> of *this</dd></dl>
<p>The function <code>ptr_fun()</code> from the C++ standard library can be used to make functors out of normal functions.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"></div><div class="line"><span class="comment">// define function to be applied coefficient-wise</span></div><div class="line"><span class="keywordtype">double</span> ramp(<span class="keywordtype">double</span> x)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (x &gt; 0)</div><div class="line">    <span class="keywordflow">return</span> x;</div><div class="line">  <span class="keywordflow">else</span> </div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">  <a class="code" href="classEigen_1_1Matrix.html">Matrix4d</a> m1 = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4d::Random</a>();</div><div class="line">  cout &lt;&lt; m1 &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;becomes: &quot;</span> &lt;&lt; endl &lt;&lt; m1.<a class="code" href="classEigen_1_1MatrixBase.html#a3929764ba38ac4eeca46274a0bf3a7b3">unaryExpr</a>(ptr_fun(ramp)) &lt;&lt; endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> Output: </p><pre class="fragment">   0.68   0.823  -0.444   -0.27
 -0.211  -0.605   0.108  0.0268
  0.566   -0.33 -0.0452   0.904
  0.597   0.536   0.258   0.832
becomes: 
  0.68  0.823      0      0
     0      0  0.108 0.0268
 0.566      0      0  0.904
 0.597  0.536  0.258  0.832
</pre><p>Genuine functors allow for more possibilities, for instance it may contain a state.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"></div><div class="line"><span class="comment">// define a custom template unary functor</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Scalar&gt;</div><div class="line"><span class="keyword">struct </span>CwiseClampOp {</div><div class="line">  CwiseClampOp(<span class="keyword">const</span> Scalar&amp; inf, <span class="keyword">const</span> Scalar&amp; sup) : m_inf(inf), m_sup(sup) {}</div><div class="line">  <span class="keyword">const</span> Scalar operator()(<span class="keyword">const</span> Scalar&amp; x)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> x&lt;m_inf ? m_inf : (x&gt;m_sup ? m_sup : x); }</div><div class="line">  Scalar m_inf, m_sup;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">  <a class="code" href="classEigen_1_1Matrix.html">Matrix4d</a> m1 = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4d::Random</a>();</div><div class="line">  cout &lt;&lt; m1 &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;becomes: &quot;</span> &lt;&lt; endl &lt;&lt; m1.<a class="code" href="classEigen_1_1MatrixBase.html#a3929764ba38ac4eeca46274a0bf3a7b3">unaryExpr</a>(CwiseClampOp&lt;double&gt;(-0.5,0.5)) &lt;&lt; endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> Output: </p><pre class="fragment">   0.68   0.823  -0.444   -0.27
 -0.211  -0.605   0.108  0.0268
  0.566   -0.33 -0.0452   0.904
  0.597   0.536   0.258   0.832
becomes: 
    0.5     0.5  -0.444   -0.27
 -0.211    -0.5   0.108  0.0268
    0.5   -0.33 -0.0452     0.5
    0.5     0.5   0.258     0.5
</pre><p>This method does not change the sparsity of <code>*this</code>: the unary function is applied to explicitly stored coefficients only. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseCompressedBase.html#a7cf299e08d2a4f6d6869e631e51b12fe">SparseCompressedBase::coeffs()</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseMatrixBase.html#a009918bb363546f107f5bdc1ea0610f3">unaryViewExpr</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#aaa71e627acbc873db1885d0fb72189a6">binaryExpr</a>, class <a class="el" href="classEigen_1_1CwiseUnaryOp.html" title="Generic expression where a coefficient-wise unary operator is applied to an expression. ">CwiseUnaryOp</a> </dd></dl>

</div>
</div>
<a id="a009918bb363546f107f5bdc1ea0610f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009918bb363546f107f5bdc1ea0610f3">&#9670;&nbsp;</a></span>unaryViewExpr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename CustomViewOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryView.html">CwiseUnaryView</a>&lt;CustomViewOp, const Derived&gt; <a class="el" href="classEigen_1_1SparseMatrixBase.html">Eigen::SparseMatrixBase</a>&lt; Derived &gt;::unaryViewExpr </td>
          <td>(</td>
          <td class="paramtype">const CustomViewOp &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code>CustomViewOp()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a custom coefficient-wise unary operator <em>func</em> of *this</dd></dl>
<p>The template parameter <em>CustomUnaryOp</em> is the type of the functor of the custom unary operator.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"></div><div class="line"><span class="comment">// define a custom template unary functor</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Scalar&gt;</div><div class="line"><span class="keyword">struct </span>CwiseClampOp {</div><div class="line">  CwiseClampOp(<span class="keyword">const</span> Scalar&amp; inf, <span class="keyword">const</span> Scalar&amp; sup) : m_inf(inf), m_sup(sup) {}</div><div class="line">  <span class="keyword">const</span> Scalar operator()(<span class="keyword">const</span> Scalar&amp; x)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> x&lt;m_inf ? m_inf : (x&gt;m_sup ? m_sup : x); }</div><div class="line">  Scalar m_inf, m_sup;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">  <a class="code" href="classEigen_1_1Matrix.html">Matrix4d</a> m1 = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4d::Random</a>();</div><div class="line">  cout &lt;&lt; m1 &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;becomes: &quot;</span> &lt;&lt; endl &lt;&lt; m1.<a class="code" href="classEigen_1_1MatrixBase.html#a3929764ba38ac4eeca46274a0bf3a7b3">unaryExpr</a>(CwiseClampOp&lt;double&gt;(-0.5,0.5)) &lt;&lt; endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> Output: </p><pre class="fragment">   0.68   0.823  -0.444   -0.27
 -0.211  -0.605   0.108  0.0268
  0.566   -0.33 -0.0452   0.904
  0.597   0.536   0.258   0.832
becomes: 
    0.5     0.5  -0.444   -0.27
 -0.211    -0.5   0.108  0.0268
    0.5   -0.33 -0.0452     0.5
    0.5     0.5   0.258     0.5
</pre><p>This method does not change the sparsity of <code>*this</code>: the unary function is applied to explicitly stored coefficients only. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseCompressedBase.html#a7cf299e08d2a4f6d6869e631e51b12fe">SparseCompressedBase::coeffs()</a> </dd></dl>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseMatrixBase.html#af9bed5dea96bdaf17ffd1a76ab0aedb1" title="Apply a unary operator coefficient-wise. ">unaryExpr</a>, <a class="el" href="classEigen_1_1SparseMatrixBase.html#aaa71e627acbc873db1885d0fb72189a6">binaryExpr</a> class <a class="el" href="classEigen_1_1CwiseUnaryOp.html" title="Generic expression where a coefficient-wise unary operator is applied to an expression. ">CwiseUnaryOp</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a8fc2c86eca0e76d5264e285ff4eea079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc2c86eca0e76d5264e285ff4eea079">&#9670;&nbsp;</a></span>operator*</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_product_op&lt;T,Scalar&gt;,Constant&lt;T&gt;,Derived&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1SparseMatrixBase.html">StorageBaseType</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of <em>expr</em> scaled by the scalar factor <em>scalar</em> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is the scalar type of <em>scalar</em>. It must be compatible with the scalar type of the given expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ForwardDeclarations_8h_source.html">ForwardDeclarations.h</a></li>
<li><a class="el" href="SparseMatrixBase_8h_source.html">SparseMatrixBase.h</a></li>
<li><a class="el" href="SparseAssign_8h_source.html">SparseAssign.h</a></li>
<li><a class="el" href="SparseBlock_8h_source.html">SparseBlock.h</a></li>
<li><a class="el" href="SparseCwiseBinaryOp_8h_source.html">SparseCwiseBinaryOp.h</a></li>
<li><a class="el" href="SparseCwiseUnaryOp_8h_source.html">SparseCwiseUnaryOp.h</a></li>
<li><a class="el" href="SparseDot_8h_source.html">SparseDot.h</a></li>
<li><a class="el" href="SparseFuzzy_8h_source.html">SparseFuzzy.h</a></li>
<li><a class="el" href="SparseProduct_8h_source.html">SparseProduct.h</a></li>
<li><a class="el" href="SparseRedux_8h_source.html">SparseRedux.h</a></li>
<li><a class="el" href="SparseSelfAdjointView_8h_source.html">SparseSelfAdjointView.h</a></li>
<li><a class="el" href="SparseTriangularView_8h_source.html">SparseTriangularView.h</a></li>
<li><a class="el" href="SparseView_8h_source.html">SparseView.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceEigen.html">Eigen</a></li><li class="navelem"><a class="el" href="classEigen_1_1SparseMatrixBase.html">SparseMatrixBase</a></li>
    <li class="footer">Generated on Mon Jan 6 2020 06:37:51 for Eigen by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
<!-- Matomo -->
<script type="text/javascript">
  var _paq = _paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//stats.sylphide-consulting.com/matomo/";
    _paq.push(['setTrackerUrl', u+'piwik.php']);
    _paq.push(['setSiteId', '20']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'piwik.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<noscript><p><img src="//stats.sylphide-consulting.com/matomo/piwik.php?idsite=20&rec=1" style="border:0;" alt="" /></p></noscript>
<!-- End Matomo Code -->
</body>
</html>
