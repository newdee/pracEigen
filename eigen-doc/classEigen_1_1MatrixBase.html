<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Eigen: Eigen::MatrixBase&lt; Derived &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="eigendoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Eigen_Silly_Professor_64x64.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://eigen.tuxfamily.org">Eigen</a>
   &#160;<span id="projectnumber">3.3.7</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classEigen_1_1MatrixBase.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classEigen_1_1MatrixBase-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Eigen::MatrixBase&lt; Derived &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__DenseMatrixManipulation__chapter.html">Dense matrix and array manipulation</a> &raquo; <a class="el" href="group__DenseMatrixManipulation__Reference.html">Reference</a> &raquo; <a class="el" href="group__Core__Module.html">Core module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Derived&gt;<br />
class Eigen::MatrixBase&lt; Derived &gt;</h3>

<p>Base class for all dense matrices, vectors, and expressions. </p>
<p>This class is the base that is inherited by all matrix, vector, and related expression types. Most of the <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library. ">Eigen</a> API is contained in this class, and its base classes. Other important classes for the <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library. ">Eigen</a> API are <a class="el" href="classEigen_1_1Matrix.html" title="The matrix class, also used for vectors and row-vectors. ">Matrix</a>, and <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing partial reduction operations. ">VectorwiseOp</a>.</p>
<p>Note that some methods are defined in other modules such as the <a class="el" href="group__LU__Module.html">LU module</a> LU module for all functions related to matrix inversions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>is the derived type, e.g. a matrix type, or an expression, etc.</td></tr>
  </table>
  </dd>
</dl>
<p>When writing a function taking <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library. ">Eigen</a> objects as argument, if you want your function to take as argument any matrix, vector, or expression, just let it take a <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions. ">MatrixBase</a> argument. As an example, here is a function printFirstRow which, given a matrix, vector, or expression <em>x</em>, prints the first row of <em>x</em>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Derived&gt;</div><div class="line"><span class="keywordtype">void</span> printFirstRow(<span class="keyword">const</span> <a class="code" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase&lt;Derived&gt;</a>&amp; <a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af163a982f5a7ad7e5c3336990b3d7000">x</a>)</div><div class="line">{</div><div class="line">  cout &lt;&lt; <a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af163a982f5a7ad7e5c3336990b3d7000">x</a>.row(0) &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><p>This class can be extended with the help of the plugin mechanism described on the page <a class="el" href="TopicCustomizing_Plugins.html">Extending MatrixBase (and other classes)</a> by defining the preprocessor symbol <code>EIGEN_MATRIXBASE_PLUGIN</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="TopicClassHierarchy.html">The class hierarchy</a> </dd></dl>
</div><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Eigen::MatrixBase&lt; Derived &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classEigen_1_1MatrixBase__inherit__graph.png" border="0" usemap="#Eigen_1_1MatrixBase_3_01Derived_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="Eigen_1_1MatrixBase_3_01Derived_01_4_inherit__map" id="Eigen_1_1MatrixBase_3_01Derived_01_4_inherit__map">
<area shape="rect" id="node7" href="structEigen_1_1doxygen_1_1dense__xpr__base__dispatcher_3_01Matrix_3_01__Scalar_00_01__Rows_00_0116fa1ae814876cf66b62915b437740e6.html" title="{Eigen::doxygen::dense\l_xpr_base_dispatcher\l\&lt; Matrix\&lt; _Scalar, _Rows,\l _Cols, _Options, _MaxRows,\l _MaxCols \&gt; \&gt;\n||}" alt="" coords="19,2283,218,2419"/>
<area shape="rect" id="node2" href="classEigen_1_1DenseBase.html" title="Base class for all dense matrices, vectors, and arrays. " alt="" coords="19,1387,219,1787"/>
<area shape="rect" id="node3" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html" title="Base class providing direct read/write coefficient access to matrices and arrays. ..." alt="" coords="5,1115,232,1339"/>
<area shape="rect" id="node4" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html" title="Base class providing read/write coefficient access to matrices and arrays. " alt="" coords="23,769,215,1067"/>
<area shape="rect" id="node5" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html" title="Base class providing read&#45;only coefficient access to matrices and arrays. " alt="" coords="9,292,228,721"/>
<area shape="rect" id="node6" href="structEigen_1_1EigenBase.html" title="{Eigen::EigenBase\&lt; Derived \&gt;\n||+ addTo()\l+ applyThisOnTheLeft()\l+ applyThisOnTheRight()\l+ cols()\l+ const_cast_derived()\l+ const_derived()\l+ derived()\l+ derived()\l+ evalTo()\l+ rows()\l+ size()\l+ subTo()\l}" alt="" coords="21,5,216,244"/>
<area shape="rect" id="node8" href="classEigen_1_1PlainObjectBase.html" title="{Eigen::PlainObjectBase\l\&lt; Matrix\&lt; _Scalar, _Rows,\l _Cols, _Options, _MaxRows,\l _MaxCols \&gt; \&gt;\n|# m_storage\l|+ base()\l+ base()\l+ coeff()\l+ coeff()\l+ coeffRef()\l+ coeffRef()\l+ coeffRef()\l+ coeffRef()\l+ cols()\l+ conservativeResize()\land 28 more...\l+ Map()\l+ Map()\l+ Map()\l+ Map()\l+ Map()\l+ Map()\l+ Map()\l+ Map()\l+ Map()\l+ Map()\land 14 more...\l# _init1()\l# _init1()\l# _init1()\l# _init1()\l# _init1()\l# _init1()\l# _init1()\l# _init1()\l# _init1()\l# _init1()\land 13 more...\l* Map()\l* Map()\l* Map()\l* Map()\l* Map()\l* Map()\l* Map()\l* Map()\l* Map()\l* Map()\land 14 more...\l}" alt="" coords="19,2467,218,3219"/>
<area shape="rect" id="node9" href="classEigen_1_1Matrix.html" title="The matrix class, also used for vectors and row&#45;vectors. " alt="" coords="32,3267,205,3520"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afacca1f88da57e5cd87dd07c8ff926bb"><td class="memItemLeft" align="right" valign="top">const AdjointReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#afacca1f88da57e5cd87dd07c8ff926bb">adjoint</a> () const</td></tr>
<tr class="separator:afacca1f88da57e5cd87dd07c8ff926bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c5982c1f64e45a939515b701fa6f4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a51c5982c1f64e45a939515b701fa6f4a">adjointInPlace</a> ()</td></tr>
<tr class="separator:a51c5982c1f64e45a939515b701fa6f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2c8059ef3f04cfa0c73b4c012db855"><td class="memTemplParams" colspan="2">template&lt;typename EssentialPart &gt; </td></tr>
<tr class="memitem:a8f2c8059ef3f04cfa0c73b4c012db855"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a8f2c8059ef3f04cfa0c73b4c012db855">applyHouseholderOnTheLeft</a> (const EssentialPart &amp;essential, const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;tau, <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> *workspace)</td></tr>
<tr class="separator:a8f2c8059ef3f04cfa0c73b4c012db855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e52262b41fa40e194dda245e0f9675"><td class="memTemplParams" colspan="2">template&lt;typename EssentialPart &gt; </td></tr>
<tr class="memitem:ab3e52262b41fa40e194dda245e0f9675"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ab3e52262b41fa40e194dda245e0f9675">applyHouseholderOnTheRight</a> (const EssentialPart &amp;essential, const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;tau, <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> *workspace)</td></tr>
<tr class="separator:ab3e52262b41fa40e194dda245e0f9675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a08ad41e81d8ad4a37b5d5c7490e765"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a3a08ad41e81d8ad4a37b5d5c7490e765"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a3a08ad41e81d8ad4a37b5d5c7490e765">applyOnTheLeft</a> (const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a3a08ad41e81d8ad4a37b5d5c7490e765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae669131f6e18f7e8f06fae271754f435"><td class="memTemplParams" colspan="2">template&lt;typename OtherScalar &gt; </td></tr>
<tr class="memitem:ae669131f6e18f7e8f06fae271754f435"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ae669131f6e18f7e8f06fae271754f435">applyOnTheLeft</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> p, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> q, const <a class="el" href="classEigen_1_1JacobiRotation.html">JacobiRotation</a>&lt; OtherScalar &gt; &amp;j)</td></tr>
<tr class="separator:ae669131f6e18f7e8f06fae271754f435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d91752925d2757fc8058a293b15462"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a45d91752925d2757fc8058a293b15462"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a45d91752925d2757fc8058a293b15462">applyOnTheRight</a> (const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a45d91752925d2757fc8058a293b15462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa07f741c86219601664433777827bf1c"><td class="memTemplParams" colspan="2">template&lt;typename OtherScalar &gt; </td></tr>
<tr class="memitem:gaa07f741c86219601664433777827bf1c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Jacobi__Module.html#gaa07f741c86219601664433777827bf1c">applyOnTheRight</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> p, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> q, const <a class="el" href="classEigen_1_1JacobiRotation.html">JacobiRotation</a>&lt; OtherScalar &gt; &amp;j)</td></tr>
<tr class="separator:gaa07f741c86219601664433777827bf1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354c33eec32ceb4193d002f4d41c0497"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1ArrayWrapper.html">ArrayWrapper</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a354c33eec32ceb4193d002f4d41c0497">array</a> ()</td></tr>
<tr class="separator:a354c33eec32ceb4193d002f4d41c0497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f287fe7b2a7e7a66d16cc88166d47f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1ArrayWrapper.html">ArrayWrapper</a>&lt; const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a72f287fe7b2a7e7a66d16cc88166d47f">array</a> () const</td></tr>
<tr class="separator:a72f287fe7b2a7e7a66d16cc88166d47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14235b62c90f93fe910070b4743782d0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1DiagonalWrapper.html">DiagonalWrapper</a>&lt; const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a14235b62c90f93fe910070b4743782d0">asDiagonal</a> () const</td></tr>
<tr class="separator:a14235b62c90f93fe910070b4743782d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae171b74b5d530846ee0836135ffcf837"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1BDCSVD.html">BDCSVD</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ae171b74b5d530846ee0836135ffcf837">bdcSvd</a> (unsigned int computationOptions=0) const</td></tr>
<tr class="separator:ae171b74b5d530846ee0836135ffcf837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1063a3752d30b568e52c89ce4e567489"><td class="memTemplParams" colspan="2">template&lt;typename CustomBinaryOp , typename OtherDerived &gt; </td></tr>
<tr class="memitem:a1063a3752d30b568e52c89ce4e567489"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; CustomBinaryOp, const Derived, const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a1063a3752d30b568e52c89ce4e567489">binaryExpr</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other, const CustomBinaryOp &amp;func=CustomBinaryOp()) const</td></tr>
<tr class="separator:a1063a3752d30b568e52c89ce4e567489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3faa00163c16824ff03e58a210c74c"><td class="memItemLeft" align="right" valign="top">RealScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a3f3faa00163c16824ff03e58a210c74c">blueNorm</a> () const</td></tr>
<tr class="separator:a3f3faa00163c16824ff03e58a210c74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ced8ab26cd4c468dea52dacbefa1bc"><td class="memTemplParams" colspan="2">template&lt;typename NewType &gt; </td></tr>
<tr class="memitem:ab2ced8ab26cd4c468dea52dacbefa1bc"><td class="memTemplItemLeft" align="right" valign="top">CastXpr&lt; NewType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ab2ced8ab26cd4c468dea52dacbefa1bc">cast</a> () const</td></tr>
<tr class="separator:ab2ced8ab26cd4c468dea52dacbefa1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee8c19c833245bbb00a591dce68e8a4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1ColPivHouseholderQR.html">ColPivHouseholderQR</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#adee8c19c833245bbb00a591dce68e8a4">colPivHouseholderQr</a> () const</td></tr>
<tr class="separator:adee8c19c833245bbb00a591dce68e8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90b6846f05bd30b8d52b66e427e3e09"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CompleteOrthogonalDecomposition.html">CompleteOrthogonalDecomposition</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ae90b6846f05bd30b8d52b66e427e3e09">completeOrthogonalDecomposition</a> () const</td></tr>
<tr class="separator:ae90b6846f05bd30b8d52b66e427e3e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7baaf2fdec0191a2166cf9fd84a2dcb2"><td class="memTemplParams" colspan="2">template&lt;typename ResultType &gt; </td></tr>
<tr class="memitem:a7baaf2fdec0191a2166cf9fd84a2dcb2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a7baaf2fdec0191a2166cf9fd84a2dcb2">computeInverseAndDetWithCheck</a> (ResultType &amp;<a class="el" href="classEigen_1_1MatrixBase.html#a7712eb69e8ea3c8f7b8da1c44dbdeebf">inverse</a>, typename ResultType::Scalar &amp;<a class="el" href="classEigen_1_1MatrixBase.html#a7ad8f77004bb956b603bb43fd2e3c061">determinant</a>, bool &amp;invertible, const RealScalar &amp;absDeterminantThreshold=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="separator:a7baaf2fdec0191a2166cf9fd84a2dcb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116f3b50d2af7dbdf7473e517a5b8b0f"><td class="memTemplParams" colspan="2">template&lt;typename ResultType &gt; </td></tr>
<tr class="memitem:a116f3b50d2af7dbdf7473e517a5b8b0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a116f3b50d2af7dbdf7473e517a5b8b0f">computeInverseWithCheck</a> (ResultType &amp;<a class="el" href="classEigen_1_1MatrixBase.html#a7712eb69e8ea3c8f7b8da1c44dbdeebf">inverse</a>, bool &amp;invertible, const RealScalar &amp;absDeterminantThreshold=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="separator:a116f3b50d2af7dbdf7473e517a5b8b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07794fba1534fa85baa54b84cb45ce10"><td class="memItemLeft" align="right" valign="top">ConjugateReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a07794fba1534fa85baa54b84cb45ce10">conjugate</a> () const</td></tr>
<tr class="memdesc:a07794fba1534fa85baa54b84cb45ce10"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
  <a href="#a07794fba1534fa85baa54b84cb45ce10">More...</a><br /></td></tr>
<tr class="separator:a07794fba1534fa85baa54b84cb45ce10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d626eb756bbeb4069d1eb0e6494c65"><td class="memItemLeft" align="right" valign="top">const MatrixFunctionReturnValue&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a34d626eb756bbeb4069d1eb0e6494c65">cos</a> () const</td></tr>
<tr class="memdesc:a34d626eb756bbeb4069d1eb0e6494c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function requires the <a href="unsupported/group__MatrixFunctions__Module.html">unsupported MatrixFunctions module</a>. To compute the coefficient-wise cosine use <a class="el" href="classEigen_1_1ArrayBase.html#a02c07fce456a1a6ec9510ca8b0934911">ArrayBase::cos</a> .  <a href="#a34d626eb756bbeb4069d1eb0e6494c65">More...</a><br /></td></tr>
<tr class="separator:a34d626eb756bbeb4069d1eb0e6494c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627e6f11bf5854ade9a5abfc344c0367"><td class="memItemLeft" align="right" valign="top">const MatrixFunctionReturnValue&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a627e6f11bf5854ade9a5abfc344c0367">cosh</a> () const</td></tr>
<tr class="memdesc:a627e6f11bf5854ade9a5abfc344c0367"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function requires the <a href="unsupported/group__MatrixFunctions__Module.html">unsupported MatrixFunctions module</a>. To compute the coefficient-wise hyperbolic cosine use <a class="el" href="classEigen_1_1ArrayBase.html#a3f34a09fc1a72fd2dc6b5fafb857fcb8">ArrayBase::cosh</a> .  <a href="#a627e6f11bf5854ade9a5abfc344c0367">More...</a><br /></td></tr>
<tr class="separator:a627e6f11bf5854ade9a5abfc344c0367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0024b44eca99cb7135887c2aaf319d28"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ga0024b44eca99cb7135887c2aaf319d28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Geometry__Module.html#ga0024b44eca99cb7135887c2aaf319d28">cross</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:ga0024b44eca99cb7135887c2aaf319d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabde56e2a0baba550815a0b05139e4d42"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:gabde56e2a0baba550815a0b05139e4d42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Geometry__Module.html#gabde56e2a0baba550815a0b05139e4d42">cross3</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:gabde56e2a0baba550815a0b05139e4d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04b39cbc74f2e12e3609df7117b0394"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseAbsReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ae04b39cbc74f2e12e3609df7117b0394">cwiseAbs</a> () const</td></tr>
<tr class="separator:ae04b39cbc74f2e12e3609df7117b0394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0147ae59510af37efc4b8f79358324b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseAbs2ReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aa0147ae59510af37efc4b8f79358324b">cwiseAbs2</a> () const</td></tr>
<tr class="separator:aa0147ae59510af37efc4b8f79358324b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc51452067ce6730d1f68e524958638"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a8cc51452067ce6730d1f68e524958638"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; std::equal_to&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;, const Derived, const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a8cc51452067ce6730d1f68e524958638">cwiseEqual</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a8cc51452067ce6730d1f68e524958638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709120e3c6fd81be98e3735856564f30"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseScalarEqualReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a709120e3c6fd81be98e3735856564f30">cwiseEqual</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;s) const</td></tr>
<tr class="separator:a709120e3c6fd81be98e3735856564f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b11744885ab2680da4093ba0b6cbf6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseInverseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a44b11744885ab2680da4093ba0b6cbf6">cwiseInverse</a> () const</td></tr>
<tr class="separator:a44b11744885ab2680da4093ba0b6cbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b143895b204800f62743554c297c740"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a4b143895b204800f62743554c297c740"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_max_op&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>, <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;, const Derived, const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a4b143895b204800f62743554c297c740">cwiseMax</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a4b143895b204800f62743554c297c740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78c95906920a6dcb53f8bd04e4adf85"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_max_op&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>, <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;, const Derived, const ConstantReturnType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ac78c95906920a6dcb53f8bd04e4adf85">cwiseMax</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;other) const</td></tr>
<tr class="separator:ac78c95906920a6dcb53f8bd04e4adf85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964630f64e1c91a3c5c7418467e89ab5"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a964630f64e1c91a3c5c7418467e89ab5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_min_op&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>, <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;, const Derived, const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a964630f64e1c91a3c5c7418467e89ab5">cwiseMin</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a964630f64e1c91a3c5c7418467e89ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c3a077f1e50b351ca567219c17769c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_min_op&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>, <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;, const Derived, const ConstantReturnType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aa5c3a077f1e50b351ca567219c17769c">cwiseMin</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;other) const</td></tr>
<tr class="separator:aa5c3a077f1e50b351ca567219c17769c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb982322a8a68b3ee9eb9d4e7bae468"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:adeb982322a8a68b3ee9eb9d4e7bae468"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; std::not_equal_to&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;, const Derived, const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#adeb982322a8a68b3ee9eb9d4e7bae468">cwiseNotEqual</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:adeb982322a8a68b3ee9eb9d4e7bae468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d9b053ae69eb1073030dc1a39a4c2f"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a28d9b053ae69eb1073030dc1a39a4c2f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_product_op&lt; Derived ::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>, OtherDerived ::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;, const Derived, const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a28d9b053ae69eb1073030dc1a39a4c2f">cwiseProduct</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a28d9b053ae69eb1073030dc1a39a4c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a45ed73a51bbffec202e504f842299"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ac8a45ed73a51bbffec202e504f842299"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_quotient_op&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;, const Derived, const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ac8a45ed73a51bbffec202e504f842299">cwiseQuotient</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:ac8a45ed73a51bbffec202e504f842299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315e35a856733d37bc85d9c102aa4e01"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseSignReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a315e35a856733d37bc85d9c102aa4e01">cwiseSign</a> () const</td></tr>
<tr class="separator:a315e35a856733d37bc85d9c102aa4e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a49e9a834666aa86e80f55b39926e04"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseSqrtReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a9a49e9a834666aa86e80f55b39926e04">cwiseSqrt</a> () const</td></tr>
<tr class="separator:a9a49e9a834666aa86e80f55b39926e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad8f77004bb956b603bb43fd2e3c061"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a7ad8f77004bb956b603bb43fd2e3c061">determinant</a> () const</td></tr>
<tr class="separator:a7ad8f77004bb956b603bb43fd2e3c061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5768147536273eb2dbdfa389cfd26a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Diagonal.html">DiagonalReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ab5768147536273eb2dbdfa389cfd26a3">diagonal</a> ()</td></tr>
<tr class="separator:ab5768147536273eb2dbdfa389cfd26a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdeedcf67e46d969c556c6c7d9780ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Transpose.html">ConstDiagonalReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aebdeedcf67e46d969c556c6c7d9780ee">diagonal</a> () const</td></tr>
<tr class="separator:aebdeedcf67e46d969c556c6c7d9780ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a13d4b8efbd7797ee8efd3dd988a7f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Diagonal.html">DiagonalDynamicIndexReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a8a13d4b8efbd7797ee8efd3dd988a7f7">diagonal</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> index)</td></tr>
<tr class="separator:a8a13d4b8efbd7797ee8efd3dd988a7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed11a711c0a3d5dbf8bc094008e29846"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Transpose.html">ConstDiagonalDynamicIndexReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aed11a711c0a3d5dbf8bc094008e29846">diagonal</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> index) const</td></tr>
<tr class="separator:aed11a711c0a3d5dbf8bc094008e29846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79e511b9322b8b801858e253fb257eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ab79e511b9322b8b801858e253fb257eb">diagonalSize</a> () const</td></tr>
<tr class="separator:ab79e511b9322b8b801858e253fb257eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd32bf5fcf6ee603c924dde9bf7bc39"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:adfd32bf5fcf6ee603c924dde9bf7bc39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1ScalarBinaryOpTraits.html">ScalarBinaryOpTraits</a>&lt; typename internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>, typename internal::traits&lt; OtherDerived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#adfd32bf5fcf6ee603c924dde9bf7bc39">dot</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:adfd32bf5fcf6ee603c924dde9bf7bc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30430fa3d5b4e74d312fd4f502ac984d"><td class="memItemLeft" align="right" valign="top">EigenvaluesReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a30430fa3d5b4e74d312fd4f502ac984d">eigenvalues</a> () const</td></tr>
<tr class="memdesc:a30430fa3d5b4e74d312fd4f502ac984d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the eigenvalues of a matrix.  <a href="#a30430fa3d5b4e74d312fd4f502ac984d">More...</a><br /></td></tr>
<tr class="separator:a30430fa3d5b4e74d312fd4f502ac984d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17994d2e81b723295f5bc3b1f862ed3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>, 3, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry__Module.html#ga17994d2e81b723295f5bc3b1f862ed3b">eulerAngles</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> a0, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> a1, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> a2) const</td></tr>
<tr class="separator:ga17994d2e81b723295f5bc3b1f862ed3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70901e189e876f64d7f3fee1dbe942cc"><td class="memItemLeft" align="right" valign="top">const MatrixExponentialReturnValue&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a70901e189e876f64d7f3fee1dbe942cc">exp</a> () const</td></tr>
<tr class="memdesc:a70901e189e876f64d7f3fee1dbe942cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function requires the <a href="unsupported/group__MatrixFunctions__Module.html">unsupported MatrixFunctions module</a>. To compute the coefficient-wise exponential use <a class="el" href="classEigen_1_1ArrayBase.html#a555df413a093a7dea1bf59253189c815">ArrayBase::exp</a> .  <a href="#a70901e189e876f64d7f3fee1dbe942cc">More...</a><br /></td></tr>
<tr class="separator:a70901e189e876f64d7f3fee1dbe942cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fdb842d9a715f8778d0b33c29cfe49"><td class="memItemLeft" align="right" valign="top">const Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ad2fdb842d9a715f8778d0b33c29cfe49">forceAlignedAccess</a> () const</td></tr>
<tr class="separator:ad2fdb842d9a715f8778d0b33c29cfe49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdaf810ac1708ca6d6ecdcfac1e06699"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#afdaf810ac1708ca6d6ecdcfac1e06699">forceAlignedAccess</a> ()</td></tr>
<tr class="separator:afdaf810ac1708ca6d6ecdcfac1e06699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42d92f115d4b8fa3d5aa731ed496ed1"><td class="memTemplParams" colspan="2">template&lt;bool Enable&gt; </td></tr>
<tr class="memitem:af42d92f115d4b8fa3d5aa731ed496ed1"><td class="memTemplItemLeft" align="right" valign="top">internal::add_const_on_value_type&lt; typename internal::conditional&lt; Enable, <a class="el" href="classEigen_1_1ForceAlignedAccess.html">ForceAlignedAccess</a>&lt; Derived &gt;, Derived &amp; &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#af42d92f115d4b8fa3d5aa731ed496ed1">forceAlignedAccessIf</a> () const</td></tr>
<tr class="separator:af42d92f115d4b8fa3d5aa731ed496ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35213d1dd4dd13ebe9a7a762d6bb847"><td class="memTemplParams" colspan="2">template&lt;bool Enable&gt; </td></tr>
<tr class="memitem:ae35213d1dd4dd13ebe9a7a762d6bb847"><td class="memTemplItemLeft" align="right" valign="top">internal::conditional&lt; Enable, <a class="el" href="classEigen_1_1ForceAlignedAccess.html">ForceAlignedAccess</a>&lt; Derived &gt;, Derived &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ae35213d1dd4dd13ebe9a7a762d6bb847">forceAlignedAccessIf</a> ()</td></tr>
<tr class="separator:ae35213d1dd4dd13ebe9a7a762d6bb847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863bc0e06b641a089508eabec6835ab2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1FullPivHouseholderQR.html">FullPivHouseholderQR</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a863bc0e06b641a089508eabec6835ab2">fullPivHouseholderQr</a> () const</td></tr>
<tr class="separator:a863bc0e06b641a089508eabec6835ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25da97d31acab0ee5d9d13bdbb0569da"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1FullPivLU.html">FullPivLU</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a25da97d31acab0ee5d9d13bdbb0569da">fullPivLu</a> () const</td></tr>
<tr class="separator:a25da97d31acab0ee5d9d13bdbb0569da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc0e3dd3510cb5a6e70aca9aab1cbf19"><td class="memItemLeft" align="right" valign="top">const HNormalizedReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry__Module.html#gadc0e3dd3510cb5a6e70aca9aab1cbf19">hnormalized</a> () const</td></tr>
<tr class="memdesc:gadc0e3dd3510cb5a6e70aca9aab1cbf19"><td class="mdescLeft">&#160;</td><td class="mdescRight">homogeneous normalization  <a href="group__Geometry__Module.html#gadc0e3dd3510cb5a6e70aca9aab1cbf19">More...</a><br /></td></tr>
<tr class="separator:gadc0e3dd3510cb5a6e70aca9aab1cbf19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3229c2d3669e983075ab91f7f480cb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Homogeneous.html">HomogeneousReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry__Module.html#gaf3229c2d3669e983075ab91f7f480cb1">homogeneous</a> () const</td></tr>
<tr class="separator:gaf3229c2d3669e983075ab91f7f480cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9377aab1cea26db5f25bab7e682f8f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1HouseholderQR.html">HouseholderQR</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a9a9377aab1cea26db5f25bab7e682f8f">householderQr</a> () const</td></tr>
<tr class="separator:a9a9377aab1cea26db5f25bab7e682f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32222d3b6677e6cdf0b801463f329b72"><td class="memItemLeft" align="right" valign="top">RealScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a32222d3b6677e6cdf0b801463f329b72">hypotNorm</a> () const</td></tr>
<tr class="separator:a32222d3b6677e6cdf0b801463f329b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba6327bc264ba4b3fc3dbdfe4b57c60"><td class="memItemLeft" align="right" valign="top">const ImagReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#afba6327bc264ba4b3fc3dbdfe4b57c60">imag</a> () const</td></tr>
<tr class="memdesc:afba6327bc264ba4b3fc3dbdfe4b57c60"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
  <a href="#afba6327bc264ba4b3fc3dbdfe4b57c60">More...</a><br /></td></tr>
<tr class="separator:afba6327bc264ba4b3fc3dbdfe4b57c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae468f7f102d5f04f20b2c0afe6eb0f82"><td class="memItemLeft" align="right" valign="top">NonConstImagReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ae468f7f102d5f04f20b2c0afe6eb0f82">imag</a> ()</td></tr>
<tr class="memdesc:ae468f7f102d5f04f20b2c0afe6eb0f82"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
  <a href="#ae468f7f102d5f04f20b2c0afe6eb0f82">More...</a><br /></td></tr>
<tr class="separator:ae468f7f102d5f04f20b2c0afe6eb0f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7712eb69e8ea3c8f7b8da1c44dbdeebf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Inverse.html">Inverse</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a7712eb69e8ea3c8f7b8da1c44dbdeebf">inverse</a> () const</td></tr>
<tr class="separator:a7712eb69e8ea3c8f7b8da1c44dbdeebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97027ea54c8cd1ddb1c578fee5cedc67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a97027ea54c8cd1ddb1c578fee5cedc67">isDiagonal</a> (const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="separator:a97027ea54c8cd1ddb1c578fee5cedc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccbd8dfa06e9d47b9bf84711f8b9d40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a4ccbd8dfa06e9d47b9bf84711f8b9d40">isIdentity</a> (const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="separator:a4ccbd8dfa06e9d47b9bf84711f8b9d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e96c42d79a56f0a6ade30ce031e17eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a1e96c42d79a56f0a6ade30ce031e17eb">isLowerTriangular</a> (const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="separator:a1e96c42d79a56f0a6ade30ce031e17eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdc8e4e4c156fdd79a21479e75dcd8a"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:aefdc8e4e4c156fdd79a21479e75dcd8a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aefdc8e4e4c156fdd79a21479e75dcd8a">isOrthogonal</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other, const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="separator:aefdc8e4e4c156fdd79a21479e75dcd8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7ee34ce202cac3eeea9cf20c9e4833"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a8a7ee34ce202cac3eeea9cf20c9e4833">isUnitary</a> (const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="separator:a8a7ee34ce202cac3eeea9cf20c9e4833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3ec1660bb4ac584220481c54ab4a64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aae3ec1660bb4ac584220481c54ab4a64">isUpperTriangular</a> (const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="separator:aae3ec1660bb4ac584220481c54ab4a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5745dca9c54390633b434e54a1d1eedd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1JacobiSVD.html">JacobiSVD</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a5745dca9c54390633b434e54a1d1eedd">jacobiSvd</a> (unsigned int computationOptions=0) const</td></tr>
<tr class="separator:a5745dca9c54390633b434e54a1d1eedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c280b1066c14ed577021f38876527f"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ae0c280b1066c14ed577021f38876527f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Product.html">Product</a>&lt; Derived, OtherDerived, LazyProduct &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ae0c280b1066c14ed577021f38876527f">lazyProduct</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:ae0c280b1066c14ed577021f38876527f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecf058a0727a4cab8b42d79e95072e1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1LDLT.html">LDLT</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a0ecf058a0727a4cab8b42d79e95072e1">ldlt</a> () const</td></tr>
<tr class="separator:a0ecf058a0727a4cab8b42d79e95072e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c45f7a30265df792d5aeaddead2635"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1LLT.html">LLT</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a90c45f7a30265df792d5aeaddead2635">llt</a> () const</td></tr>
<tr class="separator:a90c45f7a30265df792d5aeaddead2635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc57b319fc1cf8c9035016e56602a7d"><td class="memItemLeft" align="right" valign="top">const MatrixLogarithmReturnValue&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a4dc57b319fc1cf8c9035016e56602a7d">log</a> () const</td></tr>
<tr class="memdesc:a4dc57b319fc1cf8c9035016e56602a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function requires the <a href="unsupported/group__MatrixFunctions__Module.html">unsupported MatrixFunctions module</a>. To compute the coefficient-wise logarithm use <a class="el" href="classEigen_1_1ArrayBase.html#a49537efa216ab4e72f7493149d4057b9">ArrayBase::log</a> .  <a href="#a4dc57b319fc1cf8c9035016e56602a7d">More...</a><br /></td></tr>
<tr class="separator:a4dc57b319fc1cf8c9035016e56602a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72586ab059e889e7d2894ff227747e35"><td class="memTemplParams" colspan="2">template&lt;int p&gt; </td></tr>
<tr class="memitem:a72586ab059e889e7d2894ff227747e35"><td class="memTemplItemLeft" align="right" valign="top">RealScalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a72586ab059e889e7d2894ff227747e35">lpNorm</a> () const</td></tr>
<tr class="separator:a72586ab059e889e7d2894ff227747e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb312afbfe960cbda67811552d876fae"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialPivLU.html">PartialPivLU</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#afb312afbfe960cbda67811552d876fae">lu</a> () const</td></tr>
<tr class="separator:afb312afbfe960cbda67811552d876fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13291e900f7e81ddc6e5b8802f82092b"><td class="memTemplParams" colspan="2">template&lt;typename EssentialPart &gt; </td></tr>
<tr class="memitem:a13291e900f7e81ddc6e5b8802f82092b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a13291e900f7e81ddc6e5b8802f82092b">makeHouseholder</a> (EssentialPart &amp;essential, <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;tau, RealScalar &amp;beta) const</td></tr>
<tr class="separator:a13291e900f7e81ddc6e5b8802f82092b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf4bac7dffe2685ab93734fb776e817"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aebf4bac7dffe2685ab93734fb776e817">makeHouseholderInPlace</a> (<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;tau, RealScalar &amp;beta)</td></tr>
<tr class="separator:aebf4bac7dffe2685ab93734fb776e817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6cc9f734eb175e785a1118305245fc"><td class="memItemLeft" align="right" valign="top"><a id="a1a6cc9f734eb175e785a1118305245fc"></a>
const MatrixFunctionReturnValue&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a1a6cc9f734eb175e785a1118305245fc">matrixFunction</a> (StemFunction f) const</td></tr>
<tr class="memdesc:a1a6cc9f734eb175e785a1118305245fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for the <a href="unsupported/group__MatrixFunctions__Module.html">unsupported MatrixFunctions module</a>. <br /></td></tr>
<tr class="separator:a1a6cc9f734eb175e785a1118305245fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1085de7645f23f240876388457da0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1NoAlias.html">NoAlias</a>&lt; Derived, <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a2c1085de7645f23f240876388457da0b">noalias</a> ()</td></tr>
<tr class="separator:a2c1085de7645f23f240876388457da0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196c4ec3c8ffdf5bda45d0f617154975"><td class="memItemLeft" align="right" valign="top">RealScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a196c4ec3c8ffdf5bda45d0f617154975">norm</a> () const</td></tr>
<tr class="separator:a196c4ec3c8ffdf5bda45d0f617154975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16303c47ba36f7a41ea264cb26bceb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ad16303c47ba36f7a41ea264cb26bceb6">normalize</a> ()</td></tr>
<tr class="separator:ad16303c47ba36f7a41ea264cb26bceb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf2fd4c57e59604fd4116158fd34308"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a5cf2fd4c57e59604fd4116158fd34308">normalized</a> () const</td></tr>
<tr class="separator:a5cf2fd4c57e59604fd4116158fd34308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c2d83286636c8f6fde6b26539d656f"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a71c2d83286636c8f6fde6b26539d656f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_boolean_and_op, const Derived, const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a71c2d83286636c8f6fde6b26539d656f">operator &amp;&amp;</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a71c2d83286636c8f6fde6b26539d656f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028c7ac8094d610042fd0f9feca68f63"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a028c7ac8094d610042fd0f9feca68f63"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a028c7ac8094d610042fd0f9feca68f63">operator!=</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a028c7ac8094d610042fd0f9feca68f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2816a4d2f2e86899e7f8986719d08889"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2816a4d2f2e86899e7f8986719d08889"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_product_op&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>, T &gt;, Derived, <a class="el" href="classEigen_1_1DenseBase.html#a68a7ece6c5629d1e9447a321fcb14ccd">Constant</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a2816a4d2f2e86899e7f8986719d08889">operator*</a> (const T &amp;scalar) const</td></tr>
<tr class="separator:a2816a4d2f2e86899e7f8986719d08889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d220efbf7047f0894787888288cfcc"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ae2d220efbf7047f0894787888288cfcc"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Product.html">Product</a>&lt; Derived, OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ae2d220efbf7047f0894787888288cfcc">operator*</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:ae2d220efbf7047f0894787888288cfcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fb95c37f0a454e0e2e5cb120b2df7f"><td class="memTemplParams" colspan="2">template&lt;typename DiagonalDerived &gt; </td></tr>
<tr class="memitem:a36fb95c37f0a454e0e2e5cb120b2df7f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Product.html">Product</a>&lt; Derived, DiagonalDerived, LazyProduct &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a36fb95c37f0a454e0e2e5cb120b2df7f">operator*</a> (const DiagonalBase&lt; DiagonalDerived &gt; &amp;<a class="el" href="classEigen_1_1MatrixBase.html#ab5768147536273eb2dbdfa389cfd26a3">diagonal</a>) const</td></tr>
<tr class="separator:a36fb95c37f0a454e0e2e5cb120b2df7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3783b6168995ca117a1c19fea3630ac4"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a3783b6168995ca117a1c19fea3630ac4"><td class="memTemplItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a3783b6168995ca117a1c19fea3630ac4">operator*=</a> (const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a3783b6168995ca117a1c19fea3630ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4d02dad6db83c4235dafbaaebe140f"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:acc4d02dad6db83c4235dafbaaebe140f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#addd7080d5c202795820e361768d0140c">sum</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;, const Derived, const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#acc4d02dad6db83c4235dafbaaebe140f">operator+</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:acc4d02dad6db83c4235dafbaaebe140f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983cc3be0bbe11b3d041a415b76ce010"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a983cc3be0bbe11b3d041a415b76ce010"><td class="memTemplItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a983cc3be0bbe11b3d041a415b76ce010">operator+=</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a983cc3be0bbe11b3d041a415b76ce010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6b17344c30a260af7c570e3367fd71"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:aed6b17344c30a260af7c570e3367fd71"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; difference&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;, const Derived, const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aed6b17344c30a260af7c570e3367fd71">operator-</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:aed6b17344c30a260af7c570e3367fd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2e247775438bfa1ff6dbacc5963efe"><td class="memItemLeft" align="right" valign="top">const NegativeReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a5c2e247775438bfa1ff6dbacc5963efe">operator-</a> () const</td></tr>
<tr class="separator:a5c2e247775438bfa1ff6dbacc5963efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1042124b0ddee66e78ac7b0a9ac4cc9c"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a1042124b0ddee66e78ac7b0a9ac4cc9c"><td class="memTemplItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a1042124b0ddee66e78ac7b0a9ac4cc9c">operator-=</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a1042124b0ddee66e78ac7b0a9ac4cc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1864d9378be2cc8ab7b47bf9f8bb4f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2d1864d9378be2cc8ab7b47bf9f8bb4f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_quotient_op&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>, T &gt;, Derived, <a class="el" href="classEigen_1_1DenseBase.html#a68a7ece6c5629d1e9447a321fcb14ccd">Constant</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a2d1864d9378be2cc8ab7b47bf9f8bb4f">operator/</a> (const T &amp;scalar) const</td></tr>
<tr class="separator:a2d1864d9378be2cc8ab7b47bf9f8bb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373bf62ad398162df5a71963ed7cbeff"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a373bf62ad398162df5a71963ed7cbeff">operator=</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a> &amp;other)</td></tr>
<tr class="separator:a373bf62ad398162df5a71963ed7cbeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e3e1e83fdf43f9f7fb6ff51836b24d"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a80e3e1e83fdf43f9f7fb6ff51836b24d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a80e3e1e83fdf43f9f7fb6ff51836b24d">operator==</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a80e3e1e83fdf43f9f7fb6ff51836b24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff9bc0b9bea2d0822a2bf3192783102"><td class="memItemLeft" align="right" valign="top">RealScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a0ff9bc0b9bea2d0822a2bf3192783102">operatorNorm</a> () const</td></tr>
<tr class="memdesc:a0ff9bc0b9bea2d0822a2bf3192783102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the L2 operator norm.  <a href="#a0ff9bc0b9bea2d0822a2bf3192783102">More...</a><br /></td></tr>
<tr class="separator:a0ff9bc0b9bea2d0822a2bf3192783102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f44fface70a468cf9df2a4b33448298"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a6f44fface70a468cf9df2a4b33448298"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_boolean_or_op, const Derived, const OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a6f44fface70a468cf9df2a4b33448298">operator||</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a6f44fface70a468cf9df2a4b33448298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6199d8aaf26c1b8ac3097fdfa7733a1e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialPivLU.html">PartialPivLU</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a6199d8aaf26c1b8ac3097fdfa7733a1e">partialPivLu</a> () const</td></tr>
<tr class="separator:a6199d8aaf26c1b8ac3097fdfa7733a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae6c25e6a94a60e147741e76203a73b"><td class="memItemLeft" align="right" valign="top">const MatrixPowerReturnValue&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a7ae6c25e6a94a60e147741e76203a73b">pow</a> (const RealScalar &amp;p) const</td></tr>
<tr class="memdesc:a7ae6c25e6a94a60e147741e76203a73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function requires the <a href="unsupported/group__MatrixFunctions__Module.html">unsupported MatrixFunctions module</a>. To compute the coefficient-wise power to <code>p</code> use <a class="el" href="classEigen_1_1ArrayBase.html#a9b2dc1fc2bd04821c160e0f3ab6bc9f5">ArrayBase::pow</a> .  <a href="#a7ae6c25e6a94a60e147741e76203a73b">More...</a><br /></td></tr>
<tr class="separator:a7ae6c25e6a94a60e147741e76203a73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91dcacf224bd8b18346914bdf7eefc31"><td class="memItemLeft" align="right" valign="top">const MatrixComplexPowerReturnValue&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a91dcacf224bd8b18346914bdf7eefc31">pow</a> (const std::complex&lt; RealScalar &gt; &amp;p) const</td></tr>
<tr class="memdesc:a91dcacf224bd8b18346914bdf7eefc31"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function requires the <a href="unsupported/group__MatrixFunctions__Module.html">unsupported MatrixFunctions module</a>. To compute the coefficient-wise power to <code>p</code> use <a class="el" href="classEigen_1_1ArrayBase.html#a9b2dc1fc2bd04821c160e0f3ab6bc9f5">ArrayBase::pow</a> .  <a href="#a91dcacf224bd8b18346914bdf7eefc31">More...</a><br /></td></tr>
<tr class="separator:a91dcacf224bd8b18346914bdf7eefc31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cd7dac79f90b56495b7772bdeaa4b8"><td class="memItemLeft" align="right" valign="top">RealReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a05cd7dac79f90b56495b7772bdeaa4b8">real</a> () const</td></tr>
<tr class="memdesc:a05cd7dac79f90b56495b7772bdeaa4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
  <a href="#a05cd7dac79f90b56495b7772bdeaa4b8">More...</a><br /></td></tr>
<tr class="separator:a05cd7dac79f90b56495b7772bdeaa4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba1be140ede8b142460b325945c551f"><td class="memItemLeft" align="right" valign="top">NonConstRealReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aeba1be140ede8b142460b325945c551f">real</a> ()</td></tr>
<tr class="memdesc:aeba1be140ede8b142460b325945c551f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
  <a href="#aeba1be140ede8b142460b325945c551f">More...</a><br /></td></tr>
<tr class="separator:aeba1be140ede8b142460b325945c551f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67eb836f331d9b567e7f36ec0782fa07"><td class="memTemplParams" colspan="2">template&lt;unsigned int UpLo&gt; </td></tr>
<tr class="memitem:a67eb836f331d9b567e7f36ec0782fa07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::template ConstSelfAdjointViewReturnType&lt; UpLo &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a67eb836f331d9b567e7f36ec0782fa07">selfadjointView</a> () const</td></tr>
<tr class="separator:a67eb836f331d9b567e7f36ec0782fa07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad446541377593656c1399862fe6a0f94"><td class="memTemplParams" colspan="2">template&lt;unsigned int UpLo&gt; </td></tr>
<tr class="memitem:ad446541377593656c1399862fe6a0f94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::template SelfAdjointViewReturnType&lt; UpLo &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ad446541377593656c1399862fe6a0f94">selfadjointView</a> ()</td></tr>
<tr class="separator:ad446541377593656c1399862fe6a0f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e969adfdf2db4ac44c47fbdc854683"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a18e969adfdf2db4ac44c47fbdc854683">setIdentity</a> ()</td></tr>
<tr class="separator:a18e969adfdf2db4ac44c47fbdc854683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97dec020729928e328fe8ae9aad1e99e"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a97dec020729928e328fe8ae9aad1e99e">setIdentity</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#ab75c2d8a783d055db397319c5a330eee">rows</a>, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#a16145eb95335754c2ff8b2a58731bc53">cols</a>)</td></tr>
<tr class="memdesc:a97dec020729928e328fe8ae9aad1e99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes to the given size, and writes the identity expression (not necessarily square) into *this.  <a href="#a97dec020729928e328fe8ae9aad1e99e">More...</a><br /></td></tr>
<tr class="separator:a97dec020729928e328fe8ae9aad1e99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f4ff0fcbbae2f3ccaa5981e8ad5e34"><td class="memItemLeft" align="right" valign="top">const MatrixFunctionReturnValue&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a02f4ff0fcbbae2f3ccaa5981e8ad5e34">sin</a> () const</td></tr>
<tr class="memdesc:a02f4ff0fcbbae2f3ccaa5981e8ad5e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function requires the <a href="unsupported/group__MatrixFunctions__Module.html">unsupported MatrixFunctions module</a>. To compute the coefficient-wise sine use <a class="el" href="classEigen_1_1ArrayBase.html#ae865fde726793307cf91245393e6c79d">ArrayBase::sin</a> .  <a href="#a02f4ff0fcbbae2f3ccaa5981e8ad5e34">More...</a><br /></td></tr>
<tr class="separator:a02f4ff0fcbbae2f3ccaa5981e8ad5e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c37eab2dc7baf83809269254c9129e0"><td class="memItemLeft" align="right" valign="top">const MatrixFunctionReturnValue&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a9c37eab2dc7baf83809269254c9129e0">sinh</a> () const</td></tr>
<tr class="memdesc:a9c37eab2dc7baf83809269254c9129e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function requires the <a href="unsupported/group__MatrixFunctions__Module.html">unsupported MatrixFunctions module</a>. To compute the coefficient-wise hyperbolic sine use <a class="el" href="classEigen_1_1ArrayBase.html#a343f3b40026376ce47c171d140570a78">ArrayBase::sinh</a> .  <a href="#a9c37eab2dc7baf83809269254c9129e0">More...</a><br /></td></tr>
<tr class="separator:a9c37eab2dc7baf83809269254c9129e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga320dd291cbf4339c6118c41521b75350"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1SparseView.html">SparseView</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SparseCore__Module.html#ga320dd291cbf4339c6118c41521b75350">sparseView</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;m_reference=<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>(0), const typename <a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::Real &amp;m_epsilon=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="separator:ga320dd291cbf4339c6118c41521b75350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad873dca860bd47baeeede8663e161b83"><td class="memItemLeft" align="right" valign="top">const MatrixSquareRootReturnValue&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ad873dca860bd47baeeede8663e161b83">sqrt</a> () const</td></tr>
<tr class="memdesc:ad873dca860bd47baeeede8663e161b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function requires the <a href="unsupported/group__MatrixFunctions__Module.html">unsupported MatrixFunctions module</a>. To compute the coefficient-wise square root use <a class="el" href="classEigen_1_1ArrayBase.html#adbe7fe792be28d5293ae6a586b36c028">ArrayBase::sqrt</a> .  <a href="#ad873dca860bd47baeeede8663e161b83">More...</a><br /></td></tr>
<tr class="separator:ad873dca860bd47baeeede8663e161b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8da566526419f9742a6c471bbd87e0a"><td class="memItemLeft" align="right" valign="top">RealScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ac8da566526419f9742a6c471bbd87e0a">squaredNorm</a> () const</td></tr>
<tr class="separator:ac8da566526419f9742a6c471bbd87e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84d3e64f855813b1eea4202c0697dc1"><td class="memItemLeft" align="right" valign="top">RealScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ab84d3e64f855813b1eea4202c0697dc1">stableNorm</a> () const</td></tr>
<tr class="separator:ab84d3e64f855813b1eea4202c0697dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1443fa322615379557ade3399a3c3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a0b1443fa322615379557ade3399a3c3c">stableNormalize</a> ()</td></tr>
<tr class="separator:a0b1443fa322615379557ade3399a3c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399dca938633b9f8df5ec4beefeccec0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a399dca938633b9f8df5ec4beefeccec0">stableNormalized</a> () const</td></tr>
<tr class="separator:a399dca938633b9f8df5ec4beefeccec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544b609f65eb2bd3e368b3fc2d79479e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a544b609f65eb2bd3e368b3fc2d79479e">trace</a> () const</td></tr>
<tr class="separator:a544b609f65eb2bd3e368b3fc2d79479e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56665aa894f49f2765291fee0eaeb9c6"><td class="memTemplParams" colspan="2">template&lt;unsigned int Mode&gt; </td></tr>
<tr class="memitem:a56665aa894f49f2765291fee0eaeb9c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::template TriangularViewReturnType&lt; Mode &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a56665aa894f49f2765291fee0eaeb9c6">triangularView</a> ()</td></tr>
<tr class="separator:a56665aa894f49f2765291fee0eaeb9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa044521145e74117ad1df42460d7b520"><td class="memTemplParams" colspan="2">template&lt;unsigned int Mode&gt; </td></tr>
<tr class="memitem:aa044521145e74117ad1df42460d7b520"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::template ConstTriangularViewReturnType&lt; Mode &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aa044521145e74117ad1df42460d7b520">triangularView</a> () const</td></tr>
<tr class="separator:aa044521145e74117ad1df42460d7b520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3929764ba38ac4eeca46274a0bf3a7b3"><td class="memTemplParams" colspan="2">template&lt;typename CustomUnaryOp &gt; </td></tr>
<tr class="memitem:a3929764ba38ac4eeca46274a0bf3a7b3"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt; CustomUnaryOp, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a3929764ba38ac4eeca46274a0bf3a7b3">unaryExpr</a> (const CustomUnaryOp &amp;func=CustomUnaryOp()) const</td></tr>
<tr class="memdesc:a3929764ba38ac4eeca46274a0bf3a7b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a unary operator coefficient-wise.  <a href="#a3929764ba38ac4eeca46274a0bf3a7b3">More...</a><br /></td></tr>
<tr class="separator:a3929764ba38ac4eeca46274a0bf3a7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b928f32954852ffb4a103f49e3cbc18"><td class="memTemplParams" colspan="2">template&lt;typename CustomViewOp &gt; </td></tr>
<tr class="memitem:a2b928f32954852ffb4a103f49e3cbc18"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryView.html">CwiseUnaryView</a>&lt; CustomViewOp, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a2b928f32954852ffb4a103f49e3cbc18">unaryViewExpr</a> (const CustomViewOp &amp;func=CustomViewOp()) const</td></tr>
<tr class="separator:a2b928f32954852ffb4a103f49e3cbc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0dc2c32a9379eeb2b4c4a05c1a6fe52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry__Module.html#gaa0dc2c32a9379eeb2b4c4a05c1a6fe52">unitOrthogonal</a> (void) const</td></tr>
<tr class="separator:gaa0dc2c32a9379eeb2b4c4a05c1a6fe52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEigen_1_1DenseBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEigen_1_1DenseBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase&lt; Derived &gt;</a></td></tr>
<tr class="memitem:ae42ab60296c120e9f45ce3b44e1761a4 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ae42ab60296c120e9f45ce3b44e1761a4">all</a> () const</td></tr>
<tr class="separator:ae42ab60296c120e9f45ce3b44e1761a4 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e669fd3aaae50a4870dc1b8f3b8884 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#af1e669fd3aaae50a4870dc1b8f3b8884">allFinite</a> () const</td></tr>
<tr class="separator:af1e669fd3aaae50a4870dc1b8f3b8884 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbf4cb72dd577e62fbe035b1c53e695 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#abfbf4cb72dd577e62fbe035b1c53e695">any</a> () const</td></tr>
<tr class="separator:abfbf4cb72dd577e62fbe035b1c53e695 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc046747cc9329cc02e208a122e002e inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">BlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a0cc046747cc9329cc02e208a122e002e">block</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startRow, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startCol, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> blockRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> blockCols)</td></tr>
<tr class="separator:a0cc046747cc9329cc02e208a122e002e inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfe53232c88432b04374a6ebd54ea83 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a id="a7dfe53232c88432b04374a6ebd54ea83"></a>
const ConstBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a7dfe53232c88432b04374a6ebd54ea83">block</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startRow, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startCol, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> blockRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> blockCols) const</td></tr>
<tr class="memdesc:a7dfe53232c88432b04374a6ebd54ea83 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a0cc046747cc9329cc02e208a122e002e">block(Index,Index,Index,Index)</a>. */. <br /></td></tr>
<tr class="separator:a7dfe53232c88432b04374a6ebd54ea83 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa632e9e729e54614cb02e1eafdee28b7 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;int NRows, int NCols&gt; </td></tr>
<tr class="memitem:aa632e9e729e54614cb02e1eafdee28b7 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">FixedBlockXpr&lt; NRows, NCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa632e9e729e54614cb02e1eafdee28b7">block</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startRow, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startCol)</td></tr>
<tr class="separator:aa632e9e729e54614cb02e1eafdee28b7 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4feeb4fcdfbc1c4142e386082d2a5e inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2"><a id="acb4feeb4fcdfbc1c4142e386082d2a5e"></a>
template&lt;int NRows, int NCols&gt; </td></tr>
<tr class="memitem:acb4feeb4fcdfbc1c4142e386082d2a5e inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">const ConstFixedBlockXpr&lt; NRows, NCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#acb4feeb4fcdfbc1c4142e386082d2a5e">block</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startRow, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startCol) const</td></tr>
<tr class="memdesc:acb4feeb4fcdfbc1c4142e386082d2a5e inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#aa632e9e729e54614cb02e1eafdee28b7">block&lt;&gt;(Index, Index)</a>. */. <br /></td></tr>
<tr class="separator:acb4feeb4fcdfbc1c4142e386082d2a5e inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31c9f4e5739f48c43903a7971bed9f5 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;int NRows, int NCols&gt; </td></tr>
<tr class="memitem:ad31c9f4e5739f48c43903a7971bed9f5 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">FixedBlockXpr&lt; NRows, NCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ad31c9f4e5739f48c43903a7971bed9f5">block</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startRow, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startCol, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> blockRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> blockCols)</td></tr>
<tr class="separator:ad31c9f4e5739f48c43903a7971bed9f5 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcadf0223a613e236ebc7c717e29c5c0 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2"><a id="adcadf0223a613e236ebc7c717e29c5c0"></a>
template&lt;int NRows, int NCols&gt; </td></tr>
<tr class="memitem:adcadf0223a613e236ebc7c717e29c5c0 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">const ConstFixedBlockXpr&lt; NRows, NCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#adcadf0223a613e236ebc7c717e29c5c0">block</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startRow, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startCol, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> blockRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> blockCols) const</td></tr>
<tr class="memdesc:adcadf0223a613e236ebc7c717e29c5c0 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a0cc046747cc9329cc02e208a122e002e">block&lt;&gt;(Index, Index, Index, Index)</a>. <br /></td></tr>
<tr class="separator:adcadf0223a613e236ebc7c717e29c5c0 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac0fa65efc3f318bd3bace804b01ad4 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">BlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a6ac0fa65efc3f318bd3bace804b01ad4">bottomLeftCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols)</td></tr>
<tr class="separator:a6ac0fa65efc3f318bd3bace804b01ad4 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fc75e553f7d2cbfc7db3dfd240bcb0 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a id="aa3fc75e553f7d2cbfc7db3dfd240bcb0"></a>
const ConstBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa3fc75e553f7d2cbfc7db3dfd240bcb0">bottomLeftCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols) const</td></tr>
<tr class="memdesc:aa3fc75e553f7d2cbfc7db3dfd240bcb0 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a6ac0fa65efc3f318bd3bace804b01ad4">bottomLeftCorner(Index, Index)</a>. <br /></td></tr>
<tr class="separator:aa3fc75e553f7d2cbfc7db3dfd240bcb0 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10949a9280dc910c06bd937c0fe586d9 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a10949a9280dc910c06bd937c0fe586d9 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">FixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a10949a9280dc910c06bd937c0fe586d9">bottomLeftCorner</a> ()</td></tr>
<tr class="separator:a10949a9280dc910c06bd937c0fe586d9 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ed1eff5ffff0d6617c55c25f73ee25 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2"><a id="a77ed1eff5ffff0d6617c55c25f73ee25"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a77ed1eff5ffff0d6617c55c25f73ee25 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">const ConstFixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a77ed1eff5ffff0d6617c55c25f73ee25">bottomLeftCorner</a> () const</td></tr>
<tr class="memdesc:a77ed1eff5ffff0d6617c55c25f73ee25 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a10949a9280dc910c06bd937c0fe586d9">bottomLeftCorner&lt;int, int&gt;()</a>. <br /></td></tr>
<tr class="separator:a77ed1eff5ffff0d6617c55c25f73ee25 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5031f68cc0b39c743eae168ed010b94 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:ac5031f68cc0b39c743eae168ed010b94 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">FixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ac5031f68cc0b39c743eae168ed010b94">bottomLeftCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols)</td></tr>
<tr class="separator:ac5031f68cc0b39c743eae168ed010b94 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf9ffde8bbc8bb29df873699518893b inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2"><a id="a7cf9ffde8bbc8bb29df873699518893b"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a7cf9ffde8bbc8bb29df873699518893b inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">const ConstFixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a7cf9ffde8bbc8bb29df873699518893b">bottomLeftCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols) const</td></tr>
<tr class="memdesc:a7cf9ffde8bbc8bb29df873699518893b inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a6ac0fa65efc3f318bd3bace804b01ad4">bottomLeftCorner&lt;int, int&gt;(Index, Index)</a>. <br /></td></tr>
<tr class="separator:a7cf9ffde8bbc8bb29df873699518893b inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2733739c86fc837b5df837d62ea0ade5 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">BlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a2733739c86fc837b5df837d62ea0ade5">bottomRightCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols)</td></tr>
<tr class="separator:a2733739c86fc837b5df837d62ea0ade5 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc60b28236bd26945e4c28c6accca29 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a id="a1fc60b28236bd26945e4c28c6accca29"></a>
const ConstBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a1fc60b28236bd26945e4c28c6accca29">bottomRightCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols) const</td></tr>
<tr class="memdesc:a1fc60b28236bd26945e4c28c6accca29 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a2733739c86fc837b5df837d62ea0ade5">bottomRightCorner(Index, Index)</a>. <br /></td></tr>
<tr class="separator:a1fc60b28236bd26945e4c28c6accca29 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a8dd26f943ed61bfcc7b912677523b inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a65a8dd26f943ed61bfcc7b912677523b inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">FixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a65a8dd26f943ed61bfcc7b912677523b">bottomRightCorner</a> ()</td></tr>
<tr class="separator:a65a8dd26f943ed61bfcc7b912677523b inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac860595c41daec812c35ba47809b4f16 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2"><a id="ac860595c41daec812c35ba47809b4f16"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:ac860595c41daec812c35ba47809b4f16 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">const ConstFixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ac860595c41daec812c35ba47809b4f16">bottomRightCorner</a> () const</td></tr>
<tr class="memdesc:ac860595c41daec812c35ba47809b4f16 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a65a8dd26f943ed61bfcc7b912677523b">bottomRightCorner&lt;int, int&gt;()</a>. <br /></td></tr>
<tr class="separator:ac860595c41daec812c35ba47809b4f16 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ad879b121a7f1ea716f287d8df7cf8 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a68ad879b121a7f1ea716f287d8df7cf8 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">FixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a68ad879b121a7f1ea716f287d8df7cf8">bottomRightCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols)</td></tr>
<tr class="separator:a68ad879b121a7f1ea716f287d8df7cf8 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d80e43aca655ed92009030f8d34976 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2"><a id="a43d80e43aca655ed92009030f8d34976"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a43d80e43aca655ed92009030f8d34976 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">const ConstFixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a43d80e43aca655ed92009030f8d34976">bottomRightCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols) const</td></tr>
<tr class="memdesc:a43d80e43aca655ed92009030f8d34976 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a2733739c86fc837b5df837d62ea0ade5">bottomRightCorner&lt;int, int&gt;(Index, Index)</a>. <br /></td></tr>
<tr class="separator:a43d80e43aca655ed92009030f8d34976 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36137187863fe127fe88e7388eacabaa inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">RowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a36137187863fe127fe88e7388eacabaa">bottomRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n)</td></tr>
<tr class="separator:a36137187863fe127fe88e7388eacabaa inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88f39afa605f7e8a0bb3d823b4c39f6 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a id="ae88f39afa605f7e8a0bb3d823b4c39f6"></a>
ConstRowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ae88f39afa605f7e8a0bb3d823b4c39f6">bottomRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n) const</td></tr>
<tr class="memdesc:ae88f39afa605f7e8a0bb3d823b4c39f6 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a36137187863fe127fe88e7388eacabaa">bottomRows(Index)</a>. <br /></td></tr>
<tr class="separator:ae88f39afa605f7e8a0bb3d823b4c39f6 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164290bc114be03e0d71ee3b8dca86ac inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a164290bc114be03e0d71ee3b8dca86ac inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">NRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a164290bc114be03e0d71ee3b8dca86ac">bottomRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N)</td></tr>
<tr class="separator:a164290bc114be03e0d71ee3b8dca86ac inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407f6b9fb6e67503cc551a339dde85a9 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2"><a id="a407f6b9fb6e67503cc551a339dde85a9"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:a407f6b9fb6e67503cc551a339dde85a9 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">ConstNRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a407f6b9fb6e67503cc551a339dde85a9">bottomRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N) const</td></tr>
<tr class="memdesc:a407f6b9fb6e67503cc551a339dde85a9 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a36137187863fe127fe88e7388eacabaa">bottomRows&lt;int&gt;()</a>. <br /></td></tr>
<tr class="separator:a407f6b9fb6e67503cc551a339dde85a9 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f3b8aeaf37cb1decc9413ffceafa0f inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">ColXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a27f3b8aeaf37cb1decc9413ffceafa0f">col</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> i)</td></tr>
<tr class="separator:a27f3b8aeaf37cb1decc9413ffceafa0f inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c63405b4f66d00ea3ab6ca1c3fd138 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a id="a68c63405b4f66d00ea3ab6ca1c3fd138"></a>
ConstColXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a68c63405b4f66d00ea3ab6ca1c3fd138">col</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> i) const</td></tr>
<tr class="memdesc:a68c63405b4f66d00ea3ab6ca1c3fd138 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a27f3b8aeaf37cb1decc9413ffceafa0f">col()</a>. <br /></td></tr>
<tr class="separator:a68c63405b4f66d00ea3ab6ca1c3fd138 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58837c81de446efbdb58da07b73a63c1 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html">ConstColwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a58837c81de446efbdb58da07b73a63c1">colwise</a> () const</td></tr>
<tr class="separator:a58837c81de446efbdb58da07b73a63c1 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0e1b6067ec1de6cb8799da55aa7d30 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html">ColwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a1c0e1b6067ec1de6cb8799da55aa7d30">colwise</a> ()</td></tr>
<tr class="separator:a1c0e1b6067ec1de6cb8799da55aa7d30 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229be090c665b9bf7d1fcdfd1ab6e0c1 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a229be090c665b9bf7d1fcdfd1ab6e0c1">count</a> () const</td></tr>
<tr class="separator:a229be090c665b9bf7d1fcdfd1ab6e0c1 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73e57a2f0f7cfcb4ad4d55ea0b6414b inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">EvalReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa73e57a2f0f7cfcb4ad4d55ea0b6414b">eval</a> () const</td></tr>
<tr class="separator:aa73e57a2f0f7cfcb4ad4d55ea0b6414b inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be169c308801411aa24be93d30930bf inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a9be169c308801411aa24be93d30930bf">fill</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;<a class="el" href="classEigen_1_1DenseBase.html#a8515f719046aa4851e385661f45595b0">value</a>)</td></tr>
<tr class="separator:a9be169c308801411aa24be93d30930bf inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3f75f76ae40439be870258e80c7346 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;unsigned int Added, unsigned int Removed&gt; </td></tr>
<tr class="memitem:a9b3f75f76ae40439be870258e80c7346 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEPRECATED const Derived &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a9b3f75f76ae40439be870258e80c7346">flagged</a> () const</td></tr>
<tr class="separator:a9b3f75f76ae40439be870258e80c7346 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab231f1a6057f28d4244145e12c9fc0c7 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1WithFormat.html">WithFormat</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ab231f1a6057f28d4244145e12c9fc0c7">format</a> (const <a class="el" href="structEigen_1_1IOFormat.html">IOFormat</a> &amp;fmt) const</td></tr>
<tr class="separator:ab231f1a6057f28d4244145e12c9fc0c7 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13d158c900560d3e1b25d85d2d33dd6 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ab13d158c900560d3e1b25d85d2d33dd6">hasNaN</a> () const</td></tr>
<tr class="separator:ab13d158c900560d3e1b25d85d2d33dd6 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae458ead2be3576e80ffdfa5616778cd5 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">SegmentReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ae458ead2be3576e80ffdfa5616778cd5">head</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n)</td></tr>
<tr class="separator:ae458ead2be3576e80ffdfa5616778cd5 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e53394afd5aea4e3aa8fdbaa4b56958 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a id="a5e53394afd5aea4e3aa8fdbaa4b56958"></a>
ConstSegmentReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a5e53394afd5aea4e3aa8fdbaa4b56958">head</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n) const</td></tr>
<tr class="memdesc:a5e53394afd5aea4e3aa8fdbaa4b56958 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#ae458ead2be3576e80ffdfa5616778cd5">head(Index)</a>. <br /></td></tr>
<tr class="separator:a5e53394afd5aea4e3aa8fdbaa4b56958 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f84542e210e33d270e8739cc7a58e8e inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a7f84542e210e33d270e8739cc7a58e8e inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">FixedSegmentReturnType&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a7f84542e210e33d270e8739cc7a58e8e">head</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N)</td></tr>
<tr class="separator:a7f84542e210e33d270e8739cc7a58e8e inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc63ed57d91bb5d8bb4371e05154ed61 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2"><a id="acc63ed57d91bb5d8bb4371e05154ed61"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:acc63ed57d91bb5d8bb4371e05154ed61 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">ConstFixedSegmentReturnType&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#acc63ed57d91bb5d8bb4371e05154ed61">head</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N) const</td></tr>
<tr class="memdesc:acc63ed57d91bb5d8bb4371e05154ed61 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#ae458ead2be3576e80ffdfa5616778cd5">head&lt;int&gt;()</a>. <br /></td></tr>
<tr class="separator:acc63ed57d91bb5d8bb4371e05154ed61 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714a7964441e3db0510fe7675c2cae6d inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a714a7964441e3db0510fe7675c2cae6d">innerSize</a> () const</td></tr>
<tr class="separator:a714a7964441e3db0510fe7675c2cae6d inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8443357b808cd393be1b51974213f9c inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ae8443357b808cd393be1b51974213f9c inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ae8443357b808cd393be1b51974213f9c">isApprox</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other, const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="separator:ae8443357b808cd393be1b51974213f9c inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b150d48bc5e4366887ccb466e40c6b inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#af9b150d48bc5e4366887ccb466e40c6b">isApproxToConstant</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;<a class="el" href="classEigen_1_1DenseBase.html#a8515f719046aa4851e385661f45595b0">value</a>, const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="separator:af9b150d48bc5e4366887ccb466e40c6b inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca84e4179b3e5081ed11d89bbd9e74f inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a1ca84e4179b3e5081ed11d89bbd9e74f">isConstant</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;<a class="el" href="classEigen_1_1DenseBase.html#a8515f719046aa4851e385661f45595b0">value</a>, const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="separator:a1ca84e4179b3e5081ed11d89bbd9e74f inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfca6ff4e473f68fbbeabbd03b7504a9 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:adfca6ff4e473f68fbbeabbd03b7504a9 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#adfca6ff4e473f68fbbeabbd03b7504a9">isMuchSmallerThan</a> (const typename <a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::Real &amp;other, const RealScalar &amp;prec) const</td></tr>
<tr class="separator:adfca6ff4e473f68fbbeabbd03b7504a9 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4db0c6dd974fa88bbb58b2cf3d5664 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a3c4db0c6dd974fa88bbb58b2cf3d5664 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a3c4db0c6dd974fa88bbb58b2cf3d5664">isMuchSmallerThan</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other, const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="separator:a3c4db0c6dd974fa88bbb58b2cf3d5664 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56d6b4477cd3c92a9cf42f4b96e47c2 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa56d6b4477cd3c92a9cf42f4b96e47c2">isOnes</a> (const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="separator:aa56d6b4477cd3c92a9cf42f4b96e47c2 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36014ec300f53a65083057ed4e89822 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#af36014ec300f53a65083057ed4e89822">isZero</a> (const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::dummy_precision()) const</td></tr>
<tr class="separator:af36014ec300f53a65083057ed4e89822 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7c4e7a7264c0acde4632d35a9a2635 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">ColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a4c7c4e7a7264c0acde4632d35a9a2635">leftCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n)</td></tr>
<tr class="separator:a4c7c4e7a7264c0acde4632d35a9a2635 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace26683b51ab8bbd1b9afe33b16ddf51 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a id="ace26683b51ab8bbd1b9afe33b16ddf51"></a>
ConstColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ace26683b51ab8bbd1b9afe33b16ddf51">leftCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n) const</td></tr>
<tr class="memdesc:ace26683b51ab8bbd1b9afe33b16ddf51 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a4c7c4e7a7264c0acde4632d35a9a2635">leftCols(Index)</a>. <br /></td></tr>
<tr class="separator:ace26683b51ab8bbd1b9afe33b16ddf51 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30354cabc5eb2383b037984171680386 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a30354cabc5eb2383b037984171680386 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">NColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a30354cabc5eb2383b037984171680386">leftCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N)</td></tr>
<tr class="separator:a30354cabc5eb2383b037984171680386 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b7c2a596f060f6dd2306faa4221939 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2"><a id="a73b7c2a596f060f6dd2306faa4221939"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:a73b7c2a596f060f6dd2306faa4221939 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">ConstNColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a73b7c2a596f060f6dd2306faa4221939">leftCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N) const</td></tr>
<tr class="memdesc:a73b7c2a596f060f6dd2306faa4221939 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a4c7c4e7a7264c0acde4632d35a9a2635">leftCols&lt;int&gt;()</a>. <br /></td></tr>
<tr class="separator:a73b7c2a596f060f6dd2306faa4221939 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3710cb36d81cd490b3a2ff3556471b inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a6f3710cb36d81cd490b3a2ff3556471b">maxCoeff</a> () const</td></tr>
<tr class="separator:a6f3710cb36d81cd490b3a2ff3556471b inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784e23ccbb39e7c57b70af386f94f8b5 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;typename IndexType &gt; </td></tr>
<tr class="memitem:a784e23ccbb39e7c57b70af386f94f8b5 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a784e23ccbb39e7c57b70af386f94f8b5">maxCoeff</a> (IndexType *<a class="el" href="classEigen_1_1DenseBase.html#a09bc4a61cdf4ad219db0e70de12c2ae2">row</a>, IndexType *<a class="el" href="classEigen_1_1DenseBase.html#a27f3b8aeaf37cb1decc9413ffceafa0f">col</a>) const</td></tr>
<tr class="separator:a784e23ccbb39e7c57b70af386f94f8b5 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe70186a582e114a590afe9570dcc926 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;typename IndexType &gt; </td></tr>
<tr class="memitem:afe70186a582e114a590afe9570dcc926 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#afe70186a582e114a590afe9570dcc926">maxCoeff</a> (IndexType *index) const</td></tr>
<tr class="separator:afe70186a582e114a590afe9570dcc926 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ac6c0419a72ad7a88ea0bc189017d7 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a21ac6c0419a72ad7a88ea0bc189017d7">mean</a> () const</td></tr>
<tr class="separator:a21ac6c0419a72ad7a88ea0bc189017d7 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f65c4d33b2ac9d32d158181c6b23e2 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">ColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ab4f65c4d33b2ac9d32d158181c6b23e2">middleCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startCol, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> numCols)</td></tr>
<tr class="separator:ab4f65c4d33b2ac9d32d158181c6b23e2 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3354aa82f1ed7f7703992d040a101c inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a id="a1e3354aa82f1ed7f7703992d040a101c"></a>
ConstColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a1e3354aa82f1ed7f7703992d040a101c">middleCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startCol, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> numCols) const</td></tr>
<tr class="memdesc:a1e3354aa82f1ed7f7703992d040a101c inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#ab4f65c4d33b2ac9d32d158181c6b23e2">middleCols(Index,Index)</a>. <br /></td></tr>
<tr class="separator:a1e3354aa82f1ed7f7703992d040a101c inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22e661d1b3b9747c85b0246c3e78b84 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ae22e661d1b3b9747c85b0246c3e78b84 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">NColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ae22e661d1b3b9747c85b0246c3e78b84">middleCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startCol, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N)</td></tr>
<tr class="separator:ae22e661d1b3b9747c85b0246c3e78b84 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548cc72cefdbd8b9020a87f678f038d0 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2"><a id="a548cc72cefdbd8b9020a87f678f038d0"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:a548cc72cefdbd8b9020a87f678f038d0 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">ConstNColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a548cc72cefdbd8b9020a87f678f038d0">middleCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startCol, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N) const</td></tr>
<tr class="memdesc:a548cc72cefdbd8b9020a87f678f038d0 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#ab4f65c4d33b2ac9d32d158181c6b23e2">middleCols&lt;int&gt;()</a>. <br /></td></tr>
<tr class="separator:a548cc72cefdbd8b9020a87f678f038d0 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef4483df4451e9cf5a629e70132aa22 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">RowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a4ef4483df4451e9cf5a629e70132aa22">middleRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startRow, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n)</td></tr>
<tr class="separator:a4ef4483df4451e9cf5a629e70132aa22 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e41af172128dc65ff38bc058598fc24 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a id="a9e41af172128dc65ff38bc058598fc24"></a>
ConstRowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a9e41af172128dc65ff38bc058598fc24">middleRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startRow, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n) const</td></tr>
<tr class="memdesc:a9e41af172128dc65ff38bc058598fc24 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a4ef4483df4451e9cf5a629e70132aa22">middleRows(Index,Index)</a>. <br /></td></tr>
<tr class="separator:a9e41af172128dc65ff38bc058598fc24 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab963fb858672cea77e0b00f52f80422f inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ab963fb858672cea77e0b00f52f80422f inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">NRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ab963fb858672cea77e0b00f52f80422f">middleRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startRow, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N)</td></tr>
<tr class="separator:ab963fb858672cea77e0b00f52f80422f inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25a1a40ec5c03602ea13216f3a40746 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2"><a id="af25a1a40ec5c03602ea13216f3a40746"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:af25a1a40ec5c03602ea13216f3a40746 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">ConstNRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#af25a1a40ec5c03602ea13216f3a40746">middleRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> startRow, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N) const</td></tr>
<tr class="memdesc:af25a1a40ec5c03602ea13216f3a40746 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a4ef4483df4451e9cf5a629e70132aa22">middleRows&lt;int&gt;()</a>. <br /></td></tr>
<tr class="separator:af25a1a40ec5c03602ea13216f3a40746 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb695853e9a28ba1dd54861d0cd9d8f inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aaeb695853e9a28ba1dd54861d0cd9d8f">minCoeff</a> () const</td></tr>
<tr class="separator:aaeb695853e9a28ba1dd54861d0cd9d8f inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5731b75a9120bf45202b5d863faa9ee4 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;typename IndexType &gt; </td></tr>
<tr class="memitem:a5731b75a9120bf45202b5d863faa9ee4 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a5731b75a9120bf45202b5d863faa9ee4">minCoeff</a> (IndexType *<a class="el" href="classEigen_1_1DenseBase.html#a09bc4a61cdf4ad219db0e70de12c2ae2">row</a>, IndexType *<a class="el" href="classEigen_1_1DenseBase.html#a27f3b8aeaf37cb1decc9413ffceafa0f">col</a>) const</td></tr>
<tr class="separator:a5731b75a9120bf45202b5d863faa9ee4 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950a030154fa3c525a213dfda8267a85 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;typename IndexType &gt; </td></tr>
<tr class="memitem:a950a030154fa3c525a213dfda8267a85 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a950a030154fa3c525a213dfda8267a85">minCoeff</a> (IndexType *index) const</td></tr>
<tr class="separator:a950a030154fa3c525a213dfda8267a85 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2761e2b6da74dba1d17b40cc918bf7 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1NestByValue.html">NestByValue</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a3e2761e2b6da74dba1d17b40cc918bf7">nestByValue</a> () const</td></tr>
<tr class="separator:a3e2761e2b6da74dba1d17b40cc918bf7 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7183cf5d426883fb8ca5ef6f8a2c49c4 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a7183cf5d426883fb8ca5ef6f8a2c49c4">nonZeros</a> () const</td></tr>
<tr class="separator:a7183cf5d426883fb8ca5ef6f8a2c49c4 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a75198edac1ad62205648445ee30d34 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;typename CustomNullaryOp &gt; </td></tr>
<tr class="memitem:a5a75198edac1ad62205648445ee30d34 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; CustomNullaryOp, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a5a75198edac1ad62205648445ee30d34">NullaryExpr</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#ab75c2d8a783d055db397319c5a330eee">rows</a>, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#a16145eb95335754c2ff8b2a58731bc53">cols</a>, const CustomNullaryOp &amp;func)</td></tr>
<tr class="separator:a5a75198edac1ad62205648445ee30d34 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997ef3960458fb5dedb8f7f78b068a9b inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;typename CustomNullaryOp &gt; </td></tr>
<tr class="memitem:a997ef3960458fb5dedb8f7f78b068a9b inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; CustomNullaryOp, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a997ef3960458fb5dedb8f7f78b068a9b">NullaryExpr</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#adb0d244a512a784ded5319bd1a848440">size</a>, const CustomNullaryOp &amp;func)</td></tr>
<tr class="separator:a997ef3960458fb5dedb8f7f78b068a9b inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fed90701b138c1d38ec52871f4cef1 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;typename CustomNullaryOp &gt; </td></tr>
<tr class="memitem:a57fed90701b138c1d38ec52871f4cef1 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; CustomNullaryOp, typename <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a57fed90701b138c1d38ec52871f4cef1">NullaryExpr</a> (const CustomNullaryOp &amp;func)</td></tr>
<tr class="separator:a57fed90701b138c1d38ec52871f4cef1 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e575eb0ba6cc6bc5f347872abd8509d inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1CommaInitializer.html">CommaInitializer</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a0e575eb0ba6cc6bc5f347872abd8509d">operator&lt;&lt;</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;s)</td></tr>
<tr class="separator:a0e575eb0ba6cc6bc5f347872abd8509d inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0e34696162b34762b2bf4bd948f90c inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a0f0e34696162b34762b2bf4bd948f90c inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1CommaInitializer.html">CommaInitializer</a>&lt; Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a0f0e34696162b34762b2bf4bd948f90c">operator&lt;&lt;</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a0f0e34696162b34762b2bf4bd948f90c inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66155169d20c035e80d521a8b918e97 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ab66155169d20c035e80d521a8b918e97 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ab66155169d20c035e80d521a8b918e97">operator=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:ab66155169d20c035e80d521a8b918e97 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5281dadff89f46eef719b38e5d073a8f inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a5281dadff89f46eef719b38e5d073a8f">operator=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a> &amp;other)</td></tr>
<tr class="separator:a5281dadff89f46eef719b38e5d073a8f inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58915510693d64164e567bd762e1032f inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a58915510693d64164e567bd762e1032f inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a58915510693d64164e567bd762e1032f">operator=</a> (const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memdesc:a58915510693d64164e567bd762e1032f inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the generic expression <em>other</em> into *this.  <a href="classEigen_1_1DenseBase.html#a58915510693d64164e567bd762e1032f">More...</a><br /></td></tr>
<tr class="separator:a58915510693d64164e567bd762e1032f inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cded241a08ab74be620599bb033864d inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a4cded241a08ab74be620599bb033864d">outerSize</a> () const</td></tr>
<tr class="separator:a4cded241a08ab74be620599bb033864d inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af119d9a4efe5a15cd83c1ccdf01b3a4f inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#af119d9a4efe5a15cd83c1ccdf01b3a4f">prod</a> () const</td></tr>
<tr class="separator:af119d9a4efe5a15cd83c1ccdf01b3a4f inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ce1e4fab36bff43bbadcdd06a67724 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a63ce1e4fab36bff43bbadcdd06a67724 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a63ce1e4fab36bff43bbadcdd06a67724">redux</a> (const Func &amp;func) const</td></tr>
<tr class="separator:a63ce1e4fab36bff43bbadcdd06a67724 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dadfe80b813d808e91e4521c722a8e inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;int RowFactor, int ColFactor&gt; </td></tr>
<tr class="memitem:a60dadfe80b813d808e91e4521c722a8e inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a>&lt; Derived, RowFactor, ColFactor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a60dadfe80b813d808e91e4521c722a8e">replicate</a> () const</td></tr>
<tr class="separator:a60dadfe80b813d808e91e4521c722a8e inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae2d5e36f1158d1b1681dac3cdbd58e inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a>&lt; Derived, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#afae2d5e36f1158d1b1681dac3cdbd58e">replicate</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> rowFactor, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> colFactor) const</td></tr>
<tr class="separator:afae2d5e36f1158d1b1681dac3cdbd58e inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec5bac4e1ab95808808ef50ccf4cb39 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a2ec5bac4e1ab95808808ef50ccf4cb39">resize</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> newSize)</td></tr>
<tr class="separator:a2ec5bac4e1ab95808808ef50ccf4cb39 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e2b4887b47b1f2346857d1931efa0f inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a25e2b4887b47b1f2346857d1931efa0f">resize</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#ab75c2d8a783d055db397319c5a330eee">rows</a>, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#a16145eb95335754c2ff8b2a58731bc53">cols</a>)</td></tr>
<tr class="separator:a25e2b4887b47b1f2346857d1931efa0f inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ea394036d8b096abf322469c80198f inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Reverse.html">ReverseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a38ea394036d8b096abf322469c80198f">reverse</a> ()</td></tr>
<tr class="separator:a38ea394036d8b096abf322469c80198f inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2f3ac4019184abf95ca0e1a8d82866 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Reverse.html">ConstReverseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a9e2f3ac4019184abf95ca0e1a8d82866">reverse</a> () const</td></tr>
<tr class="separator:a9e2f3ac4019184abf95ca0e1a8d82866 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8045155ea45f7961fc2a5170e1d921 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#adb8045155ea45f7961fc2a5170e1d921">reverseInPlace</a> ()</td></tr>
<tr class="separator:adb8045155ea45f7961fc2a5170e1d921 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a43920b4d907a7edba59c26fba7b43d inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">ColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a5a43920b4d907a7edba59c26fba7b43d">rightCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n)</td></tr>
<tr class="separator:a5a43920b4d907a7edba59c26fba7b43d inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9393280e51da1cc594394032804781 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a id="acc9393280e51da1cc594394032804781"></a>
ConstColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#acc9393280e51da1cc594394032804781">rightCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n) const</td></tr>
<tr class="memdesc:acc9393280e51da1cc594394032804781 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a5a43920b4d907a7edba59c26fba7b43d">rightCols(Index)</a>. <br /></td></tr>
<tr class="separator:acc9393280e51da1cc594394032804781 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e17ddf77a2648f7077fb5419e06d55f inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a8e17ddf77a2648f7077fb5419e06d55f inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">NColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a8e17ddf77a2648f7077fb5419e06d55f">rightCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N)</td></tr>
<tr class="separator:a8e17ddf77a2648f7077fb5419e06d55f inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea69690c92653c0a1b544ffaa260c70 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2"><a id="a4ea69690c92653c0a1b544ffaa260c70"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:a4ea69690c92653c0a1b544ffaa260c70 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">ConstNColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a4ea69690c92653c0a1b544ffaa260c70">rightCols</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N) const</td></tr>
<tr class="memdesc:a4ea69690c92653c0a1b544ffaa260c70 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a5a43920b4d907a7edba59c26fba7b43d">rightCols&lt;int&gt;()</a>. <br /></td></tr>
<tr class="separator:a4ea69690c92653c0a1b544ffaa260c70 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09bc4a61cdf4ad219db0e70de12c2ae2 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">RowXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a09bc4a61cdf4ad219db0e70de12c2ae2">row</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> i)</td></tr>
<tr class="separator:a09bc4a61cdf4ad219db0e70de12c2ae2 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624618f6fe2271dbd70699c00c2501f5 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a id="a624618f6fe2271dbd70699c00c2501f5"></a>
ConstRowXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a624618f6fe2271dbd70699c00c2501f5">row</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> i) const</td></tr>
<tr class="memdesc:a624618f6fe2271dbd70699c00c2501f5 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a09bc4a61cdf4ad219db0e70de12c2ae2">row()</a>. */. <br /></td></tr>
<tr class="separator:a624618f6fe2271dbd70699c00c2501f5 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1cabd3404528fe8cec4bab43d74bffc inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html">ConstRowwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa1cabd3404528fe8cec4bab43d74bffc">rowwise</a> () const</td></tr>
<tr class="separator:aa1cabd3404528fe8cec4bab43d74bffc inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6daa3a3156ca0e0722bf78638e1c7f28 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html">RowwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a6daa3a3156ca0e0722bf78638e1c7f28">rowwise</a> ()</td></tr>
<tr class="separator:a6daa3a3156ca0e0722bf78638e1c7f28 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6212eee4095a0ab9ac3a2202274ea8d7 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">SegmentReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a6212eee4095a0ab9ac3a2202274ea8d7">segment</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> start, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n)</td></tr>
<tr class="separator:a6212eee4095a0ab9ac3a2202274ea8d7 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e5d6216deaac83e62374d71baee4a4 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a id="ae0e5d6216deaac83e62374d71baee4a4"></a>
ConstSegmentReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ae0e5d6216deaac83e62374d71baee4a4">segment</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> start, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n) const</td></tr>
<tr class="memdesc:ae0e5d6216deaac83e62374d71baee4a4 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a6212eee4095a0ab9ac3a2202274ea8d7">segment(Index,Index)</a>. <br /></td></tr>
<tr class="separator:ae0e5d6216deaac83e62374d71baee4a4 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7bb37ed8d1d38af1d858017f4ec79a inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:adc7bb37ed8d1d38af1d858017f4ec79a inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">FixedSegmentReturnType&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#adc7bb37ed8d1d38af1d858017f4ec79a">segment</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> start, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N)</td></tr>
<tr class="separator:adc7bb37ed8d1d38af1d858017f4ec79a inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1966e96819ba555062ddeef5d5d541d3 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2"><a id="a1966e96819ba555062ddeef5d5d541d3"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:a1966e96819ba555062ddeef5d5d541d3 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">ConstFixedSegmentReturnType&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a1966e96819ba555062ddeef5d5d541d3">segment</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> start, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N) const</td></tr>
<tr class="memdesc:a1966e96819ba555062ddeef5d5d541d3 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of segment&lt;int&gt;(Index). <br /></td></tr>
<tr class="separator:a1966e96819ba555062ddeef5d5d541d3 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e78cfcbc9852e6923bebff4323ddca inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;typename ThenDerived , typename ElseDerived &gt; </td></tr>
<tr class="memitem:a65e78cfcbc9852e6923bebff4323ddca inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Select.html">Select</a>&lt; Derived, ThenDerived, ElseDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a65e78cfcbc9852e6923bebff4323ddca">select</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt; &amp;thenMatrix, const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt; &amp;elseMatrix) const</td></tr>
<tr class="separator:a65e78cfcbc9852e6923bebff4323ddca inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ef09a843004095f84c198dd145641b inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;typename ThenDerived &gt; </td></tr>
<tr class="memitem:a57ef09a843004095f84c198dd145641b inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Select.html">Select</a>&lt; Derived, ThenDerived, typename ThenDerived::ConstantReturnType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a57ef09a843004095f84c198dd145641b">select</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt; &amp;thenMatrix, const typename ThenDerived::Scalar &amp;elseScalar) const</td></tr>
<tr class="separator:a57ef09a843004095f84c198dd145641b inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8e78c75887d4539071a0b7a61ca103 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;typename ElseDerived &gt; </td></tr>
<tr class="memitem:a9e8e78c75887d4539071a0b7a61ca103 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Select.html">Select</a>&lt; Derived, typename ElseDerived::ConstantReturnType, ElseDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a9e8e78c75887d4539071a0b7a61ca103">select</a> (const typename ElseDerived::Scalar &amp;thenScalar, const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt; &amp;elseMatrix) const</td></tr>
<tr class="separator:a9e8e78c75887d4539071a0b7a61ca103 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f1e50d1f567da38da1d2f07c5ab559 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ac2f1e50d1f567da38da1d2f07c5ab559">setConstant</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;<a class="el" href="classEigen_1_1DenseBase.html#a8515f719046aa4851e385661f45595b0">value</a>)</td></tr>
<tr class="separator:ac2f1e50d1f567da38da1d2f07c5ab559 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1ce9e801fa502e02b9b8cd9141ad0a inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a5d1ce9e801fa502e02b9b8cd9141ad0a">setLinSpaced</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#adb0d244a512a784ded5319bd1a848440">size</a>, const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;low, const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;high)</td></tr>
<tr class="memdesc:a5d1ce9e801fa502e02b9b8cd9141ad0a inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a linearly spaced vector.  <a href="classEigen_1_1DenseBase.html#a5d1ce9e801fa502e02b9b8cd9141ad0a">More...</a><br /></td></tr>
<tr class="separator:a5d1ce9e801fa502e02b9b8cd9141ad0a inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb023532476d3f14c457367e0eb5f3f1 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aeb023532476d3f14c457367e0eb5f3f1">setLinSpaced</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;low, const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;high)</td></tr>
<tr class="memdesc:aeb023532476d3f14c457367e0eb5f3f1 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a linearly spaced vector.  <a href="classEigen_1_1DenseBase.html#aeb023532476d3f14c457367e0eb5f3f1">More...</a><br /></td></tr>
<tr class="separator:aeb023532476d3f14c457367e0eb5f3f1 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250ef1b827e748f3f898fb2e55cb96e2 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a250ef1b827e748f3f898fb2e55cb96e2">setOnes</a> ()</td></tr>
<tr class="separator:a250ef1b827e748f3f898fb2e55cb96e2 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac476e5852129ba32beaa1a8a3d7ee0db inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ac476e5852129ba32beaa1a8a3d7ee0db">setRandom</a> ()</td></tr>
<tr class="separator:ac476e5852129ba32beaa1a8a3d7ee0db inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af230a143de50695d2d1fae93db7e4dcb inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#af230a143de50695d2d1fae93db7e4dcb">setZero</a> ()</td></tr>
<tr class="separator:af230a143de50695d2d1fae93db7e4dcb inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd7080d5c202795820e361768d0140c inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#addd7080d5c202795820e361768d0140c">sum</a> () const</td></tr>
<tr class="separator:addd7080d5c202795820e361768d0140c inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e7e4305fdb7781f2b2f05fa801f21e inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:af9e7e4305fdb7781f2b2f05fa801f21e inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#af9e7e4305fdb7781f2b2f05fa801f21e">swap</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:af9e7e4305fdb7781f2b2f05fa801f21e inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e25adc6da9cd1d79f4c5bd7c1819cb inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a44e25adc6da9cd1d79f4c5bd7c1819cb inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a44e25adc6da9cd1d79f4c5bd7c1819cb">swap</a> (<a class="el" href="classEigen_1_1PlainObjectBase.html">PlainObjectBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a44e25adc6da9cd1d79f4c5bd7c1819cb inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70abb2369391a6fe66df2af56e1c2d1e inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">SegmentReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a70abb2369391a6fe66df2af56e1c2d1e">tail</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n)</td></tr>
<tr class="separator:a70abb2369391a6fe66df2af56e1c2d1e inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6436ae46283505af9e57976c7d35d9d inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a id="ac6436ae46283505af9e57976c7d35d9d"></a>
ConstSegmentReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ac6436ae46283505af9e57976c7d35d9d">tail</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n) const</td></tr>
<tr class="memdesc:ac6436ae46283505af9e57976c7d35d9d inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a70abb2369391a6fe66df2af56e1c2d1e">tail(Index)</a>. <br /></td></tr>
<tr class="separator:ac6436ae46283505af9e57976c7d35d9d inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5a1e422ac928c1fc476ce798016b47 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:adf5a1e422ac928c1fc476ce798016b47 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">FixedSegmentReturnType&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#adf5a1e422ac928c1fc476ce798016b47">tail</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N)</td></tr>
<tr class="separator:adf5a1e422ac928c1fc476ce798016b47 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6c9f0397a80591bbf1c201fb92e3d3 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2"><a id="a0e6c9f0397a80591bbf1c201fb92e3d3"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:a0e6c9f0397a80591bbf1c201fb92e3d3 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">ConstFixedSegmentReturnType&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a0e6c9f0397a80591bbf1c201fb92e3d3">tail</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N) const</td></tr>
<tr class="memdesc:a0e6c9f0397a80591bbf1c201fb92e3d3 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of tail&lt;int&gt;. <br /></td></tr>
<tr class="separator:a0e6c9f0397a80591bbf1c201fb92e3d3 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbe241f3c1a307032845b8cb91f142b inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">BlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a9cbe241f3c1a307032845b8cb91f142b">topLeftCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols)</td></tr>
<tr class="separator:a9cbe241f3c1a307032845b8cb91f142b inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946d9af394c4712310c07dc199261ec8 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a id="a946d9af394c4712310c07dc199261ec8"></a>
const ConstBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a946d9af394c4712310c07dc199261ec8">topLeftCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols) const</td></tr>
<tr class="memdesc:a946d9af394c4712310c07dc199261ec8 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a9cbe241f3c1a307032845b8cb91f142b">topLeftCorner(Index, Index)</a>. <br /></td></tr>
<tr class="separator:a946d9af394c4712310c07dc199261ec8 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8664897a39a39fbb8e98d70b94f16d inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a5b8664897a39a39fbb8e98d70b94f16d inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">FixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a5b8664897a39a39fbb8e98d70b94f16d">topLeftCorner</a> ()</td></tr>
<tr class="separator:a5b8664897a39a39fbb8e98d70b94f16d inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522797cacdcf302f3b61c28adb7356e4 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2"><a id="a522797cacdcf302f3b61c28adb7356e4"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a522797cacdcf302f3b61c28adb7356e4 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">const ConstFixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a522797cacdcf302f3b61c28adb7356e4">topLeftCorner</a> () const</td></tr>
<tr class="memdesc:a522797cacdcf302f3b61c28adb7356e4 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a5b8664897a39a39fbb8e98d70b94f16d">topLeftCorner&lt;int, int&gt;()</a>. <br /></td></tr>
<tr class="separator:a522797cacdcf302f3b61c28adb7356e4 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f32fe127ed8e2522806c733faa6570 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a34f32fe127ed8e2522806c733faa6570 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">FixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a34f32fe127ed8e2522806c733faa6570">topLeftCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols)</td></tr>
<tr class="separator:a34f32fe127ed8e2522806c733faa6570 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce933f12d5ff50ac09c11e46a4f6351 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2"><a id="adce933f12d5ff50ac09c11e46a4f6351"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:adce933f12d5ff50ac09c11e46a4f6351 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">const ConstFixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#adce933f12d5ff50ac09c11e46a4f6351">topLeftCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols) const</td></tr>
<tr class="memdesc:adce933f12d5ff50ac09c11e46a4f6351 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a9cbe241f3c1a307032845b8cb91f142b">topLeftCorner&lt;int, int&gt;(Index, Index)</a>. <br /></td></tr>
<tr class="separator:adce933f12d5ff50ac09c11e46a4f6351 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa8ae556c65f8cb3c2f22778cdb4103 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">BlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#acaa8ae556c65f8cb3c2f22778cdb4103">topRightCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols)</td></tr>
<tr class="separator:acaa8ae556c65f8cb3c2f22778cdb4103 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943311d01b4db1bf40ac12f7ffb66c16 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a id="a943311d01b4db1bf40ac12f7ffb66c16"></a>
const ConstBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a943311d01b4db1bf40ac12f7ffb66c16">topRightCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols) const</td></tr>
<tr class="memdesc:a943311d01b4db1bf40ac12f7ffb66c16 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#acaa8ae556c65f8cb3c2f22778cdb4103">topRightCorner(Index, Index)</a>. <br /></td></tr>
<tr class="separator:a943311d01b4db1bf40ac12f7ffb66c16 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122a73bc1c75c6055450a26e03576299 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a122a73bc1c75c6055450a26e03576299 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">FixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a122a73bc1c75c6055450a26e03576299">topRightCorner</a> ()</td></tr>
<tr class="separator:a122a73bc1c75c6055450a26e03576299 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08fcbbf7f9e418e024b27c5badb02d5 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2"><a id="ad08fcbbf7f9e418e024b27c5badb02d5"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:ad08fcbbf7f9e418e024b27c5badb02d5 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">const ConstFixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ad08fcbbf7f9e418e024b27c5badb02d5">topRightCorner</a> () const</td></tr>
<tr class="memdesc:ad08fcbbf7f9e418e024b27c5badb02d5 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a122a73bc1c75c6055450a26e03576299">topRightCorner&lt;int, int&gt;()</a>. <br /></td></tr>
<tr class="separator:ad08fcbbf7f9e418e024b27c5badb02d5 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169529aa33a07465cb46ff5792a666b7 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a169529aa33a07465cb46ff5792a666b7 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">FixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a169529aa33a07465cb46ff5792a666b7">topRightCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols)</td></tr>
<tr class="separator:a169529aa33a07465cb46ff5792a666b7 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bf22188e8bd3679e335a3a126602d4 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2"><a id="af2bf22188e8bd3679e335a3a126602d4"></a>
template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:af2bf22188e8bd3679e335a3a126602d4 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">const ConstFixedBlockXpr&lt; CRows, CCols &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#af2bf22188e8bd3679e335a3a126602d4">topRightCorner</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cRows, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cCols) const</td></tr>
<tr class="memdesc:af2bf22188e8bd3679e335a3a126602d4 inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#acaa8ae556c65f8cb3c2f22778cdb4103">topRightCorner&lt;int, int&gt;(Index, Index)</a>. <br /></td></tr>
<tr class="separator:af2bf22188e8bd3679e335a3a126602d4 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb8bf8b8d6d2648f52dadd0e4cba68e inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">RowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aafb8bf8b8d6d2648f52dadd0e4cba68e">topRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n)</td></tr>
<tr class="separator:aafb8bf8b8d6d2648f52dadd0e4cba68e inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a5223cf192daf2306e28ef6360993d inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a id="a16a5223cf192daf2306e28ef6360993d"></a>
ConstRowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a16a5223cf192daf2306e28ef6360993d">topRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n) const</td></tr>
<tr class="memdesc:a16a5223cf192daf2306e28ef6360993d inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#aafb8bf8b8d6d2648f52dadd0e4cba68e">topRows(Index)</a>. <br /></td></tr>
<tr class="separator:a16a5223cf192daf2306e28ef6360993d inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db19cec73b4ac656dc06b848dfd6a30 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a4db19cec73b4ac656dc06b848dfd6a30 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">NRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a4db19cec73b4ac656dc06b848dfd6a30">topRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N)</td></tr>
<tr class="separator:a4db19cec73b4ac656dc06b848dfd6a30 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0ac6fe60877277856382993620be8b inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2"><a id="acd0ac6fe60877277856382993620be8b"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:acd0ac6fe60877277856382993620be8b inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">ConstNRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#acd0ac6fe60877277856382993620be8b">topRows</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> n=N) const</td></tr>
<tr class="memdesc:acd0ac6fe60877277856382993620be8b inherit pub_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#aafb8bf8b8d6d2648f52dadd0e4cba68e">topRows&lt;int&gt;()</a>. <br /></td></tr>
<tr class="separator:acd0ac6fe60877277856382993620be8b inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8952c19644a4ac7e41bea45c19b909c inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Transpose.html">TransposeReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ac8952c19644a4ac7e41bea45c19b909c">transpose</a> ()</td></tr>
<tr class="separator:ac8952c19644a4ac7e41bea45c19b909c inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c0b074cf93fc194bf91141287cee3f inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Transpose.html">ConstTransposeReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a38c0b074cf93fc194bf91141287cee3f">transpose</a> () const</td></tr>
<tr class="separator:a38c0b074cf93fc194bf91141287cee3f inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac501bd942994af7a95d95bee7a16ad2a inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ac501bd942994af7a95d95bee7a16ad2a">transposeInPlace</a> ()</td></tr>
<tr class="separator:ac501bd942994af7a95d95bee7a16ad2a inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8515f719046aa4851e385661f45595b0 inherit pub_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a8515f719046aa4851e385661f45595b0">value</a> () const</td></tr>
<tr class="separator:a8515f719046aa4851e385661f45595b0 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4225b90fcc74f18dd479b401124b3841 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;typename Visitor &gt; </td></tr>
<tr class="memitem:a4225b90fcc74f18dd479b401124b3841 inherit pub_methods_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a4225b90fcc74f18dd479b401124b3841">visit</a> (Visitor &amp;func) const</td></tr>
<tr class="separator:a4225b90fcc74f18dd479b401124b3841 inherit pub_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html">Eigen::DenseCoeffsBase&lt; Derived, DirectWriteAccessors &gt;</a></td></tr>
<tr class="memitem:a16145eb95335754c2ff8b2a58731bc53 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#a16145eb95335754c2ff8b2a58731bc53">cols</a> () const</td></tr>
<tr class="separator:a16145eb95335754c2ff8b2a58731bc53 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6af285d1c2135599fc10505f8bc4473 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#ab6af285d1c2135599fc10505f8bc4473">colStride</a> () const</td></tr>
<tr class="separator:ab6af285d1c2135599fc10505f8bc4473 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbabe7f12bcbfba3b9a448b1f5e46fa inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#a1fbabe7f12bcbfba3b9a448b1f5e46fa">derived</a> ()</td></tr>
<tr class="separator:a1fbabe7f12bcbfba3b9a448b1f5e46fa inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4f3f1c57b7594b96a7e30f2974ea2e inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memItemLeft" align="right" valign="top">const Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#afd4f3f1c57b7594b96a7e30f2974ea2e">derived</a> () const</td></tr>
<tr class="separator:afd4f3f1c57b7594b96a7e30f2974ea2e inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754e7a58a4407a8319b5beeb652d4282 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#a754e7a58a4407a8319b5beeb652d4282">innerStride</a> () const</td></tr>
<tr class="separator:a754e7a58a4407a8319b5beeb652d4282 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2cce504be7470acae3af19c0618c36 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#a6a2cce504be7470acae3af19c0618c36">outerStride</a> () const</td></tr>
<tr class="separator:a6a2cce504be7470acae3af19c0618c36 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75c2d8a783d055db397319c5a330eee inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#ab75c2d8a783d055db397319c5a330eee">rows</a> () const</td></tr>
<tr class="separator:ab75c2d8a783d055db397319c5a330eee inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dc60c1e6bced467651f2b440b2655d inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#a19dc60c1e6bced467651f2b440b2655d">rowStride</a> () const</td></tr>
<tr class="separator:a19dc60c1e6bced467651f2b440b2655d inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0d244a512a784ded5319bd1a848440 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#adb0d244a512a784ded5319bd1a848440">size</a> () const</td></tr>
<tr class="separator:adb0d244a512a784ded5319bd1a848440 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html">Eigen::DenseCoeffsBase&lt; Derived, WriteAccessors &gt;</a></td></tr>
<tr class="memitem:adc8286576b31e11f056057be666a0ec8 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#adc8286576b31e11f056057be666a0ec8">coeffRef</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> row, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> col)</td></tr>
<tr class="separator:adc8286576b31e11f056057be666a0ec8 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66b7d18b2a85f3139b703126974c900 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#ae66b7d18b2a85f3139b703126974c900">coeffRef</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> index)</td></tr>
<tr class="separator:ae66b7d18b2a85f3139b703126974c900 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16145eb95335754c2ff8b2a58731bc53 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#a16145eb95335754c2ff8b2a58731bc53">cols</a> () const</td></tr>
<tr class="separator:a16145eb95335754c2ff8b2a58731bc53 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4f3f1c57b7594b96a7e30f2974ea2e inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memItemLeft" align="right" valign="top">const Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#afd4f3f1c57b7594b96a7e30f2974ea2e">derived</a> () const</td></tr>
<tr class="separator:afd4f3f1c57b7594b96a7e30f2974ea2e inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbabe7f12bcbfba3b9a448b1f5e46fa inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#a1fbabe7f12bcbfba3b9a448b1f5e46fa">derived</a> ()</td></tr>
<tr class="separator:a1fbabe7f12bcbfba3b9a448b1f5e46fa inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ba07bad9e3026afe54806fdefe32bb inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#ae6ba07bad9e3026afe54806fdefe32bb">operator()</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> row, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> col)</td></tr>
<tr class="separator:ae6ba07bad9e3026afe54806fdefe32bb inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0171eee1d9e582d1ac7ec0f18f5f615a inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#a0171eee1d9e582d1ac7ec0f18f5f615a">operator()</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> index)</td></tr>
<tr class="separator:a0171eee1d9e582d1ac7ec0f18f5f615a inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2040f14e60fed1a4a68ca7f042e1bbf inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#aa2040f14e60fed1a4a68ca7f042e1bbf">operator[]</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> index)</td></tr>
<tr class="separator:aa2040f14e60fed1a4a68ca7f042e1bbf inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75c2d8a783d055db397319c5a330eee inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#ab75c2d8a783d055db397319c5a330eee">rows</a> () const</td></tr>
<tr class="separator:ab75c2d8a783d055db397319c5a330eee inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0d244a512a784ded5319bd1a848440 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#adb0d244a512a784ded5319bd1a848440">size</a> () const</td></tr>
<tr class="separator:adb0d244a512a784ded5319bd1a848440 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af683e04b3926aaf4091581ca24ca09ad inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af683e04b3926aaf4091581ca24ca09ad">w</a> ()</td></tr>
<tr class="separator:af683e04b3926aaf4091581ca24ca09ad inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af163a982f5a7ad7e5c3336990b3d7000 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af163a982f5a7ad7e5c3336990b3d7000">x</a> ()</td></tr>
<tr class="separator:af163a982f5a7ad7e5c3336990b3d7000 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeaa80359bf0c1311f91cdd74a2042a8 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#afeaa80359bf0c1311f91cdd74a2042a8">y</a> ()</td></tr>
<tr class="separator:afeaa80359bf0c1311f91cdd74a2042a8 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858151a06b8c0ff407232d84e695dd73 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#a858151a06b8c0ff407232d84e695dd73">z</a> ()</td></tr>
<tr class="separator:a858151a06b8c0ff407232d84e695dd73 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html">Eigen::DenseCoeffsBase&lt; Derived, ReadOnlyAccessors &gt;</a></td></tr>
<tr class="memitem:af51b00cc45490ad698239ab6a8b94393 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memItemLeft" align="right" valign="top">CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#af51b00cc45490ad698239ab6a8b94393">coeff</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> row, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> col) const</td></tr>
<tr class="separator:af51b00cc45490ad698239ab6a8b94393 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7231d519967c37b4f98002d80756bda inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memItemLeft" align="right" valign="top">CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#aa7231d519967c37b4f98002d80756bda">coeff</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> index) const</td></tr>
<tr class="separator:aa7231d519967c37b4f98002d80756bda inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16145eb95335754c2ff8b2a58731bc53 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#a16145eb95335754c2ff8b2a58731bc53">cols</a> () const</td></tr>
<tr class="separator:a16145eb95335754c2ff8b2a58731bc53 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbabe7f12bcbfba3b9a448b1f5e46fa inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#a1fbabe7f12bcbfba3b9a448b1f5e46fa">derived</a> ()</td></tr>
<tr class="separator:a1fbabe7f12bcbfba3b9a448b1f5e46fa inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4f3f1c57b7594b96a7e30f2974ea2e inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memItemLeft" align="right" valign="top">const Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#afd4f3f1c57b7594b96a7e30f2974ea2e">derived</a> () const</td></tr>
<tr class="separator:afd4f3f1c57b7594b96a7e30f2974ea2e inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3dbba4a15d0fe90185d2900e5ef0fd1 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memItemLeft" align="right" valign="top">CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#ab3dbba4a15d0fe90185d2900e5ef0fd1">operator()</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> row, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> col) const</td></tr>
<tr class="separator:ab3dbba4a15d0fe90185d2900e5ef0fd1 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fadc22d12e48c82745dad534a1671a inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memItemLeft" align="right" valign="top">CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#af9fadc22d12e48c82745dad534a1671a">operator()</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> index) const</td></tr>
<tr class="separator:af9fadc22d12e48c82745dad534a1671a inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496672306836589fa04a6ab33cb0cf2a inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memItemLeft" align="right" valign="top">CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#a496672306836589fa04a6ab33cb0cf2a">operator[]</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> index) const</td></tr>
<tr class="separator:a496672306836589fa04a6ab33cb0cf2a inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75c2d8a783d055db397319c5a330eee inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#ab75c2d8a783d055db397319c5a330eee">rows</a> () const</td></tr>
<tr class="separator:ab75c2d8a783d055db397319c5a330eee inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0d244a512a784ded5319bd1a848440 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#adb0d244a512a784ded5319bd1a848440">size</a> () const</td></tr>
<tr class="separator:adb0d244a512a784ded5319bd1a848440 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926f52a94f038db63c6b9103f98dcf0f inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memItemLeft" align="right" valign="top">CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#a926f52a94f038db63c6b9103f98dcf0f">w</a> () const</td></tr>
<tr class="separator:a926f52a94f038db63c6b9103f98dcf0f inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189c80109e76752b598d60dfcdab329e inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memItemLeft" align="right" valign="top">CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#a189c80109e76752b598d60dfcdab329e">x</a> () const</td></tr>
<tr class="separator:a189c80109e76752b598d60dfcdab329e inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6d6904a37805ce47a3238fbd735963 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memItemLeft" align="right" valign="top">CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#a0c6d6904a37805ce47a3238fbd735963">y</a> () const</td></tr>
<tr class="separator:a0c6d6904a37805ce47a3238fbd735963 inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c60c97282d4a0f8bca16ef75e231ddb inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memItemLeft" align="right" valign="top">CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#a7c60c97282d4a0f8bca16ef75e231ddb">z</a> () const</td></tr>
<tr class="separator:a7c60c97282d4a0f8bca16ef75e231ddb inherit pub_methods_classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structEigen_1_1EigenBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structEigen_1_1EigenBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structEigen_1_1EigenBase.html">Eigen::EigenBase&lt; Derived &gt;</a></td></tr>
<tr class="memitem:a16145eb95335754c2ff8b2a58731bc53 inherit pub_methods_structEigen_1_1EigenBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#a16145eb95335754c2ff8b2a58731bc53">cols</a> () const</td></tr>
<tr class="separator:a16145eb95335754c2ff8b2a58731bc53 inherit pub_methods_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbabe7f12bcbfba3b9a448b1f5e46fa inherit pub_methods_structEigen_1_1EigenBase"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#a1fbabe7f12bcbfba3b9a448b1f5e46fa">derived</a> ()</td></tr>
<tr class="separator:a1fbabe7f12bcbfba3b9a448b1f5e46fa inherit pub_methods_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4f3f1c57b7594b96a7e30f2974ea2e inherit pub_methods_structEigen_1_1EigenBase"><td class="memItemLeft" align="right" valign="top">const Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#afd4f3f1c57b7594b96a7e30f2974ea2e">derived</a> () const</td></tr>
<tr class="separator:afd4f3f1c57b7594b96a7e30f2974ea2e inherit pub_methods_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75c2d8a783d055db397319c5a330eee inherit pub_methods_structEigen_1_1EigenBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#ab75c2d8a783d055db397319c5a330eee">rows</a> () const</td></tr>
<tr class="separator:ab75c2d8a783d055db397319c5a330eee inherit pub_methods_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0d244a512a784ded5319bd1a848440 inherit pub_methods_structEigen_1_1EigenBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#adb0d244a512a784ded5319bd1a848440">size</a> () const</td></tr>
<tr class="separator:adb0d244a512a784ded5319bd1a848440 inherit pub_methods_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a98bb9a0f705c6dfde85b0bfff31bf88f"><td class="memItemLeft" align="right" valign="top">static const IdentityReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">Identity</a> ()</td></tr>
<tr class="separator:a98bb9a0f705c6dfde85b0bfff31bf88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf33ce20ef03ead47cb3dbcd5f416ede"><td class="memItemLeft" align="right" valign="top">static const IdentityReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#acf33ce20ef03ead47cb3dbcd5f416ede">Identity</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#ab75c2d8a783d055db397319c5a330eee">rows</a>, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#a16145eb95335754c2ff8b2a58731bc53">cols</a>)</td></tr>
<tr class="separator:acf33ce20ef03ead47cb3dbcd5f416ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a03a61014f37ddd2fe61ebac0c9539"><td class="memItemLeft" align="right" valign="top">static const BasisReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ac7a03a61014f37ddd2fe61ebac0c9539">Unit</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#adb0d244a512a784ded5319bd1a848440">size</a>, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> i)</td></tr>
<tr class="separator:ac7a03a61014f37ddd2fe61ebac0c9539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9daf6d22d10ed8ae00432b0f641455df"><td class="memItemLeft" align="right" valign="top">static const BasisReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a9daf6d22d10ed8ae00432b0f641455df">Unit</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> i)</td></tr>
<tr class="separator:a9daf6d22d10ed8ae00432b0f641455df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56ba94e5b0330827003eadd26cfadc2"><td class="memItemLeft" align="right" valign="top">static const BasisReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#af56ba94e5b0330827003eadd26cfadc2">UnitW</a> ()</td></tr>
<tr class="separator:af56ba94e5b0330827003eadd26cfadc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a555b7cf626cced54670b98668c4e6d"><td class="memItemLeft" align="right" valign="top">static const BasisReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a8a555b7cf626cced54670b98668c4e6d">UnitX</a> ()</td></tr>
<tr class="separator:a8a555b7cf626cced54670b98668c4e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00850083489e20249b1d05b394fc5efc"><td class="memItemLeft" align="right" valign="top">static const BasisReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a00850083489e20249b1d05b394fc5efc">UnitY</a> ()</td></tr>
<tr class="separator:a00850083489e20249b1d05b394fc5efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabdcdeff1c822a5465fcbe1f78e5afe0"><td class="memItemLeft" align="right" valign="top">static const BasisReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aabdcdeff1c822a5465fcbe1f78e5afe0">UnitZ</a> ()</td></tr>
<tr class="separator:aabdcdeff1c822a5465fcbe1f78e5afe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classEigen_1_1DenseBase"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classEigen_1_1DenseBase')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase&lt; Derived &gt;</a></td></tr>
<tr class="memitem:a68a7ece6c5629d1e9447a321fcb14ccd inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a68a7ece6c5629d1e9447a321fcb14ccd">Constant</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#ab75c2d8a783d055db397319c5a330eee">rows</a>, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#a16145eb95335754c2ff8b2a58731bc53">cols</a>, const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;<a class="el" href="classEigen_1_1DenseBase.html#a8515f719046aa4851e385661f45595b0">value</a>)</td></tr>
<tr class="separator:a68a7ece6c5629d1e9447a321fcb14ccd inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdd3189ae3a41d250593334d82210cf inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a1fdd3189ae3a41d250593334d82210cf">Constant</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#adb0d244a512a784ded5319bd1a848440">size</a>, const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;<a class="el" href="classEigen_1_1DenseBase.html#a8515f719046aa4851e385661f45595b0">value</a>)</td></tr>
<tr class="separator:a1fdd3189ae3a41d250593334d82210cf inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed89b5cc6e3b7d9d5bd63aed245ccd6d inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aed89b5cc6e3b7d9d5bd63aed245ccd6d">Constant</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;<a class="el" href="classEigen_1_1DenseBase.html#a8515f719046aa4851e385661f45595b0">value</a>)</td></tr>
<tr class="separator:aed89b5cc6e3b7d9d5bd63aed245ccd6d inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0dd2c2ee796c50a63126e1e87b55985 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">static const SequentialLinSpacedReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#af0dd2c2ee796c50a63126e1e87b55985">LinSpaced</a> (Sequential_t, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#adb0d244a512a784ded5319bd1a848440">size</a>, const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;low, const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;high)</td></tr>
<tr class="separator:af0dd2c2ee796c50a63126e1e87b55985 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef589c1dbd7fad93f97bd3fa1b1e768 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">static const RandomAccessLinSpacedReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aaef589c1dbd7fad93f97bd3fa1b1e768">LinSpaced</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#adb0d244a512a784ded5319bd1a848440">size</a>, const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;low, const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;high)</td></tr>
<tr class="memdesc:aaef589c1dbd7fad93f97bd3fa1b1e768 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a linearly spaced vector.  <a href="classEigen_1_1DenseBase.html#aaef589c1dbd7fad93f97bd3fa1b1e768">More...</a><br /></td></tr>
<tr class="separator:aaef589c1dbd7fad93f97bd3fa1b1e768 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111ba763100d5c287ab25d1c81342501 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">static const SequentialLinSpacedReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a111ba763100d5c287ab25d1c81342501">LinSpaced</a> (Sequential_t, const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;low, const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;high)</td></tr>
<tr class="separator:a111ba763100d5c287ab25d1c81342501 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8098aa5971139a5585e623dddbea860 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">static const RandomAccessLinSpacedReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ad8098aa5971139a5585e623dddbea860">LinSpaced</a> (const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;low, const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;high)</td></tr>
<tr class="memdesc:ad8098aa5971139a5585e623dddbea860 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a linearly spaced vector.  <a href="classEigen_1_1DenseBase.html#ad8098aa5971139a5585e623dddbea860">More...</a><br /></td></tr>
<tr class="separator:ad8098aa5971139a5585e623dddbea860 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2a51018a73a766f5b91aef3487f013 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a8b2a51018a73a766f5b91aef3487f013">Ones</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#ab75c2d8a783d055db397319c5a330eee">rows</a>, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#a16145eb95335754c2ff8b2a58731bc53">cols</a>)</td></tr>
<tr class="separator:a8b2a51018a73a766f5b91aef3487f013 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab710a58e4a80fbcb2594242372c8fe56 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ab710a58e4a80fbcb2594242372c8fe56">Ones</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#adb0d244a512a784ded5319bd1a848440">size</a>)</td></tr>
<tr class="separator:ab710a58e4a80fbcb2594242372c8fe56 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2755cb4023f7376880523626a8e05101 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a2755cb4023f7376880523626a8e05101">Ones</a> ()</td></tr>
<tr class="separator:a2755cb4023f7376880523626a8e05101 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97f8d9d08f969c733c8144be6225756 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">RandomReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ae97f8d9d08f969c733c8144be6225756">Random</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#ab75c2d8a783d055db397319c5a330eee">rows</a>, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#a16145eb95335754c2ff8b2a58731bc53">cols</a>)</td></tr>
<tr class="separator:ae97f8d9d08f969c733c8144be6225756 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb5f974a8f0b67eac7080db1da0e308 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">RandomReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a7eb5f974a8f0b67eac7080db1da0e308">Random</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#adb0d244a512a784ded5319bd1a848440">size</a>)</td></tr>
<tr class="separator:a7eb5f974a8f0b67eac7080db1da0e308 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae814abb451b48ed872819192dc188c19 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">RandomReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Random</a> ()</td></tr>
<tr class="separator:ae814abb451b48ed872819192dc188c19 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41a9b5050ed27d9e93c82c9c8622cd3 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ae41a9b5050ed27d9e93c82c9c8622cd3">Zero</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#ab75c2d8a783d055db397319c5a330eee">rows</a>, <a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#a16145eb95335754c2ff8b2a58731bc53">cols</a>)</td></tr>
<tr class="separator:ae41a9b5050ed27d9e93c82c9c8622cd3 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22f79b812fa564061042407f2ba8f5b inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ac22f79b812fa564061042407f2ba8f5b">Zero</a> (<a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="structEigen_1_1EigenBase.html#adb0d244a512a784ded5319bd1a848440">size</a>)</td></tr>
<tr class="separator:ac22f79b812fa564061042407f2ba8f5b inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422ddeef58bedc7bddb1d4357688d761 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a422ddeef58bedc7bddb1d4357688d761">Zero</a> ()</td></tr>
<tr class="separator:a422ddeef58bedc7bddb1d4357688d761 inherit pub_static_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8fc2c86eca0e76d5264e285ff4eea079"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8fc2c86eca0e76d5264e285ff4eea079"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_product_op&lt; T, <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;, <a class="el" href="classEigen_1_1DenseBase.html#a68a7ece6c5629d1e9447a321fcb14ccd">Constant</a>&lt; T &gt;, Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a8fc2c86eca0e76d5264e285ff4eea079">operator*</a> (const T &amp;scalar, const StorageBaseType &amp;expr)</td></tr>
<tr class="separator:a8fc2c86eca0e76d5264e285ff4eea079"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classEigen_1_1DenseBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classEigen_1_1DenseBase')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase&lt; Derived &gt;</a></td></tr>
<tr class="memitem:a86241c772c74c04eeeb0480b99c5ab77 inherit pub_types_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="classEigen_1_1DenseBase.html#a86241c772c74c04eeeb0480b99c5ab77adb37c78ebbf15aa20b65c3b70415a1ab">RowsAtCompileTime</a>, 
<br />
&#160;&#160;<a class="el" href="classEigen_1_1DenseBase.html#a86241c772c74c04eeeb0480b99c5ab77a787f85fd67ee5985917eb2cef6e70441">ColsAtCompileTime</a>, 
<br />
&#160;&#160;<a class="el" href="classEigen_1_1DenseBase.html#a86241c772c74c04eeeb0480b99c5ab77a25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a>, 
<br />
&#160;&#160;<a class="el" href="classEigen_1_1DenseBase.html#a86241c772c74c04eeeb0480b99c5ab77ad2baadea085372837b0e80dc93be1306">MaxRowsAtCompileTime</a>, 
<br />
&#160;&#160;<a class="el" href="classEigen_1_1DenseBase.html#a86241c772c74c04eeeb0480b99c5ab77acc3a41000cf1d29dd1a320b2a09d2a65">MaxColsAtCompileTime</a>, 
<br />
&#160;&#160;<a class="el" href="classEigen_1_1DenseBase.html#a86241c772c74c04eeeb0480b99c5ab77a3a459062d39cb34452518f5f201161d2">MaxSizeAtCompileTime</a>, 
<br />
&#160;&#160;<a class="el" href="classEigen_1_1DenseBase.html#a86241c772c74c04eeeb0480b99c5ab77a1156955c8099c5072934b74c72654ed0">IsVectorAtCompileTime</a>, 
<br />
&#160;&#160;<a class="el" href="classEigen_1_1DenseBase.html#a86241c772c74c04eeeb0480b99c5ab77a7392c9b2ad41ba3c16fdc5306c04d581">Flags</a>, 
<br />
&#160;&#160;<a class="el" href="classEigen_1_1DenseBase.html#a86241c772c74c04eeeb0480b99c5ab77a406b6af91d61d348ba1c9764bdd66008">IsRowMajor</a>
<br />
 }</td></tr>
<tr class="separator:a86241c772c74c04eeeb0480b99c5ab77 inherit pub_types_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65328b7d6fc10a26ff6cd5801a6a44eb inherit pub_types_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1Array.html">Array</a>&lt; typename internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>, internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a86241c772c74c04eeeb0480b99c5ab77adb37c78ebbf15aa20b65c3b70415a1ab">RowsAtCompileTime</a>, internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a86241c772c74c04eeeb0480b99c5ab77a787f85fd67ee5985917eb2cef6e70441">ColsAtCompileTime</a>, <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13ad0e7f67d40bcde3d41c12849b16ce6ea">AutoAlign</a>|(internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a86241c772c74c04eeeb0480b99c5ab77a7392c9b2ad41ba3c16fdc5306c04d581">Flags</a> &amp;<a class="el" href="group__flags.html#gae4f56c2a60bbe4bd2e44c5b19cbe8762">RowMajorBit</a> ? <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f">RowMajor</a> :<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62">ColMajor</a>), internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a86241c772c74c04eeeb0480b99c5ab77ad2baadea085372837b0e80dc93be1306">MaxRowsAtCompileTime</a>, internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a86241c772c74c04eeeb0480b99c5ab77acc3a41000cf1d29dd1a320b2a09d2a65">MaxColsAtCompileTime</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a65328b7d6fc10a26ff6cd5801a6a44eb">PlainArray</a></td></tr>
<tr class="separator:a65328b7d6fc10a26ff6cd5801a6a44eb inherit pub_types_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa301ef39d63443e9ef0b84f47350116e inherit pub_types_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; typename internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>, internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a86241c772c74c04eeeb0480b99c5ab77adb37c78ebbf15aa20b65c3b70415a1ab">RowsAtCompileTime</a>, internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a86241c772c74c04eeeb0480b99c5ab77a787f85fd67ee5985917eb2cef6e70441">ColsAtCompileTime</a>, <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13ad0e7f67d40bcde3d41c12849b16ce6ea">AutoAlign</a>|(internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a86241c772c74c04eeeb0480b99c5ab77a7392c9b2ad41ba3c16fdc5306c04d581">Flags</a> &amp;<a class="el" href="group__flags.html#gae4f56c2a60bbe4bd2e44c5b19cbe8762">RowMajorBit</a> ? <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f">RowMajor</a> :<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62">ColMajor</a>), internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a86241c772c74c04eeeb0480b99c5ab77ad2baadea085372837b0e80dc93be1306">MaxRowsAtCompileTime</a>, internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a86241c772c74c04eeeb0480b99c5ab77acc3a41000cf1d29dd1a320b2a09d2a65">MaxColsAtCompileTime</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa301ef39d63443e9ef0b84f47350116e">PlainMatrix</a></td></tr>
<tr class="separator:aa301ef39d63443e9ef0b84f47350116e inherit pub_types_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae45af9b5aca5a9caae98fd201f47cc4 inherit pub_types_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">typedef internal::conditional&lt; internal::is_same&lt; typename internal::traits&lt; Derived &gt;::XprKind, <a class="el" href="structEigen_1_1MatrixXpr.html">MatrixXpr</a> &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a8515f719046aa4851e385661f45595b0">value</a>, <a class="el" href="classEigen_1_1DenseBase.html#aa301ef39d63443e9ef0b84f47350116e">PlainMatrix</a>, <a class="el" href="classEigen_1_1DenseBase.html#a65328b7d6fc10a26ff6cd5801a6a44eb">PlainArray</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a></td></tr>
<tr class="memdesc:aae45af9b5aca5a9caae98fd201f47cc4 inherit pub_types_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The plain matrix or array type corresponding to this expression.  <a href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">More...</a><br /></td></tr>
<tr class="separator:aae45af9b5aca5a9caae98fd201f47cc4 inherit pub_types_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5feed465b3a8e60c47e73ecce83e39a2 inherit pub_types_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">typedef internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a></td></tr>
<tr class="separator:a5feed465b3a8e60c47e73ecce83e39a2 inherit pub_types_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1aba3f6c414715d830f760913c7e00 inherit pub_types_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">typedef internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a2d1aba3f6c414715d830f760913c7e00">StorageIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a2d1aba3f6c414715d830f760913c7e00">StorageIndex</a></td></tr>
<tr class="memdesc:a2d1aba3f6c414715d830f760913c7e00 inherit pub_types_classEigen_1_1DenseBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to store indices.  <a href="classEigen_1_1DenseBase.html#a2d1aba3f6c414715d830f760913c7e00">More...</a><br /></td></tr>
<tr class="separator:a2d1aba3f6c414715d830f760913c7e00 inherit pub_types_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9276182dab8236c33f1e7abf491d504d inherit pub_types_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a9276182dab8236c33f1e7abf491d504d">value_type</a></td></tr>
<tr class="separator:a9276182dab8236c33f1e7abf491d504d inherit pub_types_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structEigen_1_1EigenBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structEigen_1_1EigenBase')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="structEigen_1_1EigenBase.html">Eigen::EigenBase&lt; Derived &gt;</a></td></tr>
<tr class="memitem:a554f30542cc2316add4b1ea0a492ff02 inherit pub_types_structEigen_1_1EigenBase"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a></td></tr>
<tr class="memdesc:a554f30542cc2316add4b1ea0a492ff02 inherit pub_types_structEigen_1_1EigenBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The interface type of indices.  <a href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">More...</a><br /></td></tr>
<tr class="separator:a554f30542cc2316add4b1ea0a492ff02 inherit pub_types_structEigen_1_1EigenBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classEigen_1_1DenseBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classEigen_1_1DenseBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase&lt; Derived &gt;</a></td></tr>
<tr class="memitem:aa284042d0e1b0ad9b6a00db7fd2d9f7f inherit pro_methods_classEigen_1_1DenseBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa284042d0e1b0ad9b6a00db7fd2d9f7f">DenseBase</a> ()</td></tr>
<tr class="separator:aa284042d0e1b0ad9b6a00db7fd2d9f7f inherit pro_methods_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_classEigen_1_1DenseBase"><td colspan="2" onclick="javascript:toggleInherit('related_classEigen_1_1DenseBase')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classEigen_1_1DenseBase.html">Eigen::DenseBase&lt; Derived &gt;</a></td></tr>
<tr class="memitem:a3806d3f42de165878dace160e6aba40a inherit related_classEigen_1_1DenseBase"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a3806d3f42de165878dace160e6aba40a inherit related_classEigen_1_1DenseBase"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a3806d3f42de165878dace160e6aba40a">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt; &amp;m)</td></tr>
<tr class="separator:a3806d3f42de165878dace160e6aba40a inherit related_classEigen_1_1DenseBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afacca1f88da57e5cd87dd07c8ff926bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afacca1f88da57e5cd87dd07c8ff926bb">&#9670;&nbsp;</a></span>adjoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::AdjointReturnType <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::adjoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the adjoint (i.e. conjugate transpose) of *this.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga72a19eccc523e6a3be2d2f6d5eb3e8f9">Matrix2cf</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix2cf::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the 2x2 complex matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the adjoint of m:&quot;</span> &lt;&lt; endl &lt;&lt; m.adjoint() &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the 2x2 complex matrix m:
 (-0.211,0.68) (-0.605,0.823)
 (0.597,0.566)  (0.536,-0.33)
Here is the adjoint of m:
 (-0.211,-0.68)  (0.597,-0.566)
(-0.605,-0.823)    (0.536,0.33)
</pre><dl class="section warning"><dt>Warning</dt><dd>If you want to replace a matrix by its own adjoint, do <b>NOT</b> do this: <div class="fragment"><div class="line">m = m.adjoint(); <span class="comment">// bug!!! caused by aliasing effect</span></div></div><!-- fragment --> Instead, use the <a class="el" href="classEigen_1_1MatrixBase.html#a51c5982c1f64e45a939515b701fa6f4a">adjointInPlace()</a> method: <div class="fragment"><div class="line">m.adjointInPlace();</div></div><!-- fragment --> which gives <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library. ">Eigen</a> good opportunities for optimization, or alternatively you can also do: <div class="fragment"><div class="line">m = m.adjoint().eval();</div></div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a51c5982c1f64e45a939515b701fa6f4a">adjointInPlace()</a>, <a class="el" href="classEigen_1_1DenseBase.html#ac8952c19644a4ac7e41bea45c19b909c">transpose()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a07794fba1534fa85baa54b84cb45ce10" title="  ">conjugate()</a>, class <a class="el" href="classEigen_1_1Transpose.html" title="Expression of the transpose of a matrix. ">Transpose</a>, class internal::scalar_conjugate_op </dd></dl>

</div>
</div>
<a id="a51c5982c1f64e45a939515b701fa6f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c5982c1f64e45a939515b701fa6f4a">&#9670;&nbsp;</a></span>adjointInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::adjointInPlace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the "in place" version of <a class="el" href="classEigen_1_1MatrixBase.html#afacca1f88da57e5cd87dd07c8ff926bb">adjoint()</a>: it replaces <code>*this</code> by its own transpose. Thus, doing </p><div class="fragment"><div class="line">m.adjointInPlace();</div></div><!-- fragment --><p> has the same effect on m as doing </p><div class="fragment"><div class="line">m = m.adjoint().eval();</div></div><!-- fragment --><p> and is faster and also safer because in the latter line of code, forgetting the <a class="el" href="classEigen_1_1DenseBase.html#aa73e57a2f0f7cfcb4ad4d55ea0b6414b">eval()</a> results in a bug caused by aliasing.</p>
<p>Notice however that this method is only useful if you want to replace a matrix by its own adjoint. If you just need the adjoint of a matrix, use <a class="el" href="classEigen_1_1MatrixBase.html#afacca1f88da57e5cd87dd07c8ff926bb">adjoint()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>if the matrix is not square, then <code>*this</code> must be a resizable matrix. This excludes (non-square) fixed-size matrices, block-expressions and maps.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#ac8952c19644a4ac7e41bea45c19b909c">transpose()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#afacca1f88da57e5cd87dd07c8ff926bb">adjoint()</a>, <a class="el" href="classEigen_1_1DenseBase.html#ac501bd942994af7a95d95bee7a16ad2a">transposeInPlace()</a> </dd></dl>

</div>
</div>
<a id="a8f2c8059ef3f04cfa0c73b4c012db855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2c8059ef3f04cfa0c73b4c012db855">&#9670;&nbsp;</a></span>applyHouseholderOnTheLeft()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename EssentialPart &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::applyHouseholderOnTheLeft </td>
          <td>(</td>
          <td class="paramtype">const EssentialPart &amp;&#160;</td>
          <td class="paramname"><em>essential</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> *&#160;</td>
          <td class="paramname"><em>workspace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply the elementary reflector H given by <img class="formulaInl" alt="$ H = I - tau v v^*$" src="form_132.png"/> with <img class="formulaInl" alt="$ v^T = [1 essential^T] $" src="form_133.png"/> from the left to a vector or matrix.</p>
<p>On input: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">essential</td><td>the essential part of the vector <code>v</code> </td></tr>
    <tr><td class="paramname">tau</td><td>the scaling factor of the Householder transformation </td></tr>
    <tr><td class="paramname">workspace</td><td>a pointer to working space with at least this-&gt;<a class="el" href="structEigen_1_1EigenBase.html#a16145eb95335754c2ff8b2a58731bc53">cols()</a> * essential.size() entries</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a13291e900f7e81ddc6e5b8802f82092b">MatrixBase::makeHouseholder()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#aebf4bac7dffe2685ab93734fb776e817">MatrixBase::makeHouseholderInPlace()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#ab3e52262b41fa40e194dda245e0f9675">MatrixBase::applyHouseholderOnTheRight()</a> </dd></dl>

</div>
</div>
<a id="ab3e52262b41fa40e194dda245e0f9675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e52262b41fa40e194dda245e0f9675">&#9670;&nbsp;</a></span>applyHouseholderOnTheRight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename EssentialPart &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::applyHouseholderOnTheRight </td>
          <td>(</td>
          <td class="paramtype">const EssentialPart &amp;&#160;</td>
          <td class="paramname"><em>essential</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> *&#160;</td>
          <td class="paramname"><em>workspace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply the elementary reflector H given by <img class="formulaInl" alt="$ H = I - tau v v^*$" src="form_132.png"/> with <img class="formulaInl" alt="$ v^T = [1 essential^T] $" src="form_133.png"/> from the right to a vector or matrix.</p>
<p>On input: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">essential</td><td>the essential part of the vector <code>v</code> </td></tr>
    <tr><td class="paramname">tau</td><td>the scaling factor of the Householder transformation </td></tr>
    <tr><td class="paramname">workspace</td><td>a pointer to working space with at least this-&gt;<a class="el" href="structEigen_1_1EigenBase.html#a16145eb95335754c2ff8b2a58731bc53">cols()</a> * essential.size() entries</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a13291e900f7e81ddc6e5b8802f82092b">MatrixBase::makeHouseholder()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#aebf4bac7dffe2685ab93734fb776e817">MatrixBase::makeHouseholderInPlace()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a8f2c8059ef3f04cfa0c73b4c012db855">MatrixBase::applyHouseholderOnTheLeft()</a> </dd></dl>

</div>
</div>
<a id="a3a08ad41e81d8ad4a37b5d5c7490e765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a08ad41e81d8ad4a37b5d5c7490e765">&#9670;&nbsp;</a></span>applyOnTheLeft() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::applyOnTheLeft </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>replaces <code>*this</code> by <em>other</em> * <code>*this</code>.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga276bae130c142e906ad8f47d24d11c1c">Matrix3f</a> A = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3f::Random</a>(3,3), B;</div><div class="line">B &lt;&lt; 0,1,0,  </div><div class="line">     0,0,1,  </div><div class="line">     1,0,0;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;At start, A = &quot;</span> &lt;&lt; endl &lt;&lt; A &lt;&lt; endl;</div><div class="line">A.applyOnTheLeft(B); </div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;After applyOnTheLeft, A = &quot;</span> &lt;&lt; endl &lt;&lt; A &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">At start, A = 
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
After applyOnTheLeft, A = 
-0.211  0.823  0.536
 0.566 -0.605 -0.444
  0.68  0.597  -0.33
</pre> 
</div>
</div>
<a id="ae669131f6e18f7e8f06fae271754f435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae669131f6e18f7e8f06fae271754f435">&#9670;&nbsp;</a></span>applyOnTheLeft() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherScalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::applyOnTheLeft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1JacobiRotation.html">JacobiRotation</a>&lt; OtherScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is defined in the Jacobi module.</p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Jacobi&gt;</span> </div></div><!-- fragment --><p> Applies the rotation in the plane <em>j</em> to the rows <em>p</em> and <em>q</em> of <code>*this</code>, i.e., it computes B = J * B, with <img class="formulaInl" alt="$ B = \left ( \begin{array}{cc} \text{*this.row}(p) \\ \text{*this.row}(q) \end{array} \right ) $" src="form_159.png"/>.</p>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1JacobiRotation.html" title="Rotation given by a cosine-sine pair. ">JacobiRotation</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a45d91752925d2757fc8058a293b15462">MatrixBase::applyOnTheRight()</a>, internal::apply_rotation_in_the_plane() </dd></dl>

</div>
</div>
<a id="a45d91752925d2757fc8058a293b15462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d91752925d2757fc8058a293b15462">&#9670;&nbsp;</a></span>applyOnTheRight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::applyOnTheRight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>replaces <code>*this</code> by <code>*this</code> * <em>other</em>. It is equivalent to <a class="el" href="classEigen_1_1MatrixBase.html#a3783b6168995ca117a1c19fea3630ac4">MatrixBase::operator*=()</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga276bae130c142e906ad8f47d24d11c1c">Matrix3f</a> A = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3f::Random</a>(3,3), B;</div><div class="line">B &lt;&lt; 0,1,0,  </div><div class="line">     0,0,1,  </div><div class="line">     1,0,0;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;At start, A = &quot;</span> &lt;&lt; endl &lt;&lt; A &lt;&lt; endl;</div><div class="line">A *= B;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;After A *= B, A = &quot;</span> &lt;&lt; endl &lt;&lt; A &lt;&lt; endl;</div><div class="line">A.applyOnTheRight(B);  <span class="comment">// equivalent to A *= B</span></div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;After applyOnTheRight, A = &quot;</span> &lt;&lt; endl &lt;&lt; A &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">At start, A = 
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
After A *= B, A = 
 -0.33   0.68  0.597
 0.536 -0.211  0.823
-0.444  0.566 -0.605
After applyOnTheRight, A = 
 0.597  -0.33   0.68
 0.823  0.536 -0.211
-0.605 -0.444  0.566
</pre> 
</div>
</div>
<a id="a354c33eec32ceb4193d002f4d41c0497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354c33eec32ceb4193d002f4d41c0497">&#9670;&nbsp;</a></span>array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1ArrayWrapper.html">ArrayWrapper</a>&lt;Derived&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classEigen_1_1ArrayBase.html">Array </a> expression of this matrix </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1ArrayBase.html#af01e9ea8087e390af8af453bbe4c276c">ArrayBase::matrix()</a> </dd></dl>

</div>
</div>
<a id="a72f287fe7b2a7e7a66d16cc88166d47f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f287fe7b2a7e7a66d16cc88166d47f">&#9670;&nbsp;</a></span>array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1ArrayWrapper.html">ArrayWrapper</a>&lt;const Derived&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const <a class="el" href="classEigen_1_1ArrayBase.html">Array </a> expression of this matrix </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1ArrayBase.html#af01e9ea8087e390af8af453bbe4c276c">ArrayBase::matrix()</a> </dd></dl>

</div>
</div>
<a id="a14235b62c90f93fe910070b4743782d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14235b62c90f93fe910070b4743782d0">&#9670;&nbsp;</a></span>asDiagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DiagonalWrapper.html">DiagonalWrapper</a>&lt; const Derived &gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::asDiagonal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pseudo-expression of a diagonal matrix with *this as vector of diagonal coefficients</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>Example: </p><div class="fragment"><div class="line">cout &lt;&lt; <a class="code" href="group__matrixtypedefs.html#gaf5dfa8fd62427c5f3c8035daf15ebfcb">Matrix3i</a>(<a class="code" href="group__matrixtypedefs.html#ga837c23269fa22059fbfdca6c653bcc1e">Vector3i</a>(2,5,6).<a class="code" href="classEigen_1_1MatrixBase.html#a14235b62c90f93fe910070b4743782d0">asDiagonal</a>()) &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">2 0 0
0 5 0
0 0 6
</pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1DiagonalWrapper.html" title="Expression of a diagonal matrix. ">DiagonalWrapper</a>, class <a class="el" href="classEigen_1_1DiagonalMatrix.html" title="Represents a diagonal matrix with its storage. ">DiagonalMatrix</a>, <a class="el" href="classEigen_1_1MatrixBase.html#ab5768147536273eb2dbdfa389cfd26a3">diagonal()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a97027ea54c8cd1ddb1c578fee5cedc67">isDiagonal()</a> </dd></dl>

</div>
</div>
<a id="ae171b74b5d530846ee0836135ffcf837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae171b74b5d530846ee0836135ffcf837">&#9670;&nbsp;</a></span>bdcSvd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1BDCSVD.html">BDCSVD</a>&lt; typename <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::bdcSvd </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>computationOptions</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is defined in the SVD module.</p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/SVD&gt;</span> </div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>the singular value decomposition of <code>*this</code> computed by Divide &amp; Conquer algorithm</dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1BDCSVD.html" title="class Bidiagonal Divide and Conquer SVD ">BDCSVD</a> </dd></dl>

</div>
</div>
<a id="a1063a3752d30b568e52c89ce4e567489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1063a3752d30b568e52c89ce4e567489">&#9670;&nbsp;</a></span>binaryExpr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename CustomBinaryOp , typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;CustomBinaryOp, const Derived, const OtherDerived&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::binaryExpr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CustomBinaryOp &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code>CustomBinaryOp()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a custom coefficient-wise operator <em>func</em> of *this and <em>other</em> </dd></dl>
<p>The template parameter <em>CustomBinaryOp</em> is the type of the functor of the custom operator (see class <a class="el" href="classEigen_1_1CwiseBinaryOp.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions. ">CwiseBinaryOp</a> for an example)</p>
<p>Here is an example illustrating the use of custom functors: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"></div><div class="line"><span class="comment">// define a custom template binary functor</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Scalar&gt; <span class="keyword">struct </span>MakeComplexOp {</div><div class="line">  EIGEN_EMPTY_STRUCT_CTOR(MakeComplexOp)</div><div class="line">  <span class="keyword">typedef</span> complex&lt;Scalar&gt; result_type;</div><div class="line">  complex&lt;Scalar&gt; <a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#ae6ba07bad9e3026afe54806fdefe32bb">operator()</a>(<span class="keyword">const</span> <a class="code" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&amp; a, <span class="keyword">const</span> <a class="code" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&amp; b)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> complex&lt;Scalar&gt;(a,b); }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">  <a class="code" href="classEigen_1_1Matrix.html">Matrix4d</a> m1 = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4d::Random</a>(), m2 = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4d::Random</a>();</div><div class="line">  cout &lt;&lt; m1.<a class="code" href="classEigen_1_1MatrixBase.html#a1063a3752d30b568e52c89ce4e567489">binaryExpr</a>(m2, MakeComplexOp&lt;double&gt;()) &lt;&lt; endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> Output: </p><pre class="fragment">   (0.68,0.271)  (0.823,-0.967) (-0.444,-0.687)   (-0.27,0.998)
 (-0.211,0.435) (-0.605,-0.514)  (0.108,-0.198) (0.0268,-0.563)
 (0.566,-0.717)  (-0.33,-0.726) (-0.0452,-0.74)  (0.904,0.0259)
  (0.597,0.214)   (0.536,0.608)  (0.258,-0.782)   (0.832,0.678)
</pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseBinaryOp.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions. ">CwiseBinaryOp</a>, <a class="el" href="classEigen_1_1MatrixBase.html#acc4d02dad6db83c4235dafbaaebe140f">operator+()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a5c2e247775438bfa1ff6dbacc5963efe">operator-()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a28d9b053ae69eb1073030dc1a39a4c2f">cwiseProduct()</a> </dd></dl>

</div>
</div>
<a id="a3f3faa00163c16824ff03e58a210c74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3faa00163c16824ff03e58a210c74c">&#9670;&nbsp;</a></span>blueNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; typename internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::Real <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::blueNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <em>l2</em> norm of <code>*this</code> using the Blue's algorithm. A Portable Fortran Program to Find the Euclidean Norm of a Vector, ACM TOMS, Vol 4, Issue 1, 1978.</dd></dl>
<p>For architecture/scalar types without vectorization, this version is much faster than <a class="el" href="classEigen_1_1MatrixBase.html#ab84d3e64f855813b1eea4202c0697dc1">stableNorm()</a>. Otherwise the <a class="el" href="classEigen_1_1MatrixBase.html#ab84d3e64f855813b1eea4202c0697dc1">stableNorm()</a> is faster.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a196c4ec3c8ffdf5bda45d0f617154975">norm()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#ab84d3e64f855813b1eea4202c0697dc1">stableNorm()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a32222d3b6677e6cdf0b801463f329b72">hypotNorm()</a> </dd></dl>

</div>
</div>
<a id="ab2ced8ab26cd4c468dea52dacbefa1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ced8ab26cd4c468dea52dacbefa1bc">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename NewType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CastXpr&lt;NewType&gt;::Type <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of <code>*this</code> with the <em>Scalar</em> type casted to <em>NewScalar</em>.</dd></dl>
<p>The template parameter <em>NewScalar</em> is the type we are casting the scalars to. </p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseUnaryOp.html" title="Generic expression where a coefficient-wise unary operator is applied to an expression. ">CwiseUnaryOp</a> </dd></dl>

</div>
</div>
<a id="adee8c19c833245bbb00a591dce68e8a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee8c19c833245bbb00a591dce68e8a4">&#9670;&nbsp;</a></span>colPivHouseholderQr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1ColPivHouseholderQR.html">ColPivHouseholderQR</a>&lt; typename <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::colPivHouseholderQr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the column-pivoting Householder QR decomposition of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1ColPivHouseholderQR.html" title="Householder rank-revealing QR decomposition of a matrix with column-pivoting. ">ColPivHouseholderQR</a> </dd></dl>

</div>
</div>
<a id="ae90b6846f05bd30b8d52b66e427e3e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90b6846f05bd30b8d52b66e427e3e09">&#9670;&nbsp;</a></span>completeOrthogonalDecomposition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CompleteOrthogonalDecomposition.html">CompleteOrthogonalDecomposition</a>&lt; typename <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::completeOrthogonalDecomposition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the complete orthogonal decomposition of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CompleteOrthogonalDecomposition.html" title="Complete orthogonal decomposition (COD) of a matrix. ">CompleteOrthogonalDecomposition</a> </dd></dl>

</div>
</div>
<a id="a7baaf2fdec0191a2166cf9fd84a2dcb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7baaf2fdec0191a2166cf9fd84a2dcb2">&#9670;&nbsp;</a></span>computeInverseAndDetWithCheck()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename ResultType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::computeInverseAndDetWithCheck </td>
          <td>(</td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>inverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ResultType::Scalar &amp;&#160;</td>
          <td class="paramname"><em>determinant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>invertible</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>absDeterminantThreshold</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is defined in the LU module.</p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/LU&gt;</span> </div></div><!-- fragment --><p>Computation of matrix inverse and determinant, with invertibility check.</p>
<p>This is only for fixed-size square matrices of size up to 4x4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inverse</td><td>Reference to the matrix in which to store the inverse. </td></tr>
    <tr><td class="paramname">determinant</td><td>Reference to the variable in which to store the determinant. </td></tr>
    <tr><td class="paramname">invertible</td><td>Reference to the bool variable in which to store whether the matrix is invertible. </td></tr>
    <tr><td class="paramname">absDeterminantThreshold</td><td>Optional parameter controlling the invertibility check. The matrix will be declared invertible if the absolute value of its determinant is greater than this threshold.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga84e9fd068879d808012bb6d5dbfecb17">Matrix3d</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line"><a class="code" href="group__matrixtypedefs.html#ga84e9fd068879d808012bb6d5dbfecb17">Matrix3d</a> <a class="code" href="classEigen_1_1MatrixBase.html#a7712eb69e8ea3c8f7b8da1c44dbdeebf">inverse</a>;</div><div class="line"><span class="keywordtype">bool</span> invertible;</div><div class="line"><span class="keywordtype">double</span> <a class="code" href="classEigen_1_1MatrixBase.html#a7ad8f77004bb956b603bb43fd2e3c061">determinant</a>;</div><div class="line">m.computeInverseAndDetWithCheck(<a class="code" href="classEigen_1_1MatrixBase.html#a7712eb69e8ea3c8f7b8da1c44dbdeebf">inverse</a>,<a class="code" href="classEigen_1_1MatrixBase.html#a7ad8f77004bb956b603bb43fd2e3c061">determinant</a>,invertible);</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Its determinant is &quot;</span> &lt;&lt; <a class="code" href="classEigen_1_1MatrixBase.html#a7ad8f77004bb956b603bb43fd2e3c061">determinant</a> &lt;&lt; endl;</div><div class="line"><span class="keywordflow">if</span>(invertible) {</div><div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;It is invertible, and its inverse is:&quot;</span> &lt;&lt; endl &lt;&lt; <a class="code" href="classEigen_1_1MatrixBase.html#a7712eb69e8ea3c8f7b8da1c44dbdeebf">inverse</a> &lt;&lt; endl;</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> {</div><div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;It is not invertible.&quot;</span> &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Its determinant is 0.209
It is invertible, and its inverse is:
-0.199   2.23   2.84
  1.01 -0.555  -1.42
 -1.62   3.59   3.29
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a7712eb69e8ea3c8f7b8da1c44dbdeebf">inverse()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a116f3b50d2af7dbdf7473e517a5b8b0f">computeInverseWithCheck()</a> </dd></dl>

</div>
</div>
<a id="a116f3b50d2af7dbdf7473e517a5b8b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116f3b50d2af7dbdf7473e517a5b8b0f">&#9670;&nbsp;</a></span>computeInverseWithCheck()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename ResultType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::computeInverseWithCheck </td>
          <td>(</td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>inverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>invertible</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>absDeterminantThreshold</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is defined in the LU module.</p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/LU&gt;</span> </div></div><!-- fragment --><p>Computation of matrix inverse, with invertibility check.</p>
<p>This is only for fixed-size square matrices of size up to 4x4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inverse</td><td>Reference to the matrix in which to store the inverse. </td></tr>
    <tr><td class="paramname">invertible</td><td>Reference to the bool variable in which to store whether the matrix is invertible. </td></tr>
    <tr><td class="paramname">absDeterminantThreshold</td><td>Optional parameter controlling the invertibility check. The matrix will be declared invertible if the absolute value of its determinant is greater than this threshold.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga84e9fd068879d808012bb6d5dbfecb17">Matrix3d</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line"><a class="code" href="group__matrixtypedefs.html#ga84e9fd068879d808012bb6d5dbfecb17">Matrix3d</a> <a class="code" href="classEigen_1_1MatrixBase.html#a7712eb69e8ea3c8f7b8da1c44dbdeebf">inverse</a>;</div><div class="line"><span class="keywordtype">bool</span> invertible;</div><div class="line">m.computeInverseWithCheck(<a class="code" href="classEigen_1_1MatrixBase.html#a7712eb69e8ea3c8f7b8da1c44dbdeebf">inverse</a>,invertible);</div><div class="line"><span class="keywordflow">if</span>(invertible) {</div><div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;It is invertible, and its inverse is:&quot;</span> &lt;&lt; endl &lt;&lt; <a class="code" href="classEigen_1_1MatrixBase.html#a7712eb69e8ea3c8f7b8da1c44dbdeebf">inverse</a> &lt;&lt; endl;</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> {</div><div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;It is not invertible.&quot;</span> &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
It is invertible, and its inverse is:
-0.199   2.23   2.84
  1.01 -0.555  -1.42
 -1.62   3.59   3.29
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a7712eb69e8ea3c8f7b8da1c44dbdeebf">inverse()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a7baaf2fdec0191a2166cf9fd84a2dcb2">computeInverseAndDetWithCheck()</a> </dd></dl>

</div>
</div>
<a id="a07794fba1534fa85baa54b84cb45ce10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07794fba1534fa85baa54b84cb45ce10">&#9670;&nbsp;</a></span>conjugate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConjugateReturnType <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::conjugate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><br />
 </p>
<dl class="section return"><dt>Returns</dt><dd>an expression of the complex conjugate of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="group__CoeffwiseMathFunctions.html#cwisetable_conj">Math functions</a>, <a class="el" href="classEigen_1_1MatrixBase.html#afacca1f88da57e5cd87dd07c8ff926bb">MatrixBase::adjoint()</a> </dd></dl>

</div>
</div>
<a id="a34d626eb756bbeb4069d1eb0e6494c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d626eb756bbeb4069d1eb0e6494c65">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const MatrixFunctionReturnValue&lt;Derived&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function requires the <a href="unsupported/group__MatrixFunctions__Module.html">unsupported MatrixFunctions module</a>. To compute the coefficient-wise cosine use <a class="el" href="classEigen_1_1ArrayBase.html#a02c07fce456a1a6ec9510ca8b0934911">ArrayBase::cos</a> . </p>
<dl class="section return"><dt>Returns</dt><dd>an expression of the matrix cosine of <code>*this</code>. </dd></dl>

</div>
</div>
<a id="a627e6f11bf5854ade9a5abfc344c0367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627e6f11bf5854ade9a5abfc344c0367">&#9670;&nbsp;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const MatrixFunctionReturnValue&lt;Derived&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cosh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function requires the <a href="unsupported/group__MatrixFunctions__Module.html">unsupported MatrixFunctions module</a>. To compute the coefficient-wise hyperbolic cosine use <a class="el" href="classEigen_1_1ArrayBase.html#a3f34a09fc1a72fd2dc6b5fafb857fcb8">ArrayBase::cosh</a> . </p>
<dl class="section return"><dt>Returns</dt><dd>an expression of the matrix hyperbolic cosine of <code>*this</code>. </dd></dl>

</div>
</div>
<a id="ae04b39cbc74f2e12e3609df7117b0394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04b39cbc74f2e12e3609df7117b0394">&#9670;&nbsp;</a></span>cwiseAbs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseAbsReturnType</a> <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseAbs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise absolute value of <code>*this</code> </dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga99b41a69f0bf64eadb63a97f357ab412">MatrixXd</a> m(2,3);</div><div class="line">m &lt;&lt; 2, -4, 6,   </div><div class="line">     -5, 1, 0;</div><div class="line">cout &lt;&lt; m.cwiseAbs() &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">2 4 6
5 1 0
</pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#aa0147ae59510af37efc4b8f79358324b">cwiseAbs2()</a> </dd></dl>

</div>
</div>
<a id="aa0147ae59510af37efc4b8f79358324b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0147ae59510af37efc4b8f79358324b">&#9670;&nbsp;</a></span>cwiseAbs2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseAbs2ReturnType</a> <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseAbs2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise squared absolute value of <code>*this</code> </dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga99b41a69f0bf64eadb63a97f357ab412">MatrixXd</a> m(2,3);</div><div class="line">m &lt;&lt; 2, -4, 6,   </div><div class="line">     -5, 1, 0;</div><div class="line">cout &lt;&lt; m.cwiseAbs2() &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment"> 4 16 36
25  1  0
</pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ae04b39cbc74f2e12e3609df7117b0394">cwiseAbs()</a> </dd></dl>

</div>
</div>
<a id="a8cc51452067ce6730d1f68e524958638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc51452067ce6730d1f68e524958638">&#9670;&nbsp;</a></span>cwiseEqual() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;std::equal_to&lt;<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;, const Derived, const OtherDerived&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise == operator of *this and <em>other</em> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this performs an exact comparison, which is generally a bad idea with floating-point types. In order to check for equality between two vectors or matrices with floating-point coefficients, it is generally a far better idea to use a fuzzy comparison as provided by <a class="el" href="classEigen_1_1DenseBase.html#ae8443357b808cd393be1b51974213f9c">isApprox()</a> and isMuchSmallerThan().</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gaceba5f63d4040c79c44109590d4fa606">MatrixXi</a> m(2,2);</div><div class="line">m &lt;&lt; 1, 0,</div><div class="line">     1, 1;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Comparing m with identity matrix:&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; m.cwiseEqual(<a class="code" href="classEigen_1_1MatrixBase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">MatrixXi::Identity</a>(2,2)) &lt;&lt; endl;</div><div class="line"><a class="code" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="code" href="classEigen_1_1DenseBase.html#a229be090c665b9bf7d1fcdfd1ab6e0c1">count</a> = m.cwiseEqual(<a class="code" href="classEigen_1_1MatrixBase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">MatrixXi::Identity</a>(2,2)).count();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Number of coefficients that are equal: &quot;</span> &lt;&lt; <a class="code" href="classEigen_1_1DenseBase.html#a229be090c665b9bf7d1fcdfd1ab6e0c1">count</a> &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Comparing m with identity matrix:
1 1
0 1
Number of coefficients that are equal: 3
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#adeb982322a8a68b3ee9eb9d4e7bae468">cwiseNotEqual()</a>, <a class="el" href="classEigen_1_1DenseBase.html#ae8443357b808cd393be1b51974213f9c">isApprox()</a>, isMuchSmallerThan() </dd></dl>

</div>
</div>
<a id="a709120e3c6fd81be98e3735856564f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a709120e3c6fd81be98e3735856564f30">&#9670;&nbsp;</a></span>cwiseEqual() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseScalarEqualReturnType</a> <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise == operator of <code>*this</code> and a scalar <em>s</em> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this performs an exact comparison, which is generally a bad idea with floating-point types. In order to check for equality between two vectors or matrices with floating-point coefficients, it is generally a far better idea to use a fuzzy comparison as provided by <a class="el" href="classEigen_1_1DenseBase.html#ae8443357b808cd393be1b51974213f9c">isApprox()</a> and isMuchSmallerThan().</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a8cc51452067ce6730d1f68e524958638">cwiseEqual(const MatrixBase&lt;OtherDerived&gt; &amp;) const</a> </dd></dl>

</div>
</div>
<a id="a44b11744885ab2680da4093ba0b6cbf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b11744885ab2680da4093ba0b6cbf6">&#9670;&nbsp;</a></span>cwiseInverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseInverseReturnType</a> <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseInverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise inverse of *this.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga99b41a69f0bf64eadb63a97f357ab412">MatrixXd</a> m(2,3);</div><div class="line">m &lt;&lt; 2, 0.5, 1,   </div><div class="line">     3, 0.25, 1;</div><div class="line">cout &lt;&lt; m.cwiseInverse() &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">  0.5     2     1
0.333     4     1
</pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a28d9b053ae69eb1073030dc1a39a4c2f">cwiseProduct()</a> </dd></dl>

</div>
</div>
<a id="a4b143895b204800f62743554c297c740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b143895b204800f62743554c297c740">&#9670;&nbsp;</a></span>cwiseMax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_max_op&lt;<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>,<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;, const Derived, const OtherDerived&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise max of *this and <em>other</em> </dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gaabb0b4639dc0b48e691e02e95873b0f1">Vector3d</a> v(2,3,4), <a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af683e04b3926aaf4091581ca24ca09ad">w</a>(4,2,3);</div><div class="line">cout &lt;&lt; v.cwiseMax(<a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af683e04b3926aaf4091581ca24ca09ad">w</a>) &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">4
3
4
</pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseBinaryOp.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions. ">CwiseBinaryOp</a>, min() </dd></dl>

</div>
</div>
<a id="ac78c95906920a6dcb53f8bd04e4adf85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78c95906920a6dcb53f8bd04e4adf85">&#9670;&nbsp;</a></span>cwiseMax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_max_op&lt;<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>,<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;, const Derived, const ConstantReturnType&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise max of *this and scalar <em>other</em> </dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseBinaryOp.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions. ">CwiseBinaryOp</a>, min() </dd></dl>

</div>
</div>
<a id="a964630f64e1c91a3c5c7418467e89ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964630f64e1c91a3c5c7418467e89ab5">&#9670;&nbsp;</a></span>cwiseMin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_min_op&lt;<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>,<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;, const Derived, const OtherDerived&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseMin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise min of *this and <em>other</em> </dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gaabb0b4639dc0b48e691e02e95873b0f1">Vector3d</a> v(2,3,4), <a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af683e04b3926aaf4091581ca24ca09ad">w</a>(4,2,3);</div><div class="line">cout &lt;&lt; v.cwiseMin(<a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af683e04b3926aaf4091581ca24ca09ad">w</a>) &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">2
2
3
</pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseBinaryOp.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions. ">CwiseBinaryOp</a>, max() </dd></dl>

</div>
</div>
<a id="aa5c3a077f1e50b351ca567219c17769c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c3a077f1e50b351ca567219c17769c">&#9670;&nbsp;</a></span>cwiseMin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_min_op&lt;<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>,<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;, const Derived, const ConstantReturnType&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseMin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise min of *this and scalar <em>other</em> </dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseBinaryOp.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions. ">CwiseBinaryOp</a>, min() </dd></dl>

</div>
</div>
<a id="adeb982322a8a68b3ee9eb9d4e7bae468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb982322a8a68b3ee9eb9d4e7bae468">&#9670;&nbsp;</a></span>cwiseNotEqual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;std::not_equal_to&lt;<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;, const Derived, const OtherDerived&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseNotEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise != operator of *this and <em>other</em> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this performs an exact comparison, which is generally a bad idea with floating-point types. In order to check for equality between two vectors or matrices with floating-point coefficients, it is generally a far better idea to use a fuzzy comparison as provided by <a class="el" href="classEigen_1_1DenseBase.html#ae8443357b808cd393be1b51974213f9c">isApprox()</a> and isMuchSmallerThan().</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gaceba5f63d4040c79c44109590d4fa606">MatrixXi</a> m(2,2);</div><div class="line">m &lt;&lt; 1, 0,</div><div class="line">     1, 1;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Comparing m with identity matrix:&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; m.cwiseNotEqual(<a class="code" href="classEigen_1_1MatrixBase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">MatrixXi::Identity</a>(2,2)) &lt;&lt; endl;</div><div class="line"><a class="code" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="code" href="classEigen_1_1DenseBase.html#a229be090c665b9bf7d1fcdfd1ab6e0c1">count</a> = m.cwiseNotEqual(<a class="code" href="classEigen_1_1MatrixBase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">MatrixXi::Identity</a>(2,2)).count();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Number of coefficients that are not equal: &quot;</span> &lt;&lt; <a class="code" href="classEigen_1_1DenseBase.html#a229be090c665b9bf7d1fcdfd1ab6e0c1">count</a> &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Comparing m with identity matrix:
0 0
1 0
Number of coefficients that are not equal: 1
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a8cc51452067ce6730d1f68e524958638">cwiseEqual()</a>, <a class="el" href="classEigen_1_1DenseBase.html#ae8443357b808cd393be1b51974213f9c">isApprox()</a>, isMuchSmallerThan() </dd></dl>

</div>
</div>
<a id="a28d9b053ae69eb1073030dc1a39a4c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d9b053ae69eb1073030dc1a39a4c2f">&#9670;&nbsp;</a></span>cwiseProduct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_product_op &lt; Derived ::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>, OtherDerived ::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;, const Derived , const OtherDerived &gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the Schur product (coefficient wise product) of *this and <em>other</em> </dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gaf5dfa8fd62427c5f3c8035daf15ebfcb">Matrix3i</a> a = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3i::Random</a>(), b = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3i::Random</a>();</div><div class="line"><a class="code" href="group__matrixtypedefs.html#gaf5dfa8fd62427c5f3c8035daf15ebfcb">Matrix3i</a> c = a.cwiseProduct(b);</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;a:\n&quot;</span> &lt;&lt; a &lt;&lt; <span class="stringliteral">&quot;\nb:\n&quot;</span> &lt;&lt; b &lt;&lt; <span class="stringliteral">&quot;\nc:\n&quot;</span> &lt;&lt; c &lt;&lt; endl;</div><div class="line"></div></div><!-- fragment --><p> Output: </p><pre class="fragment">a:
 7  6 -3
-2  9  6
 6 -6 -5
b:
 1 -3  9
 0  0  3
 3  9  5
c:
  7 -18 -27
  0   0  18
 18 -54 -25
</pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseBinaryOp.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions. ">CwiseBinaryOp</a>, <a class="el" href="classEigen_1_1MatrixBase.html#aa0147ae59510af37efc4b8f79358324b">cwiseAbs2</a> </dd></dl>

</div>
</div>
<a id="ac8a45ed73a51bbffec202e504f842299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8a45ed73a51bbffec202e504f842299">&#9670;&nbsp;</a></span>cwiseQuotient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_quotient_op&lt;<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;, const Derived, const OtherDerived&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseQuotient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise quotient of *this and <em>other</em> </dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gaabb0b4639dc0b48e691e02e95873b0f1">Vector3d</a> v(2,3,4), <a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af683e04b3926aaf4091581ca24ca09ad">w</a>(4,2,3);</div><div class="line">cout &lt;&lt; v.cwiseQuotient(<a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af683e04b3926aaf4091581ca24ca09ad">w</a>) &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment"> 0.5
 1.5
1.33
</pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseBinaryOp.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions. ">CwiseBinaryOp</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a28d9b053ae69eb1073030dc1a39a4c2f">cwiseProduct()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a44b11744885ab2680da4093ba0b6cbf6">cwiseInverse()</a> </dd></dl>

</div>
</div>
<a id="a315e35a856733d37bc85d9c102aa4e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315e35a856733d37bc85d9c102aa4e01">&#9670;&nbsp;</a></span>cwiseSign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseSignReturnType</a> <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseSign </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise signum of *this.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga99b41a69f0bf64eadb63a97f357ab412">MatrixXd</a> m(2,3);</div><div class="line">m &lt;&lt;  2, -4, 6,</div><div class="line">     -5,  1, 0;</div><div class="line">cout &lt;&lt; m.cwiseSign() &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment"> 1 -1  1
-1  1  0
</pre> 
</div>
</div>
<a id="a9a49e9a834666aa86e80f55b39926e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a49e9a834666aa86e80f55b39926e04">&#9670;&nbsp;</a></span>cwiseSqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseSqrtReturnType</a> <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::cwiseSqrt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise square root of *this.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gaabb0b4639dc0b48e691e02e95873b0f1">Vector3d</a> v(1,2,4);</div><div class="line">cout &lt;&lt; v.cwiseSqrt() &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">   1
1.41
   2
</pre> <dl class="section see"><dt>See also</dt><dd>cwisePow(), cwiseSquare() </dd></dl>

</div>
</div>
<a id="a7ad8f77004bb956b603bb43fd2e3c061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad8f77004bb956b603bb43fd2e3c061">&#9670;&nbsp;</a></span>determinant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::determinant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is defined in the LU module.</p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/LU&gt;</span> </div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>the determinant of this matrix </dd></dl>

</div>
</div>
<a id="ab5768147536273eb2dbdfa389cfd26a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5768147536273eb2dbdfa389cfd26a3">&#9670;&nbsp;</a></span>diagonal() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::template DiagonalIndexReturnType&lt; Index_ &gt;::Type <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::diagonal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the main diagonal of the matrix <code>*this</code> </dd></dl>
<p><code>*this</code> is not required to be square.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gaf5dfa8fd62427c5f3c8035daf15ebfcb">Matrix3i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here are the coefficients on the main diagonal of m:&quot;</span> &lt;&lt; endl</div><div class="line">     &lt;&lt; m.diagonal() &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
 7  6 -3
-2  9  6
 6 -6 -5
Here are the coefficients on the main diagonal of m:
 7
 9
-5
</pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1Diagonal.html" title="Expression of a diagonal/subdiagonal/superdiagonal in a matrix. ">Diagonal</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an expression of the <em>DiagIndex-th</em> sub or super diagonal of the matrix <code>*this</code> </dd></dl>
<p><code>*this</code> is not required to be square.</p>
<p>The template parameter <em>DiagIndex</em> represent a super diagonal if <em>DiagIndex</em> &gt; 0 and a sub diagonal otherwise. <em>DiagIndex</em> == 0 is equivalent to the main diagonal.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gace49b1dc3432f8a6639966a2cb7178be">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here are the coefficients on the 1st super-diagonal and 2nd sub-diagonal of m:&quot;</span> &lt;&lt; endl</div><div class="line">     &lt;&lt; m.diagonal&lt;1&gt;().<a class="code" href="classEigen_1_1DenseBase.html#ac8952c19644a4ac7e41bea45c19b909c">transpose</a>() &lt;&lt; endl</div><div class="line">     &lt;&lt; m.diagonal&lt;-2&gt;().<a class="code" href="classEigen_1_1DenseBase.html#ac8952c19644a4ac7e41bea45c19b909c">transpose</a>() &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here are the coefficients on the 1st super-diagonal and 2nd sub-diagonal of m:
9 1 9
6 6
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ab5768147536273eb2dbdfa389cfd26a3">MatrixBase::diagonal()</a>, class <a class="el" href="classEigen_1_1Diagonal.html" title="Expression of a diagonal/subdiagonal/superdiagonal in a matrix. ">Diagonal</a> </dd></dl>

</div>
</div>
<a id="aebdeedcf67e46d969c556c6c7d9780ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdeedcf67e46d969c556c6c7d9780ee">&#9670;&nbsp;</a></span>diagonal() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::template ConstDiagonalIndexReturnType&lt; Index_ &gt;::Type <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::diagonal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1MatrixBase.html#ab5768147536273eb2dbdfa389cfd26a3">diagonal()</a>.</p>
<p>This is the const version of <a class="el" href="classEigen_1_1MatrixBase.html#ab5768147536273eb2dbdfa389cfd26a3">diagonal&lt;int&gt;()</a>. </p>

</div>
</div>
<a id="a8a13d4b8efbd7797ee8efd3dd988a7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a13d4b8efbd7797ee8efd3dd988a7f7">&#9670;&nbsp;</a></span>diagonal() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1Diagonal.html">DiagonalDynamicIndexReturnType</a> <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::diagonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the <em>DiagIndex-th</em> sub or super diagonal of the matrix <code>*this</code> </dd></dl>
<p><code>*this</code> is not required to be square.</p>
<p>The template parameter <em>DiagIndex</em> represent a super diagonal if <em>DiagIndex</em> &gt; 0 and a sub diagonal otherwise. <em>DiagIndex</em> == 0 is equivalent to the main diagonal.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gace49b1dc3432f8a6639966a2cb7178be">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here are the coefficients on the 1st super-diagonal and 2nd sub-diagonal of m:&quot;</span> &lt;&lt; endl</div><div class="line">     &lt;&lt; m.diagonal(1).transpose() &lt;&lt; endl</div><div class="line">     &lt;&lt; m.diagonal(-2).transpose() &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here are the coefficients on the 1st super-diagonal and 2nd sub-diagonal of m:
9 1 9
6 6
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ab5768147536273eb2dbdfa389cfd26a3">MatrixBase::diagonal()</a>, class <a class="el" href="classEigen_1_1Diagonal.html" title="Expression of a diagonal/subdiagonal/superdiagonal in a matrix. ">Diagonal</a> </dd></dl>

</div>
</div>
<a id="aed11a711c0a3d5dbf8bc094008e29846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed11a711c0a3d5dbf8bc094008e29846">&#9670;&nbsp;</a></span>diagonal() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1Transpose.html">ConstDiagonalDynamicIndexReturnType</a> <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::diagonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1MatrixBase.html#a8a13d4b8efbd7797ee8efd3dd988a7f7">diagonal(Index)</a>. </p>

</div>
</div>
<a id="ab79e511b9322b8b801858e253fb257eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79e511b9322b8b801858e253fb257eb">&#9670;&nbsp;</a></span>diagonalSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::diagonalSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the size of the main diagonal, which is min(<a class="el" href="structEigen_1_1EigenBase.html#ab75c2d8a783d055db397319c5a330eee">rows()</a>,<a class="el" href="structEigen_1_1EigenBase.html#a16145eb95335754c2ff8b2a58731bc53">cols()</a>). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structEigen_1_1EigenBase.html#ab75c2d8a783d055db397319c5a330eee">rows()</a>, <a class="el" href="structEigen_1_1EigenBase.html#a16145eb95335754c2ff8b2a58731bc53">cols()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a86241c772c74c04eeeb0480b99c5ab77a25cb495affdbd796198462b8ef06be91">SizeAtCompileTime</a>. </dd></dl>

</div>
</div>
<a id="adfd32bf5fcf6ee603c924dde9bf7bc39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd32bf5fcf6ee603c924dde9bf7bc39">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEigen_1_1ScalarBinaryOpTraits.html">ScalarBinaryOpTraits</a>&lt; typename internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>, typename internal::traits&lt; OtherDerived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::ReturnType <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the dot product of *this with other.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="section note"><dt>Note</dt><dd>If the scalar type is complex numbers, then this function returns the hermitian (sesquilinear) dot product, conjugate-linear in the first variable and linear in the second variable.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ac8da566526419f9742a6c471bbd87e0a">squaredNorm()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a196c4ec3c8ffdf5bda45d0f617154975">norm()</a> </dd></dl>

</div>
</div>
<a id="a30430fa3d5b4e74d312fd4f502ac984d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30430fa3d5b4e74d312fd4f502ac984d">&#9670;&nbsp;</a></span>eigenvalues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::EigenvaluesReturnType <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::eigenvalues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the eigenvalues of a matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Column vector containing the eigenvalues.</dd></dl>
<p>This is defined in the Eigenvalues module.</p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Eigenvalues&gt;</span> </div></div><!-- fragment --><p> This function computes the eigenvalues with the help of the <a class="el" href="classEigen_1_1EigenSolver.html" title="Computes eigenvalues and eigenvectors of general matrices. ">EigenSolver</a> class (for real matrices) or the <a class="el" href="classEigen_1_1ComplexEigenSolver.html" title="Computes eigenvalues and eigenvectors of general complex matrices. ">ComplexEigenSolver</a> class (for complex matrices).</p>
<p>The eigenvalues are repeated according to their algebraic multiplicity, so there are as many eigenvalues as rows in the matrix.</p>
<p>The <a class="el" href="classEigen_1_1SelfAdjointView.html" title="Expression of a selfadjoint matrix from a triangular part of a dense matrix. ">SelfAdjointView</a> class provides a better algorithm for selfadjoint matrices.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga99b41a69f0bf64eadb63a97f357ab412">MatrixXd</a> ones = <a class="code" href="classEigen_1_1DenseBase.html#a2755cb4023f7376880523626a8e05101">MatrixXd::Ones</a>(3,3);</div><div class="line"><a class="code" href="group__matrixtypedefs.html#ga495330872c3cd279e5fd0419747ada55">VectorXcd</a> eivals = ones.eigenvalues();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;The eigenvalues of the 3x3 matrix of ones are:&quot;</span> &lt;&lt; endl &lt;&lt; eivals &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">The eigenvalues of the 3x3 matrix of ones are:
(-5.31e-17,0)
        (3,0)
        (0,0)
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1EigenSolver.html#a114189009e42f5e03372a7a3dfa33b97" title="Returns the eigenvalues of given matrix. ">EigenSolver::eigenvalues()</a>, <a class="el" href="classEigen_1_1ComplexEigenSolver.html#a10c25c7620e7faedcd39991cce3a757b" title="Returns the eigenvalues of given matrix. ">ComplexEigenSolver::eigenvalues()</a>, <a class="el" href="classEigen_1_1SelfAdjointView.html#ad4f34424b4ea12de9bbc5623cb938b4f" title="Computes the eigenvalues of a matrix. ">SelfAdjointView::eigenvalues()</a> </dd></dl>

</div>
</div>
<a id="a70901e189e876f64d7f3fee1dbe942cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70901e189e876f64d7f3fee1dbe942cc">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const MatrixExponentialReturnValue&lt;Derived&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::exp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function requires the <a href="unsupported/group__MatrixFunctions__Module.html">unsupported MatrixFunctions module</a>. To compute the coefficient-wise exponential use <a class="el" href="classEigen_1_1ArrayBase.html#a555df413a093a7dea1bf59253189c815">ArrayBase::exp</a> . </p>
<dl class="section return"><dt>Returns</dt><dd>an expression of the matrix exponential of <code>*this</code>. </dd></dl>

</div>
</div>
<a id="ad2fdb842d9a715f8778d0b33c29cfe49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2fdb842d9a715f8778d0b33c29cfe49">&#9670;&nbsp;</a></span>forceAlignedAccess() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1ForceAlignedAccess.html">ForceAlignedAccess</a>&lt; Derived &gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::forceAlignedAccess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of *this with forced aligned access </dd></dl>
<dl class="section see"><dt>See also</dt><dd>forceAlignedAccessIf(),class <a class="el" href="classEigen_1_1ForceAlignedAccess.html" title="Enforce aligned packet loads and stores regardless of what is requested. ">ForceAlignedAccess</a> </dd></dl>

</div>
</div>
<a id="afdaf810ac1708ca6d6ecdcfac1e06699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdaf810ac1708ca6d6ecdcfac1e06699">&#9670;&nbsp;</a></span>forceAlignedAccess() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1ForceAlignedAccess.html">ForceAlignedAccess</a>&lt; Derived &gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::forceAlignedAccess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of *this with forced aligned access </dd></dl>
<dl class="section see"><dt>See also</dt><dd>forceAlignedAccessIf(), class <a class="el" href="classEigen_1_1ForceAlignedAccess.html" title="Enforce aligned packet loads and stores regardless of what is requested. ">ForceAlignedAccess</a> </dd></dl>

</div>
</div>
<a id="af42d92f115d4b8fa3d5aa731ed496ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42d92f115d4b8fa3d5aa731ed496ed1">&#9670;&nbsp;</a></span>forceAlignedAccessIf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;bool Enable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::add_const_on_value_type&lt;typename internal::conditional&lt;Enable,<a class="el" href="classEigen_1_1ForceAlignedAccess.html">ForceAlignedAccess</a>&lt;Derived&gt;,Derived&amp;&gt;::type&gt;::type <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::forceAlignedAccessIf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of *this with forced aligned access if <em>Enable</em> is true. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#afdaf810ac1708ca6d6ecdcfac1e06699">forceAlignedAccess()</a>, class <a class="el" href="classEigen_1_1ForceAlignedAccess.html" title="Enforce aligned packet loads and stores regardless of what is requested. ">ForceAlignedAccess</a> </dd></dl>

</div>
</div>
<a id="ae35213d1dd4dd13ebe9a7a762d6bb847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35213d1dd4dd13ebe9a7a762d6bb847">&#9670;&nbsp;</a></span>forceAlignedAccessIf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;bool Enable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::conditional&lt;Enable,<a class="el" href="classEigen_1_1ForceAlignedAccess.html">ForceAlignedAccess</a>&lt;Derived&gt;,Derived&amp;&gt;::type <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::forceAlignedAccessIf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of *this with forced aligned access if <em>Enable</em> is true. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#afdaf810ac1708ca6d6ecdcfac1e06699">forceAlignedAccess()</a>, class <a class="el" href="classEigen_1_1ForceAlignedAccess.html" title="Enforce aligned packet loads and stores regardless of what is requested. ">ForceAlignedAccess</a> </dd></dl>

</div>
</div>
<a id="a863bc0e06b641a089508eabec6835ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863bc0e06b641a089508eabec6835ab2">&#9670;&nbsp;</a></span>fullPivHouseholderQr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1FullPivHouseholderQR.html">FullPivHouseholderQR</a>&lt; typename <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::fullPivHouseholderQr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the full-pivoting Householder QR decomposition of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1FullPivHouseholderQR.html" title="Householder rank-revealing QR decomposition of a matrix with full pivoting. ">FullPivHouseholderQR</a> </dd></dl>

</div>
</div>
<a id="a25da97d31acab0ee5d9d13bdbb0569da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25da97d31acab0ee5d9d13bdbb0569da">&#9670;&nbsp;</a></span>fullPivLu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1FullPivLU.html">FullPivLU</a>&lt; typename <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::fullPivLu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is defined in the LU module.</p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/LU&gt;</span> </div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>the full-pivoting LU decomposition of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1FullPivLU.html" title="LU decomposition of a matrix with complete pivoting, and related features. ">FullPivLU</a> </dd></dl>

</div>
</div>
<a id="a9a9377aab1cea26db5f25bab7e682f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9377aab1cea26db5f25bab7e682f8f">&#9670;&nbsp;</a></span>householderQr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1HouseholderQR.html">HouseholderQR</a>&lt; typename <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::householderQr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the Householder QR decomposition of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1HouseholderQR.html" title="Householder QR decomposition of a matrix. ">HouseholderQR</a> </dd></dl>

</div>
</div>
<a id="a32222d3b6677e6cdf0b801463f329b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32222d3b6677e6cdf0b801463f329b72">&#9670;&nbsp;</a></span>hypotNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; typename internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::Real <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::hypotNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <em>l2</em> norm of <code>*this</code> avoiding undeflow and overflow. This version use a concatenation of hypot() calls, and it is very slow.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a196c4ec3c8ffdf5bda45d0f617154975">norm()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#ab84d3e64f855813b1eea4202c0697dc1">stableNorm()</a> </dd></dl>

</div>
</div>
<a id="a98bb9a0f705c6dfde85b0bfff31bf88f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98bb9a0f705c6dfde85b0bfff31bf88f">&#9670;&nbsp;</a></span>Identity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::IdentityReturnType <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::Identity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the identity matrix (not necessarily square).</dd></dl>
<p>This variant is only for fixed-size <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions. ">MatrixBase</a> types. For dynamic-size types, you need to use the variant taking size arguments.</p>
<p>Example: </p><div class="fragment"><div class="line">cout &lt;&lt; Matrix&lt;double, 3, 4&gt;::Identity() &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">1 0 0 0
0 1 0 0
0 0 1 0
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#acf33ce20ef03ead47cb3dbcd5f416ede">Identity(Index,Index)</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a18e969adfdf2db4ac44c47fbdc854683">setIdentity()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a4ccbd8dfa06e9d47b9bf84711f8b9d40">isIdentity()</a> </dd></dl>

</div>
</div>
<a id="acf33ce20ef03ead47cb3dbcd5f416ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf33ce20ef03ead47cb3dbcd5f416ede">&#9670;&nbsp;</a></span>Identity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::IdentityReturnType <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::Identity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the identity matrix (not necessarily square).</dd></dl>
<p>The parameters <em>rows</em> and <em>cols</em> are the number of rows and of columns of the returned matrix. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions. ">MatrixBase</a> type.</p>
<p>This variant is meant to be used for dynamic-size matrix types. For fixed-size types, it is redundant to pass <em>rows</em> and <em>cols</em> as arguments, so <a class="el" href="classEigen_1_1MatrixBase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">Identity()</a> should be used instead.</p>
<p>Example: </p><div class="fragment"><div class="line">cout &lt;&lt; <a class="code" href="classEigen_1_1MatrixBase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">MatrixXd::Identity</a>(4, 3) &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">1 0 0
0 1 0
0 0 1
0 0 0
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">Identity()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a18e969adfdf2db4ac44c47fbdc854683">setIdentity()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a4ccbd8dfa06e9d47b9bf84711f8b9d40">isIdentity()</a> </dd></dl>

</div>
</div>
<a id="afba6327bc264ba4b3fc3dbdfe4b57c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba6327bc264ba4b3fc3dbdfe4b57c60">&#9670;&nbsp;</a></span>imag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ImagReturnType <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::imag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><br />
 </p>
<dl class="section return"><dt>Returns</dt><dd>an read-only expression of the imaginary part of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#aeba1be140ede8b142460b325945c551f" title="  ">real()</a> </dd></dl>

</div>
</div>
<a id="ae468f7f102d5f04f20b2c0afe6eb0f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae468f7f102d5f04f20b2c0afe6eb0f82">&#9670;&nbsp;</a></span>imag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NonConstImagReturnType <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::imag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><br />
 </p>
<dl class="section return"><dt>Returns</dt><dd>a non const expression of the imaginary part of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#aeba1be140ede8b142460b325945c551f" title="  ">real()</a> </dd></dl>

</div>
</div>
<a id="a7712eb69e8ea3c8f7b8da1c44dbdeebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7712eb69e8ea3c8f7b8da1c44dbdeebf">&#9670;&nbsp;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Inverse.html">Inverse</a>&lt; Derived &gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::inverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is defined in the LU module.</p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/LU&gt;</span> </div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>the matrix inverse of this matrix.</dd></dl>
<p>For small fixed sizes up to 4x4, this method uses cofactors. In the general case, this method uses class <a class="el" href="classEigen_1_1PartialPivLU.html" title="LU decomposition of a matrix with partial pivoting, and related features. ">PartialPivLU</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This matrix must be invertible, otherwise the result is undefined. If you need an invertibility check, do the following: <ul>
<li>for fixed sizes up to 4x4, use <a class="el" href="classEigen_1_1MatrixBase.html#a7baaf2fdec0191a2166cf9fd84a2dcb2">computeInverseAndDetWithCheck()</a>. </li>
<li>for the general case, use class <a class="el" href="classEigen_1_1FullPivLU.html" title="LU decomposition of a matrix with complete pivoting, and related features. ">FullPivLU</a>.</li>
</ul>
Example: <div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga84e9fd068879d808012bb6d5dbfecb17">Matrix3d</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Its inverse is:&quot;</span> &lt;&lt; endl &lt;&lt; m.inverse() &lt;&lt; endl;</div></div><!-- fragment --> Output: <pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Its inverse is:
-0.199   2.23   2.84
  1.01 -0.555  -1.42
 -1.62   3.59   3.29
</pre></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a7baaf2fdec0191a2166cf9fd84a2dcb2">computeInverseAndDetWithCheck()</a> </dd></dl>

</div>
</div>
<a id="a97027ea54c8cd1ddb1c578fee5cedc67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97027ea54c8cd1ddb1c578fee5cedc67">&#9670;&nbsp;</a></span>isDiagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::isDiagonal </td>
          <td>(</td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;::dummy_precision()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if *this is approximately equal to a diagonal matrix, within the precision given by <em>prec</em>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga84e9fd068879d808012bb6d5dbfecb17">Matrix3d</a> m = 10000 * <a class="code" href="classEigen_1_1MatrixBase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">Matrix3d::Identity</a>();</div><div class="line">m(0,2) = 1;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here&#39;s the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;m.isDiagonal() returns: &quot;</span> &lt;&lt; m.isDiagonal() &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;m.isDiagonal(1e-3) returns: &quot;</span> &lt;&lt; m.isDiagonal(1e-3) &lt;&lt; endl;</div><div class="line"></div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here's the matrix m:
1e+04     0     1
    0 1e+04     0
    0     0 1e+04
m.isDiagonal() returns: 0
m.isDiagonal(1e-3) returns: 1
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a14235b62c90f93fe910070b4743782d0">asDiagonal()</a> </dd></dl>

</div>
</div>
<a id="a4ccbd8dfa06e9d47b9bf84711f8b9d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ccbd8dfa06e9d47b9bf84711f8b9d40">&#9670;&nbsp;</a></span>isIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::isIdentity </td>
          <td>(</td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;::dummy_precision()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if *this is approximately equal to the identity matrix (not necessarily square), within the precision given by <em>prec</em>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga84e9fd068879d808012bb6d5dbfecb17">Matrix3d</a> m = <a class="code" href="classEigen_1_1MatrixBase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">Matrix3d::Identity</a>();</div><div class="line">m(0,2) = 1e-4;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here&#39;s the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;m.isIdentity() returns: &quot;</span> &lt;&lt; m.isIdentity() &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;m.isIdentity(1e-3) returns: &quot;</span> &lt;&lt; m.isIdentity(1e-3) &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here's the matrix m:
     1      0 0.0001
     0      1      0
     0      0      1
m.isIdentity() returns: 0
m.isIdentity(1e-3) returns: 1
</pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor. ">CwiseNullaryOp</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">Identity()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#acf33ce20ef03ead47cb3dbcd5f416ede">Identity(Index,Index)</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a18e969adfdf2db4ac44c47fbdc854683">setIdentity()</a> </dd></dl>

</div>
</div>
<a id="a1e96c42d79a56f0a6ade30ce031e17eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e96c42d79a56f0a6ade30ce031e17eb">&#9670;&nbsp;</a></span>isLowerTriangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::isLowerTriangular </td>
          <td>(</td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;::dummy_precision()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if *this is approximately equal to a lower triangular matrix, within the precision given by <em>prec</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#aae3ec1660bb4ac584220481c54ab4a64">isUpperTriangular()</a> </dd></dl>

</div>
</div>
<a id="aefdc8e4e4c156fdd79a21479e75dcd8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefdc8e4e4c156fdd79a21479e75dcd8a">&#9670;&nbsp;</a></span>isOrthogonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::isOrthogonal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if *this is approximately orthogonal to <em>other</em>, within the precision given by <em>prec</em>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gaabb0b4639dc0b48e691e02e95873b0f1">Vector3d</a> v(1,0,0);</div><div class="line"><a class="code" href="group__matrixtypedefs.html#gaabb0b4639dc0b48e691e02e95873b0f1">Vector3d</a> <a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af683e04b3926aaf4091581ca24ca09ad">w</a>(1e-4,0,1);</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here&#39;s the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here&#39;s the vector w:&quot;</span> &lt;&lt; endl &lt;&lt; <a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af683e04b3926aaf4091581ca24ca09ad">w</a> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;v.isOrthogonal(w) returns: &quot;</span> &lt;&lt; v.isOrthogonal(<a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af683e04b3926aaf4091581ca24ca09ad">w</a>) &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;v.isOrthogonal(w,1e-3) returns: &quot;</span> &lt;&lt; v.isOrthogonal(<a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af683e04b3926aaf4091581ca24ca09ad">w</a>,1e-3) &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here's the vector v:
1
0
0
Here's the vector w:
0.0001
     0
     1
v.isOrthogonal(w) returns: 0
v.isOrthogonal(w,1e-3) returns: 1
</pre> 
</div>
</div>
<a id="a8a7ee34ce202cac3eeea9cf20c9e4833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7ee34ce202cac3eeea9cf20c9e4833">&#9670;&nbsp;</a></span>isUnitary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::isUnitary </td>
          <td>(</td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;::dummy_precision()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if *this is approximately an unitary matrix, within the precision given by <em>prec</em>. In the case where the <em>Scalar</em> type is real numbers, a unitary matrix is an orthogonal matrix, whence the name.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This can be used to check whether a family of vectors forms an orthonormal basis. Indeed, <code>m.isUnitary()</code> returns true if and only if the columns (equivalently, the rows) of m form an orthonormal basis.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga84e9fd068879d808012bb6d5dbfecb17">Matrix3d</a> m = <a class="code" href="classEigen_1_1MatrixBase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">Matrix3d::Identity</a>();</div><div class="line">m(0,2) = 1e-4;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here&#39;s the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;m.isUnitary() returns: &quot;</span> &lt;&lt; m.isUnitary() &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;m.isUnitary(1e-3) returns: &quot;</span> &lt;&lt; m.isUnitary(1e-3) &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here's the matrix m:
     1      0 0.0001
     0      1      0
     0      0      1
m.isUnitary() returns: 0
m.isUnitary(1e-3) returns: 1
</pre> 
</div>
</div>
<a id="aae3ec1660bb4ac584220481c54ab4a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3ec1660bb4ac584220481c54ab4a64">&#9670;&nbsp;</a></span>isUpperTriangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::isUpperTriangular </td>
          <td>(</td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;::dummy_precision()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if *this is approximately equal to an upper triangular matrix, within the precision given by <em>prec</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a1e96c42d79a56f0a6ade30ce031e17eb">isLowerTriangular()</a> </dd></dl>

</div>
</div>
<a id="a5745dca9c54390633b434e54a1d1eedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5745dca9c54390633b434e54a1d1eedd">&#9670;&nbsp;</a></span>jacobiSvd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1JacobiSVD.html">JacobiSVD</a>&lt; typename <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::jacobiSvd </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>computationOptions</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is defined in the SVD module.</p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/SVD&gt;</span> </div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>the singular value decomposition of <code>*this</code> computed by two-sided Jacobi transformations.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1JacobiSVD.html" title="Two-sided Jacobi SVD decomposition of a rectangular matrix. ">JacobiSVD</a> </dd></dl>

</div>
</div>
<a id="ae0c280b1066c14ed577021f38876527f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c280b1066c14ed577021f38876527f">&#9670;&nbsp;</a></span>lazyProduct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Product.html">Product</a>&lt; Derived, OtherDerived, LazyProduct &gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::lazyProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the matrix product of <code>*this</code> and <em>other</em> without implicit evaluation.</dd></dl>
<p>The returned product will behave like any other expressions: the coefficients of the product will be computed once at a time as requested. This might be useful in some extremely rare cases when only a small and no coherent fraction of the result's coefficients have to be computed.</p>
<dl class="section warning"><dt>Warning</dt><dd>This version of the matrix product can be much much slower. So use it only if you know what you are doing and that you measured a true speed improvement.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>operator*(const MatrixBase&amp;) </dd></dl>

</div>
</div>
<a id="a0ecf058a0727a4cab8b42d79e95072e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ecf058a0727a4cab8b42d79e95072e1">&#9670;&nbsp;</a></span>ldlt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1LDLT.html">LDLT</a>&lt; typename <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::ldlt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is defined in the Cholesky module.</p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Cholesky&gt;</span> </div></div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>the Cholesky decomposition with full pivoting without square root of <code>*this</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SelfAdjointView.html#a644155eef17b37c95d85b9f65bb49ac4">SelfAdjointView::ldlt()</a> </dd></dl>

</div>
</div>
<a id="a90c45f7a30265df792d5aeaddead2635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c45f7a30265df792d5aeaddead2635">&#9670;&nbsp;</a></span>llt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1LLT.html">LLT</a>&lt; typename <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::llt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is defined in the Cholesky module.</p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Cholesky&gt;</span> </div></div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classEigen_1_1LLT.html" title="Standard Cholesky decomposition (LL^T) of a matrix and associated features. ">LLT</a> decomposition of <code>*this</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SelfAdjointView.html#a405e810491642a7f7b785f2ad6f93619">SelfAdjointView::llt()</a> </dd></dl>

</div>
</div>
<a id="a4dc57b319fc1cf8c9035016e56602a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc57b319fc1cf8c9035016e56602a7d">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const MatrixLogarithmReturnValue&lt;Derived&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::log </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function requires the <a href="unsupported/group__MatrixFunctions__Module.html">unsupported MatrixFunctions module</a>. To compute the coefficient-wise logarithm use <a class="el" href="classEigen_1_1ArrayBase.html#a49537efa216ab4e72f7493149d4057b9">ArrayBase::log</a> . </p>
<dl class="section return"><dt>Returns</dt><dd>an expression of the matrix logarithm of <code>*this</code>. </dd></dl>

</div>
</div>
<a id="a72586ab059e889e7d2894ff227747e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72586ab059e889e7d2894ff227747e35">&#9670;&nbsp;</a></span>lpNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;int p&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::RealScalar <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::lpNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <b>coefficient-wise</b> <img class="formulaInl" alt="$ \ell^p $" src="form_11.png"/> norm of <code>*this</code>, that is, returns the p-th root of the sum of the p-th powers of the absolute values of the coefficients of <code>*this</code>. If <em>p</em> is the special value <em><a class="el" href="namespaceEigen.html#a7951593b031e13d90223c83d022ce99e">Eigen::Infinity</a></em>, this function returns the <img class="formulaInl" alt="$ \ell^\infty $" src="form_12.png"/> norm, that is the maximum of the absolute values of the coefficients of <code>*this</code>.</dd></dl>
<p>In all cases, if <code>*this</code> is empty, then the value 0 is returned.</p>
<dl class="section note"><dt>Note</dt><dd>For matrices, this function does not compute the <a href="https://en.wikipedia.org/wiki/Operator_norm">operator-norm</a>. That is, if <code>*this</code> is a matrix, then its coefficients are interpreted as a 1D vector. Nonetheless, you can easily compute the 1-norm and <img class="formulaInl" alt="$\infty$" src="form_13.png"/>-norm matrix operator norms using <a class="el" href="group__TutorialReductionsVisitorsBroadcasting.html#TutorialReductionsVisitorsBroadcastingReductionsNorm">partial reductions </a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a196c4ec3c8ffdf5bda45d0f617154975">norm()</a> </dd></dl>

</div>
</div>
<a id="afb312afbfe960cbda67811552d876fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb312afbfe960cbda67811552d876fae">&#9670;&nbsp;</a></span>lu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialPivLU.html">PartialPivLU</a>&lt; typename <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::lu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is defined in the LU module.</p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/LU&gt;</span> </div></div><!-- fragment --><p>Synonym of <a class="el" href="classEigen_1_1MatrixBase.html#a6199d8aaf26c1b8ac3097fdfa7733a1e">partialPivLu()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the partial-pivoting LU decomposition of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1PartialPivLU.html" title="LU decomposition of a matrix with partial pivoting, and related features. ">PartialPivLU</a> </dd></dl>

</div>
</div>
<a id="a13291e900f7e81ddc6e5b8802f82092b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13291e900f7e81ddc6e5b8802f82092b">&#9670;&nbsp;</a></span>makeHouseholder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename EssentialPart &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::makeHouseholder </td>
          <td>(</td>
          <td class="paramtype">EssentialPart &amp;&#160;</td>
          <td class="paramname"><em>essential</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealScalar &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the elementary reflector H such that: <img class="formulaInl" alt="$ H *this = [ beta 0 ... 0]^T $" src="form_131.png"/> where the transformation H is: <img class="formulaInl" alt="$ H = I - tau v v^*$" src="form_132.png"/> and the vector v is: <img class="formulaInl" alt="$ v^T = [1 essential^T] $" src="form_133.png"/></p>
<p>On output: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">essential</td><td>the essential part of the vector <code>v</code> </td></tr>
    <tr><td class="paramname">tau</td><td>the scaling factor of the Householder transformation </td></tr>
    <tr><td class="paramname">beta</td><td>the result of H * <code>*this</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#aebf4bac7dffe2685ab93734fb776e817">MatrixBase::makeHouseholderInPlace()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a8f2c8059ef3f04cfa0c73b4c012db855">MatrixBase::applyHouseholderOnTheLeft()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#ab3e52262b41fa40e194dda245e0f9675">MatrixBase::applyHouseholderOnTheRight()</a> </dd></dl>

</div>
</div>
<a id="aebf4bac7dffe2685ab93734fb776e817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf4bac7dffe2685ab93734fb776e817">&#9670;&nbsp;</a></span>makeHouseholderInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::makeHouseholderInPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealScalar &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the elementary reflector H such that: <img class="formulaInl" alt="$ H *this = [ beta 0 ... 0]^T $" src="form_131.png"/> where the transformation H is: <img class="formulaInl" alt="$ H = I - tau v v^*$" src="form_132.png"/> and the vector v is: <img class="formulaInl" alt="$ v^T = [1 essential^T] $" src="form_133.png"/></p>
<p>The essential part of the vector <code>v</code> is stored in *this.</p>
<p>On output: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tau</td><td>the scaling factor of the Householder transformation </td></tr>
    <tr><td class="paramname">beta</td><td>the result of H * <code>*this</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a13291e900f7e81ddc6e5b8802f82092b">MatrixBase::makeHouseholder()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a8f2c8059ef3f04cfa0c73b4c012db855">MatrixBase::applyHouseholderOnTheLeft()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#ab3e52262b41fa40e194dda245e0f9675">MatrixBase::applyHouseholderOnTheRight()</a> </dd></dl>

</div>
</div>
<a id="a2c1085de7645f23f240876388457da0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1085de7645f23f240876388457da0b">&#9670;&nbsp;</a></span>noalias()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1NoAlias.html">NoAlias</a>&lt; Derived, <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a> &gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::noalias </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pseudo expression of <code>*this</code> with an operator= assuming no aliasing between <code>*this</code> and the source expression.</dd></dl>
<p>More precisely, <a class="el" href="classEigen_1_1MatrixBase.html#a2c1085de7645f23f240876388457da0b">noalias()</a> allows to bypass the EvalBeforeAssignBit flag. Currently, even though several expressions may alias, only product expressions have this flag. Therefore, <a class="el" href="classEigen_1_1MatrixBase.html#a2c1085de7645f23f240876388457da0b">noalias()</a> is only usefull when the source expression contains a matrix product.</p>
<p>Here are some examples where noalias is usefull: </p><div class="fragment"><div class="line">D.noalias()  = A * B;</div><div class="line">D.noalias() += A.transpose() * B;</div><div class="line">D.noalias() -= 2 * A * B.adjoint();</div></div><!-- fragment --><p>On the other hand the following example will lead to a <b>wrong</b> result: </p><div class="fragment"><div class="line">A.noalias() = A * B;</div></div><!-- fragment --><p> because the result matrix A is also an operand of the matrix product. Therefore, there is no alternative than evaluating A * B in a temporary, that is the default behavior when you write: </p><div class="fragment"><div class="line">A = A * B;</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1NoAlias.html" title="Pseudo expression providing an operator = assuming no aliasing. ">NoAlias</a> </dd></dl>

</div>
</div>
<a id="a196c4ec3c8ffdf5bda45d0f617154975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196c4ec3c8ffdf5bda45d0f617154975">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; typename internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::Real <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>, for vectors, the <em>l2</em> norm of <code>*this</code>, and for matrices the Frobenius norm. In both cases, it consists in the square root of the sum of the square of all the matrix entries. For vectors, this is also equals to the square root of the dot product of <code>*this</code> with itself.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a72586ab059e889e7d2894ff227747e35">lpNorm()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#adfd32bf5fcf6ee603c924dde9bf7bc39">dot()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#ac8da566526419f9742a6c471bbd87e0a">squaredNorm()</a> </dd></dl>

</div>
</div>
<a id="ad16303c47ba36f7a41ea264cb26bceb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16303c47ba36f7a41ea264cb26bceb6">&#9670;&nbsp;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::normalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Normalizes the vector, i.e. divides it by its own norm.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the input vector is too small (i.e., this-&gt;<a class="el" href="classEigen_1_1MatrixBase.html#a196c4ec3c8ffdf5bda45d0f617154975">norm()</a>==0), then <code>*this</code> is left unchanged.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a196c4ec3c8ffdf5bda45d0f617154975">norm()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a5cf2fd4c57e59604fd4116158fd34308">normalized()</a> </dd></dl>

</div>
</div>
<a id="a5cf2fd4c57e59604fd4116158fd34308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf2fd4c57e59604fd4116158fd34308">&#9670;&nbsp;</a></span>normalized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::normalized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the quotient of <code>*this</code> by its own norm.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the input vector is too small (i.e., this-&gt;<a class="el" href="classEigen_1_1MatrixBase.html#a196c4ec3c8ffdf5bda45d0f617154975">norm()</a>==0), then this function returns a copy of the input.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a196c4ec3c8ffdf5bda45d0f617154975">norm()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#ad16303c47ba36f7a41ea264cb26bceb6">normalize()</a> </dd></dl>

</div>
</div>
<a id="a71c2d83286636c8f6fde6b26539d656f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c2d83286636c8f6fde6b26539d656f">&#9670;&nbsp;</a></span>operator &amp;&amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_boolean_and_op, const Derived, const OtherDerived&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise boolean <b>and</b> operator of <code>*this</code> and <em>other</em> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this operator is for expression of bool only.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__arraytypedefs.html#gaaaaed220517b7fc8a3494d6b2f0361e3">Array3d</a> v(-1,2,1), <a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af683e04b3926aaf4091581ca24ca09ad">w</a>(-3,2,3);</div><div class="line">cout &lt;&lt; ((v&lt;<a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af683e04b3926aaf4091581ca24ca09ad">w</a>) &amp;&amp; (v&lt;0)) &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">0
0
0
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a6f44fface70a468cf9df2a4b33448298">operator||()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a65e78cfcbc9852e6923bebff4323ddca">select()</a> </dd></dl>

</div>
</div>
<a id="a028c7ac8094d610042fd0f9feca68f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028c7ac8094d610042fd0f9feca68f63">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if at least one pair of coefficients of <code>*this</code> and <em>other</em> are not exactly equal to each other. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>When using floating point scalar values you probably should rather use a fuzzy comparison such as <a class="el" href="classEigen_1_1DenseBase.html#ae8443357b808cd393be1b51974213f9c">isApprox()</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#ae8443357b808cd393be1b51974213f9c">isApprox()</a>, operator== </dd></dl>

</div>
</div>
<a id="a2816a4d2f2e86899e7f8986719d08889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2816a4d2f2e86899e7f8986719d08889">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_product_op&lt;<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>,T&gt;,Derived,<a class="el" href="classEigen_1_1DenseBase.html#a68a7ece6c5629d1e9447a321fcb14ccd">Constant</a>&lt;T&gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of <code>*this</code> scaled by the scalar factor <em>scalar</em> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is the scalar type of <em>scalar</em>. It must be compatible with the scalar type of the given expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2d220efbf7047f0894787888288cfcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d220efbf7047f0894787888288cfcc">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Product.html">Product</a>&lt; Derived, OtherDerived &gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the matrix product of <code>*this</code> and <em>other</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If instead of the matrix product you want the coefficient-wise product, see Cwise::operator*().</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ae0c280b1066c14ed577021f38876527f">lazyProduct()</a>, operator*=(const MatrixBase&amp;), Cwise::operator*() </dd></dl>

</div>
</div>
<a id="a36fb95c37f0a454e0e2e5cb120b2df7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36fb95c37f0a454e0e2e5cb120b2df7f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename DiagonalDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Product.html">Product</a>&lt; Derived, DiagonalDerived, LazyProduct &gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const DiagonalBase&lt; DiagonalDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_diagonal</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the diagonal matrix product of <code>*this</code> by the diagonal matrix <em>diagonal</em>. </dd></dl>

</div>
</div>
<a id="a3783b6168995ca117a1c19fea3630ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3783b6168995ca117a1c19fea3630ac4">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived &amp; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>replaces <code>*this</code> by <code>*this</code> * <em>other</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>*this</code> </dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga276bae130c142e906ad8f47d24d11c1c">Matrix3f</a> A = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3f::Random</a>(3,3), B;</div><div class="line">B &lt;&lt; 0,1,0,  </div><div class="line">     0,0,1,  </div><div class="line">     1,0,0;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;At start, A = &quot;</span> &lt;&lt; endl &lt;&lt; A &lt;&lt; endl;</div><div class="line">A *= B;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;After A *= B, A = &quot;</span> &lt;&lt; endl &lt;&lt; A &lt;&lt; endl;</div><div class="line">A.applyOnTheRight(B);  <span class="comment">// equivalent to A *= B</span></div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;After applyOnTheRight, A = &quot;</span> &lt;&lt; endl &lt;&lt; A &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">At start, A = 
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
After A *= B, A = 
 -0.33   0.68  0.597
 0.536 -0.211  0.823
-0.444  0.566 -0.605
After applyOnTheRight, A = 
 0.597  -0.33   0.68
 0.823  0.536 -0.211
-0.605 -0.444  0.566
</pre> 
</div>
</div>
<a id="acc4d02dad6db83c4235dafbaaebe140f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4d02dad6db83c4235dafbaaebe140f">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; <a class="el" href="classEigen_1_1DenseBase.html#addd7080d5c202795820e361768d0140c">sum</a> &lt;<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;, const Derived, const OtherDerived&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the sum of <code>*this</code> and <em>other</em> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you want to add a given scalar to all coefficients, see Cwise::operator+().</dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseBinaryOp.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions. ">CwiseBinaryOp</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a983cc3be0bbe11b3d041a415b76ce010">operator+=()</a> </dd></dl>

</div>
</div>
<a id="a983cc3be0bbe11b3d041a415b76ce010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983cc3be0bbe11b3d041a415b76ce010">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived &amp; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>replaces <code>*this</code> by <code>*this</code> + <em>other</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>*this</code> </dd></dl>

</div>
</div>
<a id="aed6b17344c30a260af7c570e3367fd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6b17344c30a260af7c570e3367fd71">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; difference &lt;<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;, const Derived, const OtherDerived&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the difference of <code>*this</code> and <em>other</em> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you want to substract a given scalar from all coefficients, see Cwise::operator-().</dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseBinaryOp.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions. ">CwiseBinaryOp</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a1042124b0ddee66e78ac7b0a9ac4cc9c">operator-=()</a> </dd></dl>

</div>
</div>
<a id="a5c2e247775438bfa1ff6dbacc5963efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c2e247775438bfa1ff6dbacc5963efe">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const NegativeReturnType <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the opposite of <code>*this</code> </dd></dl>

</div>
</div>
<a id="a1042124b0ddee66e78ac7b0a9ac4cc9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1042124b0ddee66e78ac7b0a9ac4cc9c">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived &amp; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>replaces <code>*this</code> by <code>*this</code> - <em>other</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to <code>*this</code> </dd></dl>

</div>
</div>
<a id="a2d1864d9378be2cc8ab7b47bf9f8bb4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1864d9378be2cc8ab7b47bf9f8bb4f">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_quotient_op&lt;<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>,T&gt;,Derived,<a class="el" href="classEigen_1_1DenseBase.html#a68a7ece6c5629d1e9447a321fcb14ccd">Constant</a>&lt;T&gt; &gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of <code>*this</code> divided by the scalar value <em>scalar</em> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is the scalar type of <em>scalar</em>. It must be compatible with the scalar type of the given expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a373bf62ad398162df5a71963ed7cbeff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373bf62ad398162df5a71963ed7cbeff">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived &amp; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Special case of the template operator=, in order to prevent the compiler from generating a default operator= (issue hit with g++ 4.1) </p>

</div>
</div>
<a id="a80e3e1e83fdf43f9f7fb6ff51836b24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e3e1e83fdf43f9f7fb6ff51836b24d">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if each coefficients of <code>*this</code> and <em>other</em> are all exactly equal. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>When using floating point scalar values you probably should rather use a fuzzy comparison such as <a class="el" href="classEigen_1_1DenseBase.html#ae8443357b808cd393be1b51974213f9c">isApprox()</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#ae8443357b808cd393be1b51974213f9c">isApprox()</a>, operator!= </dd></dl>

</div>
</div>
<a id="a0ff9bc0b9bea2d0822a2bf3192783102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff9bc0b9bea2d0822a2bf3192783102">&#9670;&nbsp;</a></span>operatorNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::RealScalar <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operatorNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the L2 operator norm. </p>
<dl class="section return"><dt>Returns</dt><dd>Operator norm of the matrix.</dd></dl>
<p>This is defined in the Eigenvalues module.</p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Eigenvalues&gt;</span> </div></div><!-- fragment --><p> This function computes the L2 operator norm of a matrix, which is also known as the spectral norm. The norm of a matrix <img class="formulaInl" alt="$ A $" src="form_1.png"/> is defined to be </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \|A\|_2 = \max_x \frac{\|Ax\|_2}{\|x\|_2} \]" src="form_88.png"/>
</p>
<p> where the maximum is over all vectors and the norm on the right is the Euclidean vector norm. The norm equals the largest singular value, which is the square root of the largest eigenvalue of the positive semi-definite matrix <img class="formulaInl" alt="$ A^*A $" src="form_89.png"/>.</p>
<p>The current implementation uses the eigenvalues of <img class="formulaInl" alt="$ A^*A $" src="form_89.png"/>, as computed by <a class="el" href="classEigen_1_1SelfAdjointView.html#ad4f34424b4ea12de9bbc5623cb938b4f" title="Computes the eigenvalues of a matrix. ">SelfAdjointView::eigenvalues()</a>, to compute the operator norm of a matrix. The <a class="el" href="classEigen_1_1SelfAdjointView.html" title="Expression of a selfadjoint matrix from a triangular part of a dense matrix. ">SelfAdjointView</a> class provides a better algorithm for selfadjoint matrices.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga99b41a69f0bf64eadb63a97f357ab412">MatrixXd</a> ones = <a class="code" href="classEigen_1_1DenseBase.html#a2755cb4023f7376880523626a8e05101">MatrixXd::Ones</a>(3,3);</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;The operator norm of the 3x3 matrix of ones is &quot;</span></div><div class="line">     &lt;&lt; ones.operatorNorm() &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">The operator norm of the 3x3 matrix of ones is 3
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SelfAdjointView.html#ad4f34424b4ea12de9bbc5623cb938b4f" title="Computes the eigenvalues of a matrix. ">SelfAdjointView::eigenvalues()</a>, <a class="el" href="classEigen_1_1SelfAdjointView.html#a12a7da482e31ec9c517dca92dd7bae61" title="Computes the L2 operator norm. ">SelfAdjointView::operatorNorm()</a> </dd></dl>

</div>
</div>
<a id="a6f44fface70a468cf9df2a4b33448298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f44fface70a468cf9df2a4b33448298">&#9670;&nbsp;</a></span>operator||()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_boolean_or_op, const Derived, const OtherDerived&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise boolean <b>or</b> operator of <code>*this</code> and <em>other</em> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this operator is for expression of bool only.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__arraytypedefs.html#gaaaaed220517b7fc8a3494d6b2f0361e3">Array3d</a> v(-1,2,1), <a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af683e04b3926aaf4091581ca24ca09ad">w</a>(-3,2,3);</div><div class="line">cout &lt;&lt; ((v&lt;<a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af683e04b3926aaf4091581ca24ca09ad">w</a>) || (v&lt;0)) &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">1
0
1
</pre><dl class="section see"><dt>See also</dt><dd>operator&amp;&amp;(), <a class="el" href="classEigen_1_1DenseBase.html#a65e78cfcbc9852e6923bebff4323ddca">select()</a> </dd></dl>

</div>
</div>
<a id="a6199d8aaf26c1b8ac3097fdfa7733a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6199d8aaf26c1b8ac3097fdfa7733a1e">&#9670;&nbsp;</a></span>partialPivLu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialPivLU.html">PartialPivLU</a>&lt; typename <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> &gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::partialPivLu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is defined in the LU module.</p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/LU&gt;</span> </div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>the partial-pivoting LU decomposition of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1PartialPivLU.html" title="LU decomposition of a matrix with partial pivoting, and related features. ">PartialPivLU</a> </dd></dl>

</div>
</div>
<a id="a7ae6c25e6a94a60e147741e76203a73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae6c25e6a94a60e147741e76203a73b">&#9670;&nbsp;</a></span>pow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const MatrixPowerReturnValue&lt;Derived&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::pow </td>
          <td>(</td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function requires the <a href="unsupported/group__MatrixFunctions__Module.html">unsupported MatrixFunctions module</a>. To compute the coefficient-wise power to <code>p</code> use <a class="el" href="classEigen_1_1ArrayBase.html#a9b2dc1fc2bd04821c160e0f3ab6bc9f5">ArrayBase::pow</a> . </p>
<dl class="section return"><dt>Returns</dt><dd>an expression of the matrix power to <code>p</code> of <code>*this</code>. </dd></dl>

</div>
</div>
<a id="a91dcacf224bd8b18346914bdf7eefc31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91dcacf224bd8b18346914bdf7eefc31">&#9670;&nbsp;</a></span>pow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const MatrixComplexPowerReturnValue&lt;Derived&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::pow </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; RealScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function requires the <a href="unsupported/group__MatrixFunctions__Module.html">unsupported MatrixFunctions module</a>. To compute the coefficient-wise power to <code>p</code> use <a class="el" href="classEigen_1_1ArrayBase.html#a9b2dc1fc2bd04821c160e0f3ab6bc9f5">ArrayBase::pow</a> . </p>
<dl class="section return"><dt>Returns</dt><dd>an expression of the matrix power to <code>p</code> of <code>*this</code>. </dd></dl>

</div>
</div>
<a id="a05cd7dac79f90b56495b7772bdeaa4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05cd7dac79f90b56495b7772bdeaa4b8">&#9670;&nbsp;</a></span>real() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealReturnType <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::real </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><br />
 </p>
<dl class="section return"><dt>Returns</dt><dd>a read-only expression of the real part of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ae468f7f102d5f04f20b2c0afe6eb0f82" title="  ">imag()</a> </dd></dl>

</div>
</div>
<a id="aeba1be140ede8b142460b325945c551f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba1be140ede8b142460b325945c551f">&#9670;&nbsp;</a></span>real() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NonConstRealReturnType <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::real </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><br />
 </p>
<dl class="section return"><dt>Returns</dt><dd>a non const expression of the real part of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ae468f7f102d5f04f20b2c0afe6eb0f82" title="  ">imag()</a> </dd></dl>

</div>
</div>
<a id="a67eb836f331d9b567e7f36ec0782fa07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67eb836f331d9b567e7f36ec0782fa07">&#9670;&nbsp;</a></span>selfadjointView() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;unsigned int UpLo&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt;Derived&gt;::template ConstSelfAdjointViewReturnType&lt;UpLo&gt;::Type <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::selfadjointView </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the const version of MatrixBase::selfadjointView() </p>

</div>
</div>
<a id="ad446541377593656c1399862fe6a0f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad446541377593656c1399862fe6a0f94">&#9670;&nbsp;</a></span>selfadjointView() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;unsigned int UpLo&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt;Derived&gt;::template SelfAdjointViewReturnType&lt;UpLo&gt;::Type <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::selfadjointView </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a symmetric/self-adjoint view extracted from the upper or lower triangular part of the current matrix</dd></dl>
<p>The parameter <em>UpLo</em> can be either <code><a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1">Upper</a></code> or <code><a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749">Lower</a></code> </p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gaf5dfa8fd62427c5f3c8035daf15ebfcb">Matrix3i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the symmetric matrix extracted from the upper part of m:&quot;</span> &lt;&lt; endl</div><div class="line">     &lt;&lt; <a class="code" href="group__matrixtypedefs.html#gaf5dfa8fd62427c5f3c8035daf15ebfcb">Matrix3i</a>(m.selfadjointView&lt;<a class="code" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1">Upper</a>&gt;()) &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the symmetric matrix extracted from the lower part of m:&quot;</span> &lt;&lt; endl</div><div class="line">     &lt;&lt; <a class="code" href="group__matrixtypedefs.html#gaf5dfa8fd62427c5f3c8035daf15ebfcb">Matrix3i</a>(m.selfadjointView&lt;<a class="code" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749">Lower</a>&gt;()) &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
 7  6 -3
-2  9  6
 6 -6 -5
Here is the symmetric matrix extracted from the upper part of m:
 7  6 -3
 6  9  6
-3  6 -5
Here is the symmetric matrix extracted from the lower part of m:
 7 -2  6
-2  9 -6
 6 -6 -5
</pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1SelfAdjointView.html" title="Expression of a selfadjoint matrix from a triangular part of a dense matrix. ">SelfAdjointView</a> </dd></dl>

</div>
</div>
<a id="a18e969adfdf2db4ac44c47fbdc854683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e969adfdf2db4ac44c47fbdc854683">&#9670;&nbsp;</a></span>setIdentity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived &amp; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::setIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes the identity expression (not necessarily square) into *this.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gace49b1dc3432f8a6639966a2cb7178be">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a422ddeef58bedc7bddb1d4357688d761">Matrix4i::Zero</a>();</div><div class="line">m.block&lt;3,3&gt;(1,0).<a class="code" href="classEigen_1_1MatrixBase.html#a18e969adfdf2db4ac44c47fbdc854683">setIdentity</a>();</div><div class="line">cout &lt;&lt; m &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">0 0 0 0
1 0 0 0
0 1 0 0
0 0 1 0
</pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor. ">CwiseNullaryOp</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">Identity()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#acf33ce20ef03ead47cb3dbcd5f416ede">Identity(Index,Index)</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a4ccbd8dfa06e9d47b9bf84711f8b9d40">isIdentity()</a> </dd></dl>

</div>
</div>
<a id="a97dec020729928e328fe8ae9aad1e99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97dec020729928e328fe8ae9aad1e99e">&#9670;&nbsp;</a></span>setIdentity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived &amp; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::setIdentity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes to the given size, and writes the identity expression (not necessarily square) into *this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>the new number of rows </td></tr>
    <tr><td class="paramname">cols</td><td>the new number of columns</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga731599f782380312960376c43450eb48">MatrixXf</a> m;</div><div class="line">m.setIdentity(3, 3);</div><div class="line">cout &lt;&lt; m &lt;&lt; endl;</div></div><!-- fragment --><p> Output: </p><pre class="fragment">1 0 0
0 1 0
0 0 1
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a18e969adfdf2db4ac44c47fbdc854683">MatrixBase::setIdentity()</a>, class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor. ">CwiseNullaryOp</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">MatrixBase::Identity()</a> </dd></dl>

</div>
</div>
<a id="a02f4ff0fcbbae2f3ccaa5981e8ad5e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f4ff0fcbbae2f3ccaa5981e8ad5e34">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const MatrixFunctionReturnValue&lt;Derived&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::sin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function requires the <a href="unsupported/group__MatrixFunctions__Module.html">unsupported MatrixFunctions module</a>. To compute the coefficient-wise sine use <a class="el" href="classEigen_1_1ArrayBase.html#ae865fde726793307cf91245393e6c79d">ArrayBase::sin</a> . </p>
<dl class="section return"><dt>Returns</dt><dd>an expression of the matrix sine of <code>*this</code>. </dd></dl>

</div>
</div>
<a id="a9c37eab2dc7baf83809269254c9129e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c37eab2dc7baf83809269254c9129e0">&#9670;&nbsp;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const MatrixFunctionReturnValue&lt;Derived&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::sinh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function requires the <a href="unsupported/group__MatrixFunctions__Module.html">unsupported MatrixFunctions module</a>. To compute the coefficient-wise hyperbolic sine use <a class="el" href="classEigen_1_1ArrayBase.html#a343f3b40026376ce47c171d140570a78">ArrayBase::sinh</a> . </p>
<dl class="section return"><dt>Returns</dt><dd>an expression of the matrix hyperbolic sine of <code>*this</code>. </dd></dl>

</div>
</div>
<a id="ad873dca860bd47baeeede8663e161b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad873dca860bd47baeeede8663e161b83">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const MatrixSquareRootReturnValue&lt;Derived&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::sqrt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function requires the <a href="unsupported/group__MatrixFunctions__Module.html">unsupported MatrixFunctions module</a>. To compute the coefficient-wise square root use <a class="el" href="classEigen_1_1ArrayBase.html#adbe7fe792be28d5293ae6a586b36c028">ArrayBase::sqrt</a> . </p>
<dl class="section return"><dt>Returns</dt><dd>an expression of the matrix square root of <code>*this</code>. </dd></dl>

</div>
</div>
<a id="ac8da566526419f9742a6c471bbd87e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8da566526419f9742a6c471bbd87e0a">&#9670;&nbsp;</a></span>squaredNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; typename internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::Real <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::squaredNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>, for vectors, the squared <em>l2</em> norm of <code>*this</code>, and for matrices the Frobenius norm. In both cases, it consists in the sum of the square of all the matrix entries. For vectors, this is also equals to the dot product of <code>*this</code> with itself.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#adfd32bf5fcf6ee603c924dde9bf7bc39">dot()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a196c4ec3c8ffdf5bda45d0f617154975">norm()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a72586ab059e889e7d2894ff227747e35">lpNorm()</a> </dd></dl>

</div>
</div>
<a id="ab84d3e64f855813b1eea4202c0697dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84d3e64f855813b1eea4202c0697dc1">&#9670;&nbsp;</a></span>stableNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; typename internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> &gt;::Real <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::stableNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <em>l2</em> norm of <code>*this</code> avoiding underflow and overflow. This version use a blockwise two passes algorithm: 1 - find the absolute largest coefficient <code>s</code> 2 - compute <img class="formulaInl" alt="$ s \Vert \frac{*this}{s} \Vert $" src="form_31.png"/> in a standard way</dd></dl>
<p>For architecture/scalar types supporting vectorization, this version is faster than <a class="el" href="classEigen_1_1MatrixBase.html#a3f3faa00163c16824ff03e58a210c74c">blueNorm()</a>. Otherwise the <a class="el" href="classEigen_1_1MatrixBase.html#a3f3faa00163c16824ff03e58a210c74c">blueNorm()</a> is much faster.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a196c4ec3c8ffdf5bda45d0f617154975">norm()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a3f3faa00163c16824ff03e58a210c74c">blueNorm()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a32222d3b6677e6cdf0b801463f329b72">hypotNorm()</a> </dd></dl>

</div>
</div>
<a id="a0b1443fa322615379557ade3399a3c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1443fa322615379557ade3399a3c3c">&#9670;&nbsp;</a></span>stableNormalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::stableNormalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Normalizes the vector while avoid underflow and overflow</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>This method is analogue to the <a class="el" href="classEigen_1_1MatrixBase.html#ad16303c47ba36f7a41ea264cb26bceb6">normalize()</a> method, but it reduces the risk of underflow and overflow when computing the norm.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the input vector is too small (i.e., this-&gt;<a class="el" href="classEigen_1_1MatrixBase.html#a196c4ec3c8ffdf5bda45d0f617154975">norm()</a>==0), then <code>*this</code> is left unchanged.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ab84d3e64f855813b1eea4202c0697dc1">stableNorm()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a399dca938633b9f8df5ec4beefeccec0">stableNormalized()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#ad16303c47ba36f7a41ea264cb26bceb6">normalize()</a> </dd></dl>

</div>
</div>
<a id="a399dca938633b9f8df5ec4beefeccec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399dca938633b9f8df5ec4beefeccec0">&#9670;&nbsp;</a></span>stableNormalized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#aae45af9b5aca5a9caae98fd201f47cc4">PlainObject</a> <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::stableNormalized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the quotient of <code>*this</code> by its own norm while avoiding underflow and overflow.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>This method is analogue to the <a class="el" href="classEigen_1_1MatrixBase.html#a5cf2fd4c57e59604fd4116158fd34308">normalized()</a> method, but it reduces the risk of underflow and overflow when computing the norm.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the input vector is too small (i.e., this-&gt;<a class="el" href="classEigen_1_1MatrixBase.html#a196c4ec3c8ffdf5bda45d0f617154975">norm()</a>==0), then this function returns a copy of the input.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ab84d3e64f855813b1eea4202c0697dc1">stableNorm()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a0b1443fa322615379557ade3399a3c3c">stableNormalize()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a5cf2fd4c57e59604fd4116158fd34308">normalized()</a> </dd></dl>

</div>
</div>
<a id="a544b609f65eb2bd3e368b3fc2d79479e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544b609f65eb2bd3e368b3fc2d79479e">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the trace of <code>*this</code>, i.e. the sum of the coefficients on the main diagonal.</dd></dl>
<p><code>*this</code> can be any matrix, not necessarily square.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ab5768147536273eb2dbdfa389cfd26a3">diagonal()</a>, <a class="el" href="classEigen_1_1DenseBase.html#addd7080d5c202795820e361768d0140c">sum()</a> </dd></dl>

</div>
</div>
<a id="a56665aa894f49f2765291fee0eaeb9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56665aa894f49f2765291fee0eaeb9c6">&#9670;&nbsp;</a></span>triangularView() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;unsigned int Mode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt;Derived&gt;::template TriangularViewReturnType&lt;Mode&gt;::Type <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::triangularView </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a triangular view extracted from the current matrix</dd></dl>
<p>The parameter <em>Mode</em> can have the following values: <code><a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1">Upper</a></code>, <code><a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda7b37877e0b9b0df28c9c2b669a633265">StrictlyUpper</a></code>, <code><a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdadd28224d7ea92689930be73c1b50b0ad">UnitUpper</a></code>, <code><a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749">Lower</a></code>, <code><a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda2424988b6fca98be70b595632753ba81">StrictlyLower</a></code>, <code><a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda8f40b928c10a71ba03e5f75ad2a72fda">UnitLower</a></code>.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gaf5dfa8fd62427c5f3c8035daf15ebfcb">Matrix3i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3i::Random</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the upper-triangular matrix extracted from m:&quot;</span> &lt;&lt; endl</div><div class="line">     &lt;&lt; <a class="code" href="group__matrixtypedefs.html#gaf5dfa8fd62427c5f3c8035daf15ebfcb">Matrix3i</a>(m.triangularView&lt;<a class="code" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1">Eigen::Upper</a>&gt;()) &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the strictly-upper-triangular matrix extracted from m:&quot;</span> &lt;&lt; endl</div><div class="line">     &lt;&lt; <a class="code" href="group__matrixtypedefs.html#gaf5dfa8fd62427c5f3c8035daf15ebfcb">Matrix3i</a>(m.triangularView&lt;<a class="code" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda7b37877e0b9b0df28c9c2b669a633265">Eigen::StrictlyUpper</a>&gt;()) &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the unit-lower-triangular matrix extracted from m:&quot;</span> &lt;&lt; endl</div><div class="line">     &lt;&lt; <a class="code" href="group__matrixtypedefs.html#gaf5dfa8fd62427c5f3c8035daf15ebfcb">Matrix3i</a>(m.triangularView&lt;<a class="code" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda8f40b928c10a71ba03e5f75ad2a72fda">Eigen::UnitLower</a>&gt;()) &lt;&lt; endl;</div><div class="line"><span class="comment">// FIXME need to implement output for triangularViews (Bug 885)</span></div></div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
 7  6 -3
-2  9  6
 6 -6 -5
Here is the upper-triangular matrix extracted from m:
 7  6 -3
 0  9  6
 0  0 -5
Here is the strictly-upper-triangular matrix extracted from m:
 0  6 -3
 0  0  6
 0  0  0
Here is the unit-lower-triangular matrix extracted from m:
 1  0  0
-2  1  0
 6 -6  1
</pre><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1TriangularView.html" title="Expression of a triangular part in a matrix. ">TriangularView</a> </dd></dl>

</div>
</div>
<a id="aa044521145e74117ad1df42460d7b520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa044521145e74117ad1df42460d7b520">&#9670;&nbsp;</a></span>triangularView() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;unsigned int Mode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt;Derived&gt;::template ConstTriangularViewReturnType&lt;Mode&gt;::Type <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::triangularView </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the const version of MatrixBase::triangularView() </p>

</div>
</div>
<a id="a3929764ba38ac4eeca46274a0bf3a7b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3929764ba38ac4eeca46274a0bf3a7b3">&#9670;&nbsp;</a></span>unaryExpr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename CustomUnaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;CustomUnaryOp, const Derived&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::unaryExpr </td>
          <td>(</td>
          <td class="paramtype">const CustomUnaryOp &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code>CustomUnaryOp()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a unary operator coefficient-wise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Functor implementing the unary operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CustomUnaryOp</td><td>Type of <em>func</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An expression of a custom coefficient-wise unary operator <em>func</em> of *this</dd></dl>
<p>The function <code>ptr_fun()</code> from the C++ standard library can be used to make functors out of normal functions.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"></div><div class="line"><span class="comment">// define function to be applied coefficient-wise</span></div><div class="line"><span class="keywordtype">double</span> ramp(<span class="keywordtype">double</span> <a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af163a982f5a7ad7e5c3336990b3d7000">x</a>)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af163a982f5a7ad7e5c3336990b3d7000">x</a> &gt; 0)</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af163a982f5a7ad7e5c3336990b3d7000">x</a>;</div><div class="line">  <span class="keywordflow">else</span> </div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">  <a class="code" href="classEigen_1_1Matrix.html">Matrix4d</a> m1 = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4d::Random</a>();</div><div class="line">  cout &lt;&lt; m1 &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;becomes: &quot;</span> &lt;&lt; endl &lt;&lt; m1.<a class="code" href="classEigen_1_1MatrixBase.html#a3929764ba38ac4eeca46274a0bf3a7b3">unaryExpr</a>(ptr_fun(ramp)) &lt;&lt; endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> Output: </p><pre class="fragment">   0.68   0.823  -0.444   -0.27
 -0.211  -0.605   0.108  0.0268
  0.566   -0.33 -0.0452   0.904
  0.597   0.536   0.258   0.832
becomes: 
  0.68  0.823      0      0
     0      0  0.108 0.0268
 0.566      0      0  0.904
 0.597  0.536  0.258  0.832
</pre><p>Genuine functors allow for more possibilities, for instance it may contain a state.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"></div><div class="line"><span class="comment">// define a custom template unary functor</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Scalar&gt;</div><div class="line"><span class="keyword">struct </span>CwiseClampOp {</div><div class="line">  CwiseClampOp(<span class="keyword">const</span> <a class="code" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&amp; inf, <span class="keyword">const</span> <a class="code" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&amp; sup) : m_inf(inf), m_sup(sup) {}</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> <a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#ae6ba07bad9e3026afe54806fdefe32bb">operator()</a>(<span class="keyword">const</span> <a class="code" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&amp; <a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af163a982f5a7ad7e5c3336990b3d7000">x</a>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> x&lt;m_inf ? m_inf : (x&gt;m_sup ? m_sup : <a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af163a982f5a7ad7e5c3336990b3d7000">x</a>); }</div><div class="line">  <a class="code" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> m_inf, m_sup;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">  <a class="code" href="classEigen_1_1Matrix.html">Matrix4d</a> m1 = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4d::Random</a>();</div><div class="line">  cout &lt;&lt; m1 &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;becomes: &quot;</span> &lt;&lt; endl &lt;&lt; m1.<a class="code" href="classEigen_1_1MatrixBase.html#a3929764ba38ac4eeca46274a0bf3a7b3">unaryExpr</a>(CwiseClampOp&lt;double&gt;(-0.5,0.5)) &lt;&lt; endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> Output: </p><pre class="fragment">   0.68   0.823  -0.444   -0.27
 -0.211  -0.605   0.108  0.0268
  0.566   -0.33 -0.0452   0.904
  0.597   0.536   0.258   0.832
becomes: 
    0.5     0.5  -0.444   -0.27
 -0.211    -0.5   0.108  0.0268
    0.5   -0.33 -0.0452     0.5
    0.5     0.5   0.258     0.5
</pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a2b928f32954852ffb4a103f49e3cbc18">unaryViewExpr</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a1063a3752d30b568e52c89ce4e567489">binaryExpr</a>, class <a class="el" href="classEigen_1_1CwiseUnaryOp.html" title="Generic expression where a coefficient-wise unary operator is applied to an expression. ">CwiseUnaryOp</a> </dd></dl>

</div>
</div>
<a id="a2b928f32954852ffb4a103f49e3cbc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b928f32954852ffb4a103f49e3cbc18">&#9670;&nbsp;</a></span>unaryViewExpr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename CustomViewOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryView.html">CwiseUnaryView</a>&lt;CustomViewOp, const Derived&gt; <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::unaryViewExpr </td>
          <td>(</td>
          <td class="paramtype">const CustomViewOp &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code>CustomViewOp()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a custom coefficient-wise unary operator <em>func</em> of *this</dd></dl>
<p>The template parameter <em>CustomUnaryOp</em> is the type of the functor of the custom unary operator.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"></div><div class="line"><span class="comment">// define a custom template unary functor</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Scalar&gt;</div><div class="line"><span class="keyword">struct </span>CwiseClampOp {</div><div class="line">  CwiseClampOp(<span class="keyword">const</span> <a class="code" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&amp; inf, <span class="keyword">const</span> <a class="code" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&amp; sup) : m_inf(inf), m_sup(sup) {}</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> <a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#ae6ba07bad9e3026afe54806fdefe32bb">operator()</a>(<span class="keyword">const</span> <a class="code" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&amp; <a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af163a982f5a7ad7e5c3336990b3d7000">x</a>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> x&lt;m_inf ? m_inf : (x&gt;m_sup ? m_sup : <a class="code" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#af163a982f5a7ad7e5c3336990b3d7000">x</a>); }</div><div class="line">  <a class="code" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a> m_inf, m_sup;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">  <a class="code" href="classEigen_1_1Matrix.html">Matrix4d</a> m1 = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix4d::Random</a>();</div><div class="line">  cout &lt;&lt; m1 &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;becomes: &quot;</span> &lt;&lt; endl &lt;&lt; m1.<a class="code" href="classEigen_1_1MatrixBase.html#a3929764ba38ac4eeca46274a0bf3a7b3">unaryExpr</a>(CwiseClampOp&lt;double&gt;(-0.5,0.5)) &lt;&lt; endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> Output: </p><pre class="fragment">   0.68   0.823  -0.444   -0.27
 -0.211  -0.605   0.108  0.0268
  0.566   -0.33 -0.0452   0.904
  0.597   0.536   0.258   0.832
becomes: 
    0.5     0.5  -0.444   -0.27
 -0.211    -0.5   0.108  0.0268
    0.5   -0.33 -0.0452     0.5
    0.5     0.5   0.258     0.5
</pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a3929764ba38ac4eeca46274a0bf3a7b3" title="Apply a unary operator coefficient-wise. ">unaryExpr</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a1063a3752d30b568e52c89ce4e567489">binaryExpr</a> class <a class="el" href="classEigen_1_1CwiseUnaryOp.html" title="Generic expression where a coefficient-wise unary operator is applied to an expression. ">CwiseUnaryOp</a> </dd></dl>

</div>
</div>
<a id="ac7a03a61014f37ddd2fe61ebac0c9539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a03a61014f37ddd2fe61ebac0c9539">&#9670;&nbsp;</a></span>Unit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::BasisReturnType <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::Unit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the i-th unit (basis) vector.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a9daf6d22d10ed8ae00432b0f641455df">MatrixBase::Unit(Index)</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a8a555b7cf626cced54670b98668c4e6d">MatrixBase::UnitX()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a00850083489e20249b1d05b394fc5efc">MatrixBase::UnitY()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#aabdcdeff1c822a5465fcbe1f78e5afe0">MatrixBase::UnitZ()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#af56ba94e5b0330827003eadd26cfadc2">MatrixBase::UnitW()</a> </dd></dl>

</div>
</div>
<a id="a9daf6d22d10ed8ae00432b0f641455df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9daf6d22d10ed8ae00432b0f641455df">&#9670;&nbsp;</a></span>Unit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::BasisReturnType <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::Unit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEigen_1_1EigenBase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the i-th unit (basis) vector.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>This variant is for fixed-size vector only.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ac7a03a61014f37ddd2fe61ebac0c9539">MatrixBase::Unit(Index,Index)</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a8a555b7cf626cced54670b98668c4e6d">MatrixBase::UnitX()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a00850083489e20249b1d05b394fc5efc">MatrixBase::UnitY()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#aabdcdeff1c822a5465fcbe1f78e5afe0">MatrixBase::UnitZ()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#af56ba94e5b0330827003eadd26cfadc2">MatrixBase::UnitW()</a> </dd></dl>

</div>
</div>
<a id="af56ba94e5b0330827003eadd26cfadc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af56ba94e5b0330827003eadd26cfadc2">&#9670;&nbsp;</a></span>UnitW()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::BasisReturnType <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::UnitW </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the W axis unit vector (0,0,0,1)</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ac7a03a61014f37ddd2fe61ebac0c9539">MatrixBase::Unit(Index,Index)</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a9daf6d22d10ed8ae00432b0f641455df">MatrixBase::Unit(Index)</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a00850083489e20249b1d05b394fc5efc">MatrixBase::UnitY()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#aabdcdeff1c822a5465fcbe1f78e5afe0">MatrixBase::UnitZ()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#af56ba94e5b0330827003eadd26cfadc2">MatrixBase::UnitW()</a> </dd></dl>

</div>
</div>
<a id="a8a555b7cf626cced54670b98668c4e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a555b7cf626cced54670b98668c4e6d">&#9670;&nbsp;</a></span>UnitX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::BasisReturnType <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::UnitX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the X axis unit vector (1{,0}^*)</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ac7a03a61014f37ddd2fe61ebac0c9539">MatrixBase::Unit(Index,Index)</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a9daf6d22d10ed8ae00432b0f641455df">MatrixBase::Unit(Index)</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a00850083489e20249b1d05b394fc5efc">MatrixBase::UnitY()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#aabdcdeff1c822a5465fcbe1f78e5afe0">MatrixBase::UnitZ()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#af56ba94e5b0330827003eadd26cfadc2">MatrixBase::UnitW()</a> </dd></dl>

</div>
</div>
<a id="a00850083489e20249b1d05b394fc5efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00850083489e20249b1d05b394fc5efc">&#9670;&nbsp;</a></span>UnitY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::BasisReturnType <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::UnitY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the Y axis unit vector (0,1{,0}^*)</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ac7a03a61014f37ddd2fe61ebac0c9539">MatrixBase::Unit(Index,Index)</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a9daf6d22d10ed8ae00432b0f641455df">MatrixBase::Unit(Index)</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a00850083489e20249b1d05b394fc5efc">MatrixBase::UnitY()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#aabdcdeff1c822a5465fcbe1f78e5afe0">MatrixBase::UnitZ()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#af56ba94e5b0330827003eadd26cfadc2">MatrixBase::UnitW()</a> </dd></dl>

</div>
</div>
<a id="aabdcdeff1c822a5465fcbe1f78e5afe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabdcdeff1c822a5465fcbe1f78e5afe0">&#9670;&nbsp;</a></span>UnitZ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Derived &gt;::BasisReturnType <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; Derived &gt;::UnitZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the Z axis unit vector (0,0,1{,0}^*)</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ac7a03a61014f37ddd2fe61ebac0c9539">MatrixBase::Unit(Index,Index)</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a9daf6d22d10ed8ae00432b0f641455df">MatrixBase::Unit(Index)</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a00850083489e20249b1d05b394fc5efc">MatrixBase::UnitY()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#aabdcdeff1c822a5465fcbe1f78e5afe0">MatrixBase::UnitZ()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#af56ba94e5b0330827003eadd26cfadc2">MatrixBase::UnitW()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a8fc2c86eca0e76d5264e285ff4eea079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc2c86eca0e76d5264e285ff4eea079">&#9670;&nbsp;</a></span>operator*</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_product_op&lt;T,<a class="el" href="classEigen_1_1DenseBase.html#a5feed465b3a8e60c47e73ecce83e39a2">Scalar</a>&gt;,<a class="el" href="classEigen_1_1DenseBase.html#a68a7ece6c5629d1e9447a321fcb14ccd">Constant</a>&lt;T&gt;,Derived&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StorageBaseType &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of <em>expr</em> scaled by the scalar factor <em>scalar</em> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is the scalar type of <em>scalar</em>. It must be compatible with the scalar type of the given expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="MatrixBase_8h_source.html">MatrixBase.h</a></li>
<li><a class="el" href="LDLT_8h_source.html">LDLT.h</a></li>
<li><a class="el" href="LLT_8h_source.html">LLT.h</a></li>
<li><a class="el" href="Assign_8h_source.html">Assign.h</a></li>
<li><a class="el" href="CwiseBinaryOp_8h_source.html">CwiseBinaryOp.h</a></li>
<li><a class="el" href="CwiseNullaryOp_8h_source.html">CwiseNullaryOp.h</a></li>
<li><a class="el" href="Diagonal_8h_source.html">Diagonal.h</a></li>
<li><a class="el" href="DiagonalMatrix_8h_source.html">DiagonalMatrix.h</a></li>
<li><a class="el" href="DiagonalProduct_8h_source.html">DiagonalProduct.h</a></li>
<li><a class="el" href="Dot_8h_source.html">Dot.h</a></li>
<li><a class="el" href="ForceAlignedAccess_8h_source.html">ForceAlignedAccess.h</a></li>
<li><a class="el" href="GeneralProduct_8h_source.html">GeneralProduct.h</a></li>
<li><a class="el" href="NoAlias_8h_source.html">NoAlias.h</a></li>
<li><a class="el" href="PermutationMatrix_8h_source.html">PermutationMatrix.h</a></li>
<li><a class="el" href="Redux_8h_source.html">Redux.h</a></li>
<li><a class="el" href="SelfAdjointView_8h_source.html">SelfAdjointView.h</a></li>
<li><a class="el" href="StableNorm_8h_source.html">StableNorm.h</a></li>
<li><a class="el" href="Transpose_8h_source.html">Transpose.h</a></li>
<li><a class="el" href="TriangularMatrix_8h_source.html">TriangularMatrix.h</a></li>
<li><a class="el" href="MatrixBaseEigenvalues_8h_source.html">MatrixBaseEigenvalues.h</a></li>
<li><a class="el" href="EulerAngles_8h_source.html">EulerAngles.h</a></li>
<li><a class="el" href="Homogeneous_8h_source.html">Homogeneous.h</a></li>
<li><a class="el" href="OrthoMethods_8h_source.html">OrthoMethods.h</a></li>
<li><a class="el" href="Householder_8h_source.html">Householder.h</a></li>
<li><a class="el" href="Jacobi_8h_source.html">Jacobi.h</a></li>
<li><a class="el" href="Determinant_8h_source.html">Determinant.h</a></li>
<li><a class="el" href="FullPivLU_8h_source.html">FullPivLU.h</a></li>
<li><a class="el" href="InverseImpl_8h_source.html">InverseImpl.h</a></li>
<li><a class="el" href="PartialPivLU_8h_source.html">PartialPivLU.h</a></li>
<li><a class="el" href="ColPivHouseholderQR_8h_source.html">ColPivHouseholderQR.h</a></li>
<li><a class="el" href="CompleteOrthogonalDecomposition_8h_source.html">CompleteOrthogonalDecomposition.h</a></li>
<li><a class="el" href="FullPivHouseholderQR_8h_source.html">FullPivHouseholderQR.h</a></li>
<li><a class="el" href="HouseholderQR_8h_source.html">HouseholderQR.h</a></li>
<li><a class="el" href="SparseView_8h_source.html">SparseView.h</a></li>
<li><a class="el" href="BDCSVD_8h_source.html">BDCSVD.h</a></li>
<li><a class="el" href="JacobiSVD_8h_source.html">JacobiSVD.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceEigen.html">Eigen</a></li><li class="navelem"><a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a></li>
    <li class="footer">Generated on Mon Jan 6 2020 06:37:51 for Eigen by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
<!-- Matomo -->
<script type="text/javascript">
  var _paq = _paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//stats.sylphide-consulting.com/matomo/";
    _paq.push(['setTrackerUrl', u+'piwik.php']);
    _paq.push(['setSiteId', '20']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'piwik.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<noscript><p><img src="//stats.sylphide-consulting.com/matomo/piwik.php?idsite=20&rec=1" style="border:0;" alt="" /></p></noscript>
<!-- End Matomo Code -->
</body>
</html>
